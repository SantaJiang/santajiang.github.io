<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="蒋胜达">





<title>2024.05社招面经 | Santa&#39;s Blog</title>



    <link rel="icon" href="/images/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Santa's Blog" type="application/atom+xml">
</head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Santa&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">文章</a>
                
                    <a class="menu-item" href="/categories">归档</a>
                
                    <a class="menu-item" href="/tags">标签</a>
                
                    <a class="menu-item" href="/project">项目</a>
                
                    <a class="menu-item" href="/about">关于</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Santa&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">文章</a>
                
                    <a class="menu-item" href="/categories">归档</a>
                
                    <a class="menu-item" href="/tags">标签</a>
                
                    <a class="menu-item" href="/project">项目</a>
                
                    <a class="menu-item" href="/about">关于</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">2024.05社招面经</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">蒋胜达</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">六月 14, 2024&nbsp;&nbsp;15:09</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/%E9%9D%A2%E8%AF%95/">面试</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h2 id="全部都是实际面试中被问到的"><a href="#全部都是实际面试中被问到的" class="headerlink" title="全部都是实际面试中被问到的"></a>全部都是实际面试中被问到的</h2><h3 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h3><h4 id="智能指针的几种类型，分别的作用和场景"><a href="#智能指针的几种类型，分别的作用和场景" class="headerlink" title="智能指针的几种类型，分别的作用和场景"></a>智能指针的几种类型，分别的作用和场景</h4><p>类型：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">C++中的智能指针主要是为了解决原始指针可能导致的内存泄漏和悬挂指针问题，通过封装和自动管理动态分配的内存来提高代码的安全性和可靠性。以下是几种常见的智能指针类型及其作用：</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 1.std::unique<span class="emphasis">_ptr:</span></span><br><span class="line"><span class="emphasis">作用: 提供独占所有权的智能指针。一个unique_</span>ptr实例在任何时候都拥有它所指向对象的唯一所有权，并且在其生命周期结束时自动删除所指向的对象。这确保了资源的唯一性和自动清理，防止了资源的重复释放。</span><br><span class="line"><span class="code">    </span></span><br><span class="line"><span class="code">- 2.std::shared_ptr:</span></span><br><span class="line"><span class="code">作用: 实现共享所有权的智能指针。允许多个shared_ptr实例共享同一个对象的所有权。通过引用计数机制管理对象的生命周期，当最后一个指向对象的shared_ptr销毁时，对象会被自动删除。适合于多个对象或作用域需要共享资源的场景。</span></span><br><span class="line"><span class="code">    </span></span><br><span class="line"><span class="code">- 3.std::weak_ptr:</span></span><br><span class="line"><span class="code">作用: 是一种非拥有型的智能指针，用于解决shared_ptr循环引用的问题。weak_ptr可以观察但不增加它所指向对象的引用计数。通常与shared_ptr配合使用，当需要访问一个对象但又不想影响其生命周期时非常有用。</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>场景：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//unique_ptr: 想象一下你正在编写一个简单的游戏，游戏中每个玩家都有一个独一无二的武器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Weapon</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Weapon</span>(<span class="keyword">const</span> std::string&amp; name) : <span class="built_in">name_</span>(name) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Weapon</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Weapon &quot;</span> &lt;&lt; name_ &lt;&lt; <span class="string">&quot; is destroyed.&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">use</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Firing &quot;</span> &lt;&lt; name_ &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Player</span>(std::unique_ptr&lt;Weapon&gt; weapon) : <span class="built_in">weapon_</span>(std::<span class="built_in">move</span>(weapon)) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">attack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( ) &#123;</span><br><span class="line">            weapon_-&gt;<span class="built_in">use</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;No weapon to use!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unique_ptr&lt;Weapon&gt; weapon_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> sword = std::make_unique&lt;Weapon&gt;(<span class="string">&quot;Sword of Darkness&quot;</span>);</span><br><span class="line">    <span class="function">Player <span class="title">player</span><span class="params">(std::move(sword))</span></span>; <span class="comment">// 将剑的所有权转移给玩家</span></span><br><span class="line">    player.<span class="built_in">attack</span>(); <span class="comment">// 使用剑攻击</span></span><br><span class="line">    <span class="comment">// 此时sword已经无效，剑的生命周期完全由Player管理</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在这个例子中，每个玩家通过 unique_ptr 拥有一把独特的武器。当玩家对象被销毁时，其所拥有的武器也会自动被销毁，实现了资源的自动管理。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//shared_ptr: 考虑一个文档编辑软件，其中多个标签页可以打开并共享同一个文档。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Document</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Document</span>(<span class="keyword">const</span> std::string&amp; title) : <span class="built_in">title_</span>(title) &#123; std::cout &lt;&lt; <span class="string">&quot;Document &quot;</span> &lt;&lt; title_ &lt;&lt; <span class="string">&quot; created.&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    ~<span class="built_in">Document</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Document &quot;</span> &lt;&lt; title_ &lt;&lt; <span class="string">&quot; closed.&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string title_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tab</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Tab</span>(std::shared_ptr&lt;Document&gt; doc) : <span class="built_in">document_</span>(doc) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;Document&gt; document_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> doc = std::make_shared&lt;Document&gt;(<span class="string">&quot;My Important Document&quot;</span>); <span class="comment">// 创建一个文档</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">Tab <span class="title">tab1</span><span class="params">(doc)</span></span>; <span class="comment">// 新建一个标签页，共享文档</span></span><br><span class="line">        <span class="function">Tab <span class="title">tab2</span><span class="params">(doc)</span></span>; <span class="comment">// 再新建一个标签页，同样共享文档</span></span><br><span class="line">        <span class="comment">// 当tab1和tab2离开作用域时，它们不会删除文档，因为文档还在被共享</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当所有标签页关闭且没有其他共享者时，文档才会被自动销毁</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在这个场景中，多个 Tab（标签页）对象通过 shared_ptr 共享同一个 Document（文档）对象。只有当所有引用该文档的标签页都被关闭（即没有更多的 shared_ptr 引用它）时，文档才会被自动删除，确保了资源的有效共享和管理。</span></span><br></pre></td></tr></table></figure>
<h4 id="智能指针的常用接口"><a href="#智能指针的常用接口" class="headerlink" title="智能指针的常用接口"></a>智能指针的常用接口</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">`unique_ptr`</span> 和 <span class="code">`shared_ptr`</span> 是 C++ 中两种常用的智能指针，它们都用于自动管理动态分配的内存，但各自有不同的特性和接口设计来满足不同的使用场景。</span><br><span class="line"></span><br><span class="line">unique<span class="emphasis">_ptr 常用接口</span></span><br><span class="line"><span class="emphasis">1. 构造和析构</span></span><br><span class="line"><span class="emphasis">   - `unique_</span>ptr<span class="xml"><span class="tag">&lt;<span class="name">T</span>&gt;</span></span>`：默认构造函数，创建一个不持有任何对象的 unique<span class="emphasis">_ptr。</span></span><br><span class="line"><span class="emphasis">   - `unique_</span>ptr<span class="xml"><span class="tag">&lt;<span class="name">T</span>&gt;</span></span>(new T(args...))`：直接在构造时分配并持有对象。</span><br><span class="line"><span class="bullet">   -</span> 析构函数：自动删除所持有的对象。</span><br><span class="line"><span class="bullet">2.</span> 移动语义</span><br><span class="line"><span class="bullet">   -</span> <span class="code">`unique_ptr&lt;T&gt;(unique_ptr&lt;T&gt;&amp;&amp;)`</span>：移动构造函数，将另一个 unique<span class="emphasis">_ptr 的资源转移给自己。</span></span><br><span class="line"><span class="emphasis">   - `unique_</span>ptr&amp; operator=(unique<span class="emphasis">_ptr<span class="xml"><span class="tag">&lt;<span class="name">T</span>&gt;</span></span>&amp;&amp;)`：移动赋值运算符，类似移动构造，转移资源并清空右值。</span></span><br><span class="line"><span class="emphasis">3. 获取原始指针</span></span><br><span class="line"><span class="emphasis">   - `T* get() const noexcept`：返回所指向的对象的原始指针。</span></span><br><span class="line"><span class="emphasis">4. 释放所有权</span></span><br><span class="line"><span class="emphasis">   - `T* release()`：释放所有权但不删除对象，返回原始指针。</span></span><br><span class="line"><span class="emphasis">   - `void reset(T* ptr = nullptr)`：释放当前持有的对象（如果有的话），并可选地持有新对象的指针。</span></span><br><span class="line"><span class="emphasis">5. 自定义删除器</span></span><br><span class="line"><span class="emphasis">   - `template <span class="xml"><span class="tag">&lt;<span class="name">class</span> <span class="attr">D</span>&gt;</span></span> unique_</span>ptr<span class="xml">&lt;T, D&gt;</span>(T<span class="emphasis">* ptr, D deleter)`：构造函数，使用自定义删除器。</span></span><br><span class="line"><span class="emphasis">   - `template <span class="xml"><span class="tag">&lt;<span class="name">class</span> <span class="attr">D</span>&gt;</span></span> void reset(T*</span> ptr, D deleter)`：重置智能指针并设置新的删除器。</span><br><span class="line"></span><br><span class="line">shared<span class="emphasis">_ptr 常用接口</span></span><br><span class="line"><span class="emphasis">1. 构造和析构</span></span><br><span class="line"><span class="emphasis">   - 与 `unique_</span>ptr` 类似，但 shared<span class="emphasis">_ptr 还支持拷贝构造和赋值，因为它是共享所有权的。</span></span><br><span class="line"><span class="emphasis">2. 拷贝和赋值</span></span><br><span class="line"><span class="emphasis">   - `shared_</span>ptr(const shared<span class="emphasis">_ptr<span class="xml"><span class="tag">&lt;<span class="name">T</span>&gt;</span></span>&amp;)`：拷贝构造函数，共享同一个控制块和对象。</span></span><br><span class="line"><span class="emphasis">   - `shared_</span>ptr&amp; operator=(const shared<span class="emphasis">_ptr<span class="xml"><span class="tag">&lt;<span class="name">T</span>&gt;</span></span>&amp;)`：拷贝赋值运算符，同样共享控制块和对象。</span></span><br><span class="line"><span class="emphasis">3. 引用计数</span></span><br><span class="line"><span class="emphasis">   - 无直接操作引用计数的接口，但可以通过 `use_</span>count()` 查询当前引用计数。</span><br><span class="line"><span class="bullet">   -</span> <span class="code">`long use_count() const noexcept`</span>：返回当前引用计数。</span><br><span class="line"><span class="bullet">4.</span> 获取原始指针</span><br><span class="line"><span class="bullet">   -</span> <span class="code">`T* get() const noexcept`</span>：同 <span class="code">`unique_ptr`</span>。</span><br><span class="line"><span class="bullet">5.</span> 释放所有权</span><br><span class="line"><span class="bullet">   -</span> 无需手动释放，当引用计数降至0时，自动删除对象。</span><br><span class="line"><span class="bullet">6.</span> 自定义删除器</span><br><span class="line"><span class="bullet">   -</span> 构造函数和 <span class="code">`reset()`</span> 方法同样支持传递自定义删除器。</span><br><span class="line"><span class="bullet">7.</span> 其他</span><br><span class="line"><span class="bullet">   -</span> <span class="code">`bool unique() const noexcept`</span>：检查是否只有一个 shared<span class="emphasis">_ptr 实例指向对象。</span></span><br><span class="line"><span class="emphasis">   - `void swap(shared_</span>ptr<span class="xml"><span class="tag">&lt;<span class="name">T</span>&gt;</span></span>&amp; other) noexcept`：交换两个 shared<span class="emphasis">_ptr 的资源。</span></span><br></pre></td></tr></table></figure>

<h4 id="shared-ptr内部的引用计数，怎么实现的"><a href="#shared-ptr内部的引用计数，怎么实现的" class="headerlink" title="shared_ptr内部的引用计数，怎么实现的"></a>shared_ptr内部的引用计数，怎么实现的</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">`shared_ptr`</span> 的内部引用计数机制是通过一个称为“控制块”（control block）的数据结构来实现的，这个控制块通常包含以下几个关键部分：</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 引用计数器（Reference Count）：记录当前有多少个 <span class="code">`shared_ptr`</span> 实例共享同一个对象。当创建一个新的 <span class="code">`shared_ptr`</span> 实例或者拷贝现有的 <span class="code">`shared_ptr`</span> 时，引用计数会递增；当一个 <span class="code">`shared_ptr`</span> 实例被销毁或者被重置时，引用计数会递减。</span><br><span class="line"><span class="bullet">2.</span> 弱引用计数器（Weak Reference Count）：专门用于跟踪 <span class="code">`weak_ptr`</span> 实例，与 <span class="code">`shared_ptr`</span> 的引用计数独立。这个计数不影响对象的生命周期，但可以用来判断对象是否已经被销毁。</span><br><span class="line"><span class="bullet">3.</span> 对象指针：指向被管理的实际对象的指针。</span><br><span class="line"><span class="bullet">4.</span> 自定义删除器（可选）：存储用户提供的删除器，用于在对象不再被任何 <span class="code">`shared_ptr`</span> 引用时正确地释放对象资源。</span><br><span class="line"></span><br><span class="line"><span class="code">`shared_ptr`</span> 内部的引用计数通常是线程安全的，这意味着即使是多线程环境下，对引用计数的修改也是原子操作，防止了数据竞争和一致性问题。这通常通过使用原子操作（如 <span class="code">`std::atomic`</span>）来保证。</span><br><span class="line"></span><br><span class="line">实现细节上，<span class="code">`shared_ptr`</span> 类中通常会有一个指向控制块的指针（有时称为 <span class="code">`_M_refcount`</span> 或 <span class="code">`_internal`</span> 等），这个指针在 <span class="code">`shared_ptr`</span> 构造时被初始化。每次创建新的 <span class="code">`shared_ptr`</span> 实例或拷贝时，控制块中的引用计数器会通过原子加操作递增。相应的，当 <span class="code">`shared_ptr`</span> 实例被销毁或其 <span class="code">`reset`</span> 方法被调用时，引用计数器会通过原子减操作递减。当引用计数降为零时，控制块会负责调用删除器来释放对象资源，并最终自我销毁。</span><br><span class="line"></span><br><span class="line">此外，为了效率考虑，<span class="code">`shared_ptr`</span> 和控制块的实现可能还会利用小型对象优化（Small Object Optimization, SSO）策略，尝试将小型对象直接嵌入控制块中，以减少内存分配和间接寻址的开销。但这一点依赖于具体实现和编译器。</span><br></pre></td></tr></table></figure>

<h4 id="shared-ptr：我拿一个裸指针指向这个对像，其他已经指向这个对象的共享指针能知道吗"><a href="#shared-ptr：我拿一个裸指针指向这个对像，其他已经指向这个对象的共享指针能知道吗" class="headerlink" title="shared_ptr：我拿一个裸指针指向这个对像，其他已经指向这个对象的共享指针能知道吗"></a>shared_ptr：我拿一个裸指针指向这个对像，其他已经指向这个对象的共享指针能知道吗</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">当你使用裸指针指向一个由 <span class="code">`shared_ptr`</span> 管理的对象时，这个裸指针操作本身并不会直接影响到原有的 <span class="code">`shared_ptr`</span> 对象。换句话说，通过裸指针访问该对象，并不会让 <span class="code">`shared_ptr`</span> 自动感知到这一行为，也不会改变 <span class="code">`shared_ptr`</span> 内部的引用计数。</span><br><span class="line"></span><br><span class="line"><span class="code">`shared_ptr`</span> 通过其内部的引用计数来跟踪对该对象的所有权共享情况，但这个机制仅限于那些通过 <span class="code">`shared_ptr`</span> 实例进行的管理。直接使用裸指针访问对象，绕过了 <span class="code">`shared_ptr`</span> 的管理机制，因此：</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 裸指针无法增加或减少 <span class="code">`shared_ptr`</span> 的引用计数。</span><br><span class="line"><span class="bullet">-</span> 其他已经指向该对象的 <span class="code">`shared_ptr`</span> 不会知道有裸指针正在访问或修改该对象。</span><br><span class="line"><span class="bullet">-</span> 如果所有 <span class="code">`shared_ptr`</span> 实例因为生命周期结束或被重置而导致引用计数归零，即使还有裸指针指向该对象，该对象也会被自动释放，这可能导致裸指针成为悬挂指针（dangling pointer）。</span><br><span class="line"></span><br><span class="line">因此，尽管可以直接使用裸指针访问 <span class="code">`shared_ptr`</span> 管理的对象，这种做法并不推荐，因为它可能导致内存管理混乱和未定义行为。如果需要共享访问，应当继续使用 <span class="code">`shared_ptr`</span> 或在必要时使用 <span class="code">`weak_ptr`</span>，以维持对象生命周期的正确管理。</span><br></pre></td></tr></table></figure>

<h4 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">指针和引用是C++中两种重要的概念，它们都允许你间接访问内存中的数据，但它们之间存在一些根本性的差异：</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 定义和初始化：</span><br><span class="line"><span class="bullet">   -</span> 指针：指针是一个变量，其存储的是另一个变量的地址。指针可以在定义时初始化也可以不初始化，但不初始化的指针可能指向任意位置，使用时容易引发错误。如果指针指向<span class="code">`nullptr`</span>（或早期的实现中的<span class="code">`NULL`</span>），则表示它不指向任何对象。</span><br><span class="line"><span class="bullet">   -</span> 引用：引用实质上是一个已存在对象的别名，必须在定义时初始化，并且一旦初始化后就不能改变引用的对象。引用没有空值，总是必须关联到一个有效的对象。</span><br><span class="line"><span class="bullet">2.</span> 可变性：</span><br><span class="line"><span class="bullet">   -</span> 指针：指针本身可以改变，使其指向另一个对象的地址。也就是说，指针可以在其生命周期内指向不同的对象。</span><br><span class="line"><span class="bullet">   -</span> 引用：一旦引用被初始化为一个对象，它就不能被重新绑定到另一个对象。引用始终指向同一个对象。</span><br><span class="line"><span class="bullet">3.</span> 空值：</span><br><span class="line"><span class="bullet">   -</span> 指针：可以指向<span class="code">`nullptr`</span>，表示不指向任何有效对象。</span><br><span class="line"><span class="bullet">   -</span> 引用：总是必须关联到一个有效的对象，不能为<span class="code">`nullptr`</span>。</span><br><span class="line"><span class="bullet">4.</span> 内存占用：</span><br><span class="line"><span class="bullet">   -</span> 指针：指针有自己的内存空间，存储的是地址，其大小是固定的（通常是机器字长，例如在32位系统上是4字节，在64位系统上是8字节）。</span><br><span class="line"><span class="bullet">   -</span> 引用：严格意义上讲，引用本身不占用额外的内存空间，它更像是一个对象的另一个名字。但实际上，编译器可能会为引用实现内部的指针机制，但这对外部是透明的。</span><br><span class="line"><span class="bullet">5.</span> 使用便捷性：</span><br><span class="line"><span class="bullet">   -</span> 指针：访问指针所指对象的值时，需要解引用操作（如<span class="code">`*ptr`</span>）。</span><br><span class="line"><span class="bullet">   -</span> 引用：使用引用就像直接使用原始变量一样，不需要解引用，更直观易用。</span><br><span class="line"><span class="bullet">6.</span> 安全性：</span><br><span class="line"><span class="bullet">   -</span> 指针：由于指针可以为空，且可以随意改变，使用不当可能导致野指针、悬挂指针等问题，增加了程序出错的风险。</span><br><span class="line"><span class="bullet">   -</span> 引用：由于引用必须初始化且不能改变绑定，因此使用起来相对安全。</span><br><span class="line"></span><br><span class="line">综上，引用提供了一种更安全且易于使用的间接访问方式，而指针则提供了更底层、更灵活的内存操作能力，但也伴随着更高的风险。在选择使用指针还是引用时，应根据具体需求和上下文来决定。</span><br></pre></td></tr></table></figure>

<h4 id="为什么要用指针，用static变量-普通成员变量可以吗"><a href="#为什么要用指针，用static变量-普通成员变量可以吗" class="headerlink" title="为什么要用指针，用static变量/普通成员变量可以吗"></a>为什么要用指针，用static变量/普通成员变量可以吗</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">指针之所以在C++中被广泛使用，是因为它们提供了一些独特的能力，是静态变量（static variables）和普通成员变量所不具备的。以下是使用指针的一些主要原因：</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 动态内存分配：指针允许在程序运行时动态地分配和释放内存，这对于不确定所需内存大小或需要在程序运行过程中调整内存使用的情况非常有用。静态变量和普通成员变量的内存是在编译时或对象构造时分配的，大小固定且生命周期受限。</span><br><span class="line"><span class="bullet">2.</span> 灵活性和间接访问：通过指针，你可以改变所指向的对象，这为数据结构（如链表、树、图等）的实现提供了灵活性。静态变量和普通成员变量的地址是固定的，不能重新指向其他对象。</span><br><span class="line"><span class="bullet">3.</span> 函数间传递大型对象：传递指针或引用比复制整个对象更为高效，特别是当对象很大或复制成本较高时。静态变量不属于任何特定对象实例，而普通成员变量的传递通常意味着对象本身的传递或引用传递。</span><br><span class="line"><span class="bullet">4.</span> 实现多态：通过指向基类的指针或引用，可以指向派生类对象，这是实现多态的基础。这种方法允许编写通用代码，提高了代码的可重用性和灵活性。静态变量和普通成员变量不直接支持这种动态类型的行为。</span><br><span class="line"><span class="bullet">5.</span> 资源共享：多个指针可以指向同一块内存，允许不同部分的代码共享数据，而不必担心数据的独立副本问题。静态变量虽然也能实现某种程度上的共享，但它的作用域和生命周期限制了共享的方式。</span><br><span class="line"><span class="bullet">6.</span> 内存管理和控制：指针提供了直接操作内存的能力，比如通过指针算术可以遍历数组或在连续内存块中移动。这在某些底层编程和系统编程任务中至关重要，而静态变量和普通成员变量不提供这样的底层访问能力。</span><br><span class="line"></span><br><span class="line">虽然静态变量和普通成员变量在某些情况下足够使用，但指针提供了额外的灵活性和功能，使得C++能够支持更复杂的程序设计模式和系统级编程。在决定使用指针之前，应该权衡其带来的灵活性和潜在的安全风险。</span><br></pre></td></tr></table></figure>

<h4 id="父类和派生类的构造顺序"><a href="#父类和派生类的构造顺序" class="headerlink" title="父类和派生类的构造顺序"></a>父类和派生类的构造顺序</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">在C++中，当创建一个派生类对象时，构造函数的调用顺序遵循以下规则：</span><br><span class="line"></span><br><span class="line">1.基类（父类）构造函数：首先，会调用基类的构造函数。调用哪个基类的构造函数取决于派生类构造函数的初始化列表中是如何指定的。如果没有显式指定，将会调用基类的默认构造函数（如果有的话）。如果有多个基类，那么这些基类的构造函数将按照它们在派生类继承列表中声明的顺序被调用。</span><br><span class="line"></span><br><span class="line">2.成员变量：接下来，派生类自身的非静态成员变量将按照它们在类定义中的声明顺序依次被构造。</span><br><span class="line"></span><br><span class="line">3.派生类构造函数：最后，派生类自己的构造函数体被执行。</span><br><span class="line"></span><br><span class="line">这个过程确保了当派生类的构造函数开始执行时，基类的成员已经完全初始化，派生类可以安全地访问这些成员（如果访问权限允许的话）。</span><br></pre></td></tr></table></figure>

<h4 id="构造函数和析构函数能是虚函数吗，如果反着来会有什么问题"><a href="#构造函数和析构函数能是虚函数吗，如果反着来会有什么问题" class="headerlink" title="构造函数和析构函数能是虚函数吗，如果反着来会有什么问题"></a>构造函数和析构函数能是虚函数吗，如果反着来会有什么问题</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">在C++中，构造函数不能是虚函数，而析构函数可以是虚函数，但不是必须的。</span><br><span class="line"></span><br><span class="line"><span class="section">### 构造函数为什么不能是虚函数？</span></span><br><span class="line"><span class="bullet">1.</span> 构造时机：虚函数的调用是基于对象的实际类型，这要求对象已经完全构造完成，包括其虚函数表的建立。但在构造函数执行过程中，对象还处于构建阶段，其类型信息可能尚未完全确定，尤其是涉及到多态时。因此，构造期间无法确定应该调用哪个派生类的虚函数实现。</span><br><span class="line"><span class="bullet">2.</span> 构造目的：构造函数的主要目的是初始化对象，包括基类和派生类的数据成员。虚函数机制是为了实现多态，而构造时还未到达使用多态的阶段，更多的是关注对象状态的正确建立。</span><br><span class="line"></span><br><span class="line"><span class="section">### 析构函数可以是虚函数吗？</span></span><br><span class="line"><span class="bullet">1.</span> 多态性：析构函数可以并且建议在基类中声明为虚函数，以便当通过基类指针或引用删除派生类对象时，能够正确调用派生类的析构函数，完成派生类特有的资源清理工作。这是实现多态性的一部分，确保所有资源得到恰当释放。</span><br><span class="line"></span><br><span class="line"><span class="section">### 反过来会怎样？</span></span><br><span class="line"><span class="bullet">-</span> 如果构造函数是虚函数：实际上这是不允许的，C++标准明确禁止构造函数为虚函数，因此这个问题在技术上不成立。试图强制实现这样的逻辑会导致编译错误。</span><br><span class="line"><span class="bullet">-</span> 如果析构函数不是虚函数：</span><br><span class="line"><span class="bullet">  -</span> 多态问题：当使用基类指针或引用管理派生类对象时，如果析构函数不是虚函数，则通过基类指针删除对象时，只会调用基类的析构函数，而派生类特有的资源可能得不到释放，导致内存泄漏或其他资源管理问题。</span><br><span class="line"><span class="bullet">  -</span> 资源泄露风险：特别是在涉及复杂继承结构和资源管理的场景下，忘记将基类析构函数声明为虚函数，会大大增加资源泄露的风险。</span><br><span class="line"></span><br><span class="line">总之，构造函数因其本质和执行时机的特殊性不能是虚函数，而析构函数虽不是必须为虚函数，但在实现多态的类层次结构中，将其声明为虚函数是最佳实践，以确保资源的正确释放。</span><br></pre></td></tr></table></figure>

<h4 id="虚函数底层原理"><a href="#虚函数底层原理" class="headerlink" title="虚函数底层原理"></a>虚函数底层原理</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">C++中虚函数的底层原理基于两个核心概念：虚函数表（Virtual Table，简称vtable）和虚指针（Virtual Pointer，简称vptr）。下面是对这个机制的详细解析：</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 虚函数表（vtable）</span><br><span class="line"><span class="bullet">-</span> 创建：编译器为每个含有虚函数的类自动生成一个虚函数表。这个表是一个静态的数据结构，存放了该类所有虚函数的地址（即函数指针）。</span><br><span class="line"><span class="bullet">-</span> 内容：不仅包括本类定义的虚函数地址，还可能包括从基类继承而来的虚函数地址。如果子类重写了基类的虚函数，子类的虚函数表中会替换为子类函数的地址。</span><br><span class="line"><span class="bullet">-</span> 布局：虚函数表中的函数按声明顺序排列，且通常第一个条目是用于RTTI（运行时类型信息）的类型信息指针。</span><br><span class="line"></span><br><span class="line"><span class="bullet">2.</span> 虚指针（vptr）</span><br><span class="line"><span class="bullet">-</span> 初始化：每个含有虚函数的类实例在创建时，都会自动分配一个隐藏的成员变量——虚指针vptr。这个指针在对象构造时被初始化，指向该对象对应的虚函数表。</span><br><span class="line"><span class="bullet">-</span> 位置：虚指针通常放置在对象内存布局的最开始处，但这取决于编译器实现。</span><br><span class="line"></span><br><span class="line"><span class="bullet">3.</span> 函数调用过程</span><br><span class="line"><span class="bullet">-</span> 静态绑定与动态绑定：非虚函数调用通过静态绑定在编译时确定，而虚函数调用则通过动态绑定在运行时确定。</span><br><span class="line"><span class="bullet">-</span> 调用路径：当通过基类指针或引用来调用虚函数时，编译器生成的代码首先访问对象的vptr，然后通过vptr找到虚函数表，最后根据表中记录的地址调用正确的虚函数实现。</span><br><span class="line"></span><br><span class="line"><span class="bullet">4.</span> 效率考量</span><br><span class="line"><span class="bullet">-</span> 性能影响：相比直接调用非虚函数，通过虚函数表的间接调用会有轻微的性能开销。但在现代CPU高速缓存和优化技术下，除非频繁调用或在极端性能敏感的应用中，这种开销通常可以接受。</span><br><span class="line"><span class="bullet">-</span> 设计权衡：虽然虚函数带来了一定的运行时开销，但它提供了动态多态的关键能力，使得程序设计更加灵活和可扩展。</span><br><span class="line"></span><br><span class="line"><span class="bullet">5.</span> 特殊情况</span><br><span class="line"><span class="bullet">-</span> 纯虚函数：含有纯虚函数的类不能实例化，它是作为接口使用，强制派生类必须实现这些函数。</span><br><span class="line"><span class="bullet">-</span> 虚析构函数：确保通过基类指针删除派生类对象时，派生类的析构函数会被正确调用。</span><br><span class="line"></span><br><span class="line">综上所述，虚函数的底层机制通过虚函数表和虚指针的配合，实现了在运行时根据对象的实际类型动态选择并调用函数的功能，从而支持了面向对象编程中的多态性。</span><br></pre></td></tr></table></figure>

<h4 id="虚表指针和虚表什么时候创建的"><a href="#虚表指针和虚表什么时候创建的" class="headerlink" title="虚表指针和虚表什么时候创建的"></a>虚表指针和虚表什么时候创建的</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">在C++中，虚表指针（vptr）和虚表的创建时机如下：</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 虚表（VTable）的创建时机： 虚表是在编译时期由编译器生成的。当一个类定义了至少一个虚函数时，编译器会为该类创建一个虚函数表，这个表中包含了类中所有虚函数的地址。这个过程在程序的编译阶段完成，虚函数表会被存放在程序的只读数据段（如.rdata段），供程序运行时使用。虚函数表属于类，类的所有对象共享这个类的虚函数表。</span><br><span class="line"></span><br><span class="line"><span class="bullet">2.</span> 虚表指针（VPtr）的创建时机： 虚表指针是在对象创建的运行时期初始化的。每当一个包含虚函数的类的对象被创建时，编译器会在对象的内存布局的最前面（通常）放置一个隐藏的指针，即虚表指针。这个指针在对象构造时被初始化，指向该类的虚函数表。如果类有构造函数，虚表指针的初始化通常发生在构造函数的开始部分；如果没有显式定义构造函数，编译器会生成一个默认构造函数来完成这项工作。这样，每个对象都有自己的虚表指针，但它们都指向同一个类的虚函数表。</span><br><span class="line"></span><br><span class="line">总结来说，虚表在编译时期静态生成，而虚表指针则在每个对象的运行时期动态初始化。</span><br></pre></td></tr></table></figure>

<h4 id="你认为在多线程编程中最重要的东西？互斥锁和信号量的区别？"><a href="#你认为在多线程编程中最重要的东西？互斥锁和信号量的区别？" class="headerlink" title="你认为在多线程编程中最重要的东西？互斥锁和信号量的区别？"></a>你认为在多线程编程中最重要的东西？互斥锁和信号量的区别？</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">多线程编程中最重要的几个要素包括：</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 同步与通信：确保多个线程能够有效地协同工作，防止数据竞争和不一致问题。这通常通过同步机制（如互斥锁、信号量）实现。</span><br><span class="line"><span class="bullet">2.</span> 资源共享：合理管理线程间共享的数据资源，确保并发访问的安全性。</span><br><span class="line"><span class="bullet">3.</span> 线程生命周期管理：创建、运行、同步、停止和销毁线程的控制。</span><br><span class="line"><span class="bullet">4.</span> 死锁与竞态条件的预防：识别并避免可能导致程序挂起或行为异常的并发问题。</span><br><span class="line"><span class="bullet">5.</span> 性能考量：平衡线程数量与系统资源，避免过度的上下文切换，提高效率。</span><br><span class="line"></span><br><span class="line">互斥锁（Mutex）和信号量（Semaphore）都是多线程编程中常用的同步机制，但它们之间存在一些关键区别：</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 用途：</span><br><span class="line"><span class="bullet">  -</span> 互斥锁主要用于互斥，即确保同一时间只有一个线程可以访问共享资源。它提供了一个简单的锁定机制，当一个线程获得了锁，其他试图获取同一锁的线程必须等待，直到锁被释放。</span><br><span class="line"><span class="bullet">  -</span> 信号量则用于更广泛的同步需求，不仅限于互斥访问。它可以用来控制多个线程访问有限数量的相同资源。信号量维护一个计数器，线程可以通过减小计数器来请求访问资源，通过增大计数器来释放资源。当计数器为非负时，线程可以获取信号量；当计数器为负时，线程必须等待，直到计数器变为非负。</span><br><span class="line"><span class="bullet">-</span> 功能：</span><br><span class="line"><span class="bullet">  -</span> 互斥锁只有两种状态：锁定和未锁定，适用于一对一的资源保护。</span><br><span class="line"><span class="bullet">  -</span> 信号量可以有多个单位，可以实现一对多的资源管理，适用于更复杂的同步场景，比如生产者-消费者模型。</span><br><span class="line"><span class="bullet">-</span> 复杂度：</span><br><span class="line"><span class="bullet">  -</span> 互斥锁的操作相对简单，通常用于简单的互斥访问控制。</span><br><span class="line"><span class="bullet">  -</span> 信号量提供了更复杂的同步机制，能够解决更复杂数量的资源管理和访问控制问题。</span><br><span class="line"></span><br><span class="line">在实际应用中，选择使用互斥锁还是信号量取决于具体的需求，如是否需要控制资源的访问数量、同步复杂度等因素。</span><br></pre></td></tr></table></figure>


<h4 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">进程与线程是现代操作系统中实现并发执行和资源管理的两个基本概念，它们有以下几方面的区别：</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 资源拥有和独立性：</span><br><span class="line"><span class="bullet">   -</span> 进程是资源分配的最小单位，拥有独立的地址空间，包括内存、文件描述符、打开的文件、信号处理器等。每个进程都是独立的，不共享内存，需要通过进程间通信（IPC）机制来交换数据。</span><br><span class="line"><span class="bullet">   -</span> 线程是CPU调度的最小单位，存在于进程内部，共享所属进程的地址空间和资源。线程之间可以直接访问同一进程内的数据，无需IPC，从而简化了通信和数据共享的复杂度。</span><br><span class="line"><span class="bullet">2.</span> 创建和销毁开销：</span><br><span class="line"><span class="bullet">   -</span> 创建和销毁进程的开销远大于线程，因为进程需要分配独立的地址空间和系统资源。</span><br><span class="line"><span class="bullet">   -</span> 线程的创建和销毁相对轻量级，因为它不需要分配单独的地址空间，只需分配栈和少量的线程控制块。</span><br><span class="line"><span class="bullet">3.</span> 上下文切换：</span><br><span class="line"><span class="bullet">   -</span> 进程之间的上下文切换比线程更耗时，因为它涉及到切换整个地址空间，保存和恢复更多的状态信息。</span><br><span class="line"><span class="bullet">   -</span> 线程上下文切换更快，因为它通常只涉及保存和恢复寄存器状态，共享同一地址空间。</span><br><span class="line"><span class="bullet">4.</span> 并发与并行：</span><br><span class="line"><span class="bullet">   -</span> 进程和线程都可以实现并发执行，即交替执行，给人一种同时运行的错觉。</span><br><span class="line"><span class="bullet">   -</span> 在多核处理器系统中，线程可以真正并行执行，即同时在不同的CPU核心上运行，充分利用硬件资源。</span><br><span class="line"><span class="bullet">5.</span> 通信：</span><br><span class="line"><span class="bullet">   -</span> 进程间通信（IPC）通常需要使用管道、消息队列、共享内存等机制，实现起来较为复杂。</span><br><span class="line"><span class="bullet">   -</span> 线程间可以直接读写同一进程内的数据，或者使用简单的锁和条件变量进行同步，通信效率更高。</span><br><span class="line"><span class="bullet">6.</span> 控制和管理：</span><br><span class="line"><span class="bullet">   -</span> 进程提供了一定程度的隔离，一个进程崩溃通常不会直接影响其他进程。</span><br><span class="line"><span class="bullet">   -</span> 线程之间缺乏这种隔离，一个线程的错误可能导致整个进程（包括其他线程）崩溃。</span><br><span class="line"></span><br><span class="line">根据具体的应用场景，开发者可以选择使用进程或线程来达到并发处理的目的，考虑因素包括资源需求、通信复杂度、性能要求以及安全隔离需求等。</span><br></pre></td></tr></table></figure>

<h4 id="从操作系统的角度解释线程比进程切换的快的原因"><a href="#从操作系统的角度解释线程比进程切换的快的原因" class="headerlink" title="从操作系统的角度解释线程比进程切换的快的原因"></a>从操作系统的角度解释线程比进程切换的快的原因</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">从操作系统的角度来看，线程比进程切换更快的原因主要在于线程共享地址空间和减少了上下文切换时需要保存和恢复的信息量。下面是详细解释：</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 地址空间: 进程切换涉及到虚拟地址空间的切换。每个进程都有自己的独立虚拟地址空间，这意味着在进程切换时，操作系统需要更新内存管理单元（MMU）的页表，以映射新进程的地址空间到物理内存。这一操作包括刷新TLB（Translation Lookaside Buffer，转换旁路缓存），它是快速查找虚拟地址到物理地址映射的硬件缓存。TLB刷新会导致后续内存访问变慢，直到TLB重新被填充。而线程共享所在进程的地址空间，因此在线程间切换时，不需要改变页表，也就不需要刷新TLB，从而减少了切换时间。</span><br><span class="line"><span class="bullet">2.</span> 上下文信息: 进程上下文包括了更多需要保存和恢复的信息，如独立的栈、全局变量、打开的文件描述符、信号处理器等。在进程切换时，所有这些信息都需要被保存和恢复。相比之下，线程上下文主要是栈（包括寄存器状态）、线程局部存储器等，而栈顶指针、程序计数器等关键寄存器信息是主要需要保存和恢复的部分。由于线程共享进程的资源，因此，相比进程，线程切换时需要保存和恢复的信息量少很多。</span><br><span class="line"><span class="bullet">3.</span> 硬件栈: 进程切换时，除了软件层面的上下文信息保存，还需要硬件栈的切换。而线程共享同一进程的内核栈，因此，线程切换时通常只需要切换用户栈，有时甚至用户栈也不需要切换，进一步减少了开销。</span><br><span class="line"><span class="bullet">4.</span> 系统开销: 创建和销毁进程需要分配和回收系统资源，如内存空间、文件描述符等，这涉及到复杂的系统调用和资源管理，开销较大。而线程的创建和销毁由于共享资源，开销相对较小。</span><br><span class="line"></span><br><span class="line">综上所述，由于线程在地址空间、上下文信息量、硬件栈使用以及系统开销等方面的特性，使得线程之间的切换比进程切换更快，更高效。这对于需要频繁切换的高并发场景特别有利，能够提升系统的响应速度和整体性能。</span><br></pre></td></tr></table></figure>

<h4 id="死锁问题"><a href="#死锁问题" class="headerlink" title="死锁问题"></a>死锁问题</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">死锁是指在多线程或多进程的并发系统中，两个或多个进程（或线程）因为互相等待对方占有的资源而永久阻塞的状态，导致这些进程都无法继续执行下去。死锁发生的必要条件通常包括：</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 互斥条件：资源只能被一个进程（或线程）占用。</span><br><span class="line"><span class="bullet">2.</span> 请求与保持条件：一个进程（或线程）持有资源并请求其他资源。</span><br><span class="line"><span class="bullet">3.</span> 不可剥夺条件：资源只能在进程（或线程）主动释放后才能被其他进程（或线程）获取。</span><br><span class="line"><span class="bullet">4.</span> 循环等待条件：存在一个进程（或线程）的资源请求序列形成了一个循环等待的环。</span><br><span class="line"></span><br><span class="line">解决死锁问题的方法主要包括以下几种策略：</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 预防死锁：</span><br><span class="line"><span class="bullet">   -</span> 破坏上述死锁的四个必要条件之一，如通过静态分配资源避免请求与保持条件，规定资源的分配顺序以破坏循环等待条件，或者允许资源剥夺。</span><br><span class="line"><span class="bullet">2.</span> 避免死锁：</span><br><span class="line"><span class="bullet">   -</span> 利用银行家算法等预先判断资源分配请求是否会导致死锁，只在安全状态下分配资源。</span><br><span class="line"><span class="bullet">3.</span> 检测死锁：</span><br><span class="line"><span class="bullet">   -</span> 运行时系统定期检查是否存在死锁，例如通过检测循环等待条件。一旦检测到死锁，采取相应措施解除。</span><br><span class="line"><span class="bullet">4.</span> 解除死锁：</span><br><span class="line"><span class="bullet">   -</span> 进程撤销法：终止一部分死锁进程，释放其资源。</span><br><span class="line"><span class="bullet">   -</span> 进程回退法：让进程回退到安全状态，释放资源后重新尝试。</span><br><span class="line"><span class="bullet">   -</span> 剥夺资源：强制从某些进程那里剥夺资源分配给其他进程，但这可能影响被剥夺进程的正确性。</span><br><span class="line"><span class="bullet">   -</span> 死锁忽略：在某些情况下，如果死锁发生的概率很小或影响不大，可以选择忽略死锁问题。</span><br><span class="line"></span><br><span class="line">选择合适的策略需根据具体的应用场景和系统需求来决定，通常需要在系统设计初期就考虑死锁预防机制，以减少运行时处理死锁的复杂性和风险。</span><br></pre></td></tr></table></figure>

<h4 id="动态库和静态库的区别"><a href="#动态库和静态库的区别" class="headerlink" title="动态库和静态库的区别"></a>动态库和静态库的区别</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">动态库和静态库是程序开发中用于代码复用的两种不同类型的库文件，它们在链接方式、运行时行为、资源占用、更新维护等方面有着显著的区别：</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 链接时机:</span><br><span class="line"><span class="bullet">   -</span> 静态库：在编译期间（link time），静态库的代码会被直接整合到目标应用程序中，生成的可执行文件是自包含的，不依赖于库文件本身。</span><br><span class="line"><span class="bullet">   -</span> 动态库：动态库在编译时并不被直接合并到可执行文件中，而是在程序运行时（runtime）由操作系统加载到内存中，并与应用程序链接。这意味着动态库不成为可执行文件的一部分。</span><br><span class="line"><span class="bullet">2.</span> 内存占用与代码共享:</span><br><span class="line"><span class="bullet">   -</span> 静态库：每个使用静态库的应用程序都会包含库代码的一份拷贝，这会增加最终可执行文件的大小，并且不能在不同程序间共享相同的库代码，导致内存占用较高。</span><br><span class="line"><span class="bullet">   -</span> 动态库：多个程序可以共享同一份动态库的代码段，只需在内存中载入一次，节省了内存空间，尤其是在多个程序同时运行且都使用同一动态库的情况下。</span><br><span class="line"><span class="bullet">3.</span> 更新与维护:</span><br><span class="line"><span class="bullet">   -</span> 静态库：如果静态库需要更新，所有依赖它的应用程序都需要重新编译和链接，这在大型项目或部署环境中可能会非常不便。</span><br><span class="line"><span class="bullet">   -</span> 动态库：更新动态库时，只需替换相应的库文件，无需重新编译依赖它的应用程序，这大大简化了软件的升级和维护过程。</span><br><span class="line"><span class="bullet">4.</span> 文件扩展名与平台差异:</span><br><span class="line"><span class="bullet">   -</span> 静态库：常见的文件扩展名有<span class="code">`.a`</span>（Unix-like系统）和<span class="code">`.lib`</span>（Windows系统）。</span><br><span class="line"><span class="bullet">   -</span> 动态库：在Unix-like系统中通常为<span class="code">`.so`</span>（Shared Object），Windows系统中为<span class="code">`.dll`</span>（Dynamic Link Library）。</span><br><span class="line"><span class="bullet">5.</span> 性能:</span><br><span class="line"><span class="bullet">   -</span> 静态库：因为代码已经集成在可执行文件中，启动时不需要额外的加载步骤，可能会有更快的启动时间。</span><br><span class="line"><span class="bullet">   -</span> 动态库：虽然可能有轻微的加载延迟，但在某些情况下，如代码共享，可以减少总的内存使用，从而提高整体系统性能。</span><br><span class="line"></span><br><span class="line">根据项目的具体需求，开发者可以选择使用静态库或动态库，以平衡开发便利性、资源占用、更新灵活性和运行时性能等因素。</span><br></pre></td></tr></table></figure>

<h4 id="qt的事件循环讲一下"><a href="#qt的事件循环讲一下" class="headerlink" title="qt的事件循环讲一下"></a>qt的事件循环讲一下</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Qt的事件循环是其框架内用于处理各种用户交互和系统事件的核心机制。它基于事件驱动编程模型，允许应用程序响应如鼠标点击、键盘输入、窗口调整大小、定时器触发等多种事件，而不是按照固定的线性流程执行。</span><br><span class="line"></span><br><span class="line">在Qt中，事件循环的工作原理大致如下：</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 事件生成：当用户进行操作（如点击鼠标、敲击键盘）或系统发生某种状态变化（如时间到达定时器设定值）时，Qt会生成相应的事件对象。这些事件对象是从基类<span class="code">`QEvent`</span>派生的，比如<span class="code">`QMouseEvent`</span>、<span class="code">`QKeyEvent`</span>、<span class="code">`QTimerEvent`</span>等。</span><br><span class="line"><span class="bullet">2.</span> 事件队列：生成的事件被放置到一个事件队列中。这个队列负责存储等待处理的所有事件，确保事件按先进先出（FIFO）的顺序被处理。</span><br><span class="line"><span class="bullet">3.</span> 事件循环启动：通过调用<span class="code">`QApplication::exec()`</span>方法，事件循环开始运行。这个方法会进入一个循环，不断地检查事件队列是否为空。</span><br><span class="line"><span class="bullet">4.</span> 事件分发与处理：在循环中，事件循环会从队列顶部取出一个事件，并分发给对应的对象进行处理。对象通过重写<span class="code">`QObject::event()`</span>方法或特定事件处理函数（如<span class="code">`mousePressEvent()`</span>、<span class="code">`keyPressEvent()`</span>）来响应这些事件。</span><br><span class="line"><span class="bullet">5.</span> 同步与异步处理：Qt支持事件的同步和异步处理。<span class="code">`postEvent`</span>函数用于将事件添加到队列中异步处理，而<span class="code">`sendEvent`</span>则尝试直接调用事件处理函数同步处理事件，不经过队列。</span><br><span class="line"><span class="bullet">6.</span> 循环终止：当事件队列为空，且没有其他活动的事件源时，事件循环可能会阻塞等待新事件。此外，可以通过调用<span class="code">`QApplication::exit()`</span>显式退出事件循环，这通常是应用程序关闭时的操作。</span><br><span class="line"><span class="bullet">7.</span> 资源清理：事件循环结束时，Qt会自动清理一些资源，包括关闭打开的文件、释放内存等，确保程序优雅地退出。</span><br><span class="line"></span><br><span class="line">简而言之，Qt的事件循环机制使得应用程序能够高效、有序地处理外部输入和内部状态变化，是构建响应式和交互式GUI应用程序的基础。</span><br></pre></td></tr></table></figure>

<h4 id="qt的消息机制和windows的消息机制有什么关联吗"><a href="#qt的消息机制和windows的消息机制有什么关联吗" class="headerlink" title="qt的消息机制和windows的消息机制有什么关联吗"></a>qt的消息机制和windows的消息机制有什么关联吗</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Qt的消息机制和Windows的消息机制虽然服务于相似的目的——即实现应用程序的事件驱动编程，但它们在实现细节和设计理念上有所不同，同时又存在着紧密的关联，特别是在Qt应用于Windows平台时。</span><br><span class="line"></span><br><span class="line">Windows消息机制：</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 基于C语言风格，更底层，直接与操作系统交互。</span><br><span class="line"><span class="bullet">-</span> 消息通过消息队列传递，应用程序通过调用如<span class="code">`GetMessage`</span>, <span class="code">`TranslateMessage`</span>, 和 <span class="code">`DispatchMessage`</span>等API函数来处理消息队列中的消息。</span><br><span class="line"><span class="bullet">-</span> 每个窗口过程（Window Procedure）是一个回调函数，负责处理发送给窗口的消息。</span><br><span class="line"><span class="bullet">-</span> 消息由一个消息标识符（message ID）、附加的WPARAM和LPARAM参数以及一个指向窗口实例的HWND组成，封装在一个MSG结构中。</span><br><span class="line"></span><br><span class="line">Qt事件机制：</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 更高层，面向对象，提供了更加抽象和易于使用的API。</span><br><span class="line"><span class="bullet">-</span> 基于事件（<span class="code">`QEvent`</span>）和事件处理器（如<span class="code">`QObject::event()`</span>）的概念。</span><br><span class="line"><span class="bullet">-</span> 事件循环由<span class="code">`QEventLoop`</span>管理，通过调用<span class="code">`QApplication::exec()`</span>启动。</span><br><span class="line"><span class="bullet">-</span> 事件处理通常通过重写<span class="code">`QObject`</span>的<span class="code">`event()`</span>函数或特定事件处理函数（如<span class="code">`mousePressEvent`</span>）来完成。</span><br><span class="line"><span class="bullet">-</span> Qt的事件机制在不同平台（如Windows、Linux、macOS）上提供了统一的接口，隐藏了底层系统的差异。</span><br><span class="line"></span><br><span class="line">关联点：</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 当Qt应用运行在Windows平台上时，Qt的消息机制需要与Windows的消息机制对接。Qt通过一个名为<span class="code">`QEventDispatcherWin32`</span>的类（它是<span class="code">`QAbstractEventDispatcher`</span>的子类）来桥接Qt的事件循环与Windows消息循环。</span><br><span class="line"><span class="bullet">-</span> <span class="code">`QEventDispatcherWin32`</span>会监听Windows消息队列，将Windows消息转换为Qt事件（<span class="code">`QEvent`</span>），并放入Qt的事件队列中，这样Qt应用就可以通过统一的事件处理接口来响应原本来自Windows的消息。</span><br><span class="line"><span class="bullet">-</span> Qt还提供了接口，允许开发者直接处理Windows消息，例如通过重写<span class="code">`QWidget::winEvent()`</span>或使用native event filters，这样可以在保持Qt编程风格的同时，处理特定于Windows的低级消息。</span><br><span class="line"></span><br><span class="line">因此，尽管Qt提供了一个跨平台的事件处理模型，但在Windows平台上，它依然依赖于Windows的消息机制作为与操作系统交互的基础，并在此之上构建了一层更为高级和抽象的事件处理框架。</span><br></pre></td></tr></table></figure>

<h4 id="Qt架构相较于C-标准库有哪些不同吗，多了哪些东西，有哪些优势"><a href="#Qt架构相较于C-标准库有哪些不同吗，多了哪些东西，有哪些优势" class="headerlink" title="Qt架构相较于C++标准库有哪些不同吗，多了哪些东西，有哪些优势"></a>Qt架构相较于C++标准库有哪些不同吗，多了哪些东西，有哪些优势</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Qt架构与C++标准库（STL）之间有一些本质上的不同，主要体现在目标、功能范围和提供的特性上。以下是它们之间的一些关键区别以及Qt所增添的优势：</span><br><span class="line"></span><br><span class="line"><span class="section">### 不同之处</span></span><br><span class="line"><span class="bullet">1.</span> 目标和范围：</span><br><span class="line"><span class="bullet">   -</span> C++标准库：主要关注于提供基础的数据结构（如vector, list, map等）、算法（排序、查找等）、输入输出流、字符串处理等通用编程组件。它是C++语言的组成部分，旨在提升编程效率和代码质量。</span><br><span class="line"><span class="bullet">   -</span> Qt库：是一个全面的应用程序开发框架，不仅包含数据结构和算法，还提供了用于图形用户界面（GUI）开发、网络编程、数据库访问、多线程、文件I/O、XML处理、JSON解析、国际化和本地化等高级功能。Qt特别强调跨平台能力，允许开发者编写一次代码，在多种操作系统上编译运行。</span><br><span class="line"></span><br><span class="line"><span class="bullet">2.</span> 用户界面支持：</span><br><span class="line"><span class="bullet">   -</span> C++标准库：不包含直接用于创建图形用户界面的组件。</span><br><span class="line"><span class="bullet">   -</span> Qt库：拥有强大的GUI开发工具和组件，如QWidget、QML等，使得UI设计变得直观且高效。</span><br><span class="line"></span><br><span class="line"><span class="bullet">3.</span> 信号与槽机制：</span><br><span class="line"><span class="bullet">   -</span> C++标准库：没有内置的事件驱动编程机制。</span><br><span class="line"><span class="bullet">   -</span> Qt库：引入了独特的信号（Signals）和槽（Slots）机制，这是一种灵活的事件处理方式，允许对象之间的松耦合通信，是Qt框架的一大特色。</span><br><span class="line"></span><br><span class="line"><span class="bullet">4.</span> 跨平台能力：</span><br><span class="line"><span class="bullet">   -</span> C++标准库：虽然大部分是跨平台的，但它不直接提供平台无关的UI或系统服务接口。</span><br><span class="line"><span class="bullet">   -</span> Qt库：提供了高度抽象的API，使得开发者能编写跨平台的代码，无需担心底层操作系统的差异。</span><br><span class="line"></span><br><span class="line"><span class="section">### Qt的优势</span></span><br><span class="line"><span class="bullet">1.</span> 集成开发环境：Qt Creator是一个功能丰富的集成开发环境（IDE），专为Qt开发设计，提供代码编辑、调试、UI设计、版本控制等功能。</span><br><span class="line"><span class="bullet">2.</span> 图形用户界面工具：Qt Designer等工具简化了UI设计过程，支持拖拽式布局设计。</span><br><span class="line"><span class="bullet">3.</span> 跨平台一致性：Qt确保了代码在不同操作系统上的表现一致，减少了移植工作。</span><br><span class="line"><span class="bullet">4.</span> 丰富的模块和库：Qt提供了广泛的模块，几乎覆盖了开发复杂应用所需的所有方面。</span><br><span class="line"><span class="bullet">5.</span> 信号与槽机制：简化了对象间的通信，提高了代码的可读性和可维护性。</span><br><span class="line"><span class="bullet">6.</span> 活跃的社区和文档：Qt拥有庞大的开发者社区和详尽的文档，便于学习和解决问题。</span><br><span class="line"></span><br><span class="line">综上所述，Qt不仅仅是一个库，它是一个完整的开发框架，补充了C++标准库的功能，特别是在应用程序开发尤其是GUI领域，提供了更高的生产力和更广泛的工具集。</span><br></pre></td></tr></table></figure>

<h4 id="qt的信号槽底层原理"><a href="#qt的信号槽底层原理" class="headerlink" title="qt的信号槽底层原理"></a>qt的信号槽底层原理</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Qt的信号槽（Signals and Slots）机制是其框架中一个核心且强大的特性，允许对象之间进行解耦通信。其底层原理涉及以下几个关键技术组件和步骤：</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 元对象系统（Meta-Object System）：Qt的信号槽机制建立在元对象系统之上，该系统为每个 QObject 类的实例提供运行时类型信息。元对象编译器（moc，Meta-Object Compiler）是一个预处理器，它扫描C++源代码中的Q<span class="emphasis">_OBJECT宏，并生成额外的C++代码来实现信号槽机制和其他元对象特性。这个过程中，moc会为信号和槽生成相应的元数据。</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">2. 动态代理（Dynamic Proxy）：为了在信号发射时调用相应的槽函数，Qt使用了一种动态代理机制。这意味着在运行时，信号和槽的连接是通过查找元数据并在必要时生成适配代码来实现的。这保证了信号和槽的连接既类型安全又灵活。</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">3. 事件驱动：信号槽机制在本质上是事件驱动的。当信号被发射（emit）时，它会产生一个事件，这个事件随后被事件循环捕获并处理，导致相应的槽函数被调用。尽管通常感觉上是即时发生的，但实际上信号的处理是通过事件循环排队和调度的。</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">4. 连接管理：信号和槽之间的连接是由`QObject::connect`方法建立的。这个方法记录了信号和槽之间的关系，包括它们的参数类型，以便在信号发射时进行类型检查和适配。连接可以是直接的也可以是队列的（在不同线程中），并且可以指定连接类型（如默认、直接、队列、阻塞）来控制调用行为。</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">5. 线程安全性：Qt信号槽机制设计时考虑到了线程安全性。在不同线程中，信号和槽的交互需要特殊处理，以确保数据同步和线程间的正确通信。Qt通过事件队列和线程间的消息传递来确保跨线程的信号槽调用是安全的。</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">6. 类型检查与转换：在连接信号和槽时，Qt会检查它们的签名（参数类型和数量）是否匹配。如果不完全匹配，但可以通过隐式类型转换达成一致，Qt也会允许这样的连接。类型检查确保了信号发送的数据能够正确地传递给槽函数。</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">总的来说，Qt的信号槽机制通过元对象系统、动态代理、事件循环等组件实现了对象间的松耦合通信，提升了代码的模块化和可维护性，同时也保证了高效率和线程安全。</span></span><br></pre></td></tr></table></figure>

<h4 id="qt的信号槽connect函数的参数，第五个参数是什么"><a href="#qt的信号槽connect函数的参数，第五个参数是什么" class="headerlink" title="qt的信号槽connect函数的参数，第五个参数是什么"></a>qt的信号槽connect函数的参数，第五个参数是什么</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Qt的<span class="code">`connect`</span>函数用于建立信号和槽之间的连接，其原型可以接受多个参数，其中第五个参数是<span class="code">`connectionType`</span>，用于指定信号和槽之间的连接类型。这个参数是可选的，因为默认情况下会使用<span class="code">`Qt::AutoConnection`</span>。以下是关于第五个参数<span class="code">`connectionType`</span>的可能取值及其含义：</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> Qt::AutoConnection（默认值）：连接类型会在信号发送时自动决定。如果接收者和发送者在同一个线程，则使用<span class="code">`Qt::DirectConnection`</span>；如果在不同线程，则使用<span class="code">`Qt::QueuedConnection`</span>。</span><br><span class="line"></span><br><span class="line"><span class="bullet">2.</span> Qt::DirectConnection：槽函数会在信号发送的时候直接被调用，即槽函数运行于信号发送者所在线程。这种模式下，信号发送后槽函数会立即执行，不经过事件队列。</span><br><span class="line"></span><br><span class="line"><span class="bullet">3.</span> Qt::QueuedConnection：槽函数会在控制权回到接收者所在线程的事件循环时被调用。这意味着槽函数将在接收者线程的一个后续事件循环迭代中执行，因此发送信号后槽函数不会立即执行。</span><br><span class="line"></span><br><span class="line"><span class="bullet">4.</span> Qt::BlockingQueuedConnection：类似于<span class="code">`Qt::QueuedConnection`</span>，但是发送者线程会阻塞，直到槽函数执行完毕。这种连接类型要求发送者和接收者不在同一个线程，否则会导致死锁。</span><br><span class="line"></span><br><span class="line"><span class="bullet">5.</span> Qt::UniqueConnection：这不是一个独立的连接类型，而是一个标志位，可以与上述类型通过按位或（<span class="code">`|`</span>）操作符组合使用。如果设置了这个标志，当尝试重复连接相同的信号和槽时，连接将失败，从而避免了槽函数的重复调用。</span><br><span class="line"></span><br><span class="line">在实际编程中，通过合理选择连接类型，开发者可以控制多线程环境下的执行顺序和线程安全问题，以及优化程序的响应性和性能。</span><br></pre></td></tr></table></figure>

<h4 id="有一串列表，怎么判断他们有没有相交的部分"><a href="#有一串列表，怎么判断他们有没有相交的部分" class="headerlink" title="有一串列表，怎么判断他们有没有相交的部分"></a>有一串列表，怎么判断他们有没有相交的部分</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">判断两个链表是否相交，通常涉及以下几种方法，具体取决于链表是否有环以及你所拥有的信息。这里假设您提到的是单链表，且希望判断它们是否在某个节点处相交。</span><br><span class="line"></span><br><span class="line"><span class="section">### 对于无环链表</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 计算长度法:</span><br><span class="line"><span class="bullet">   -</span> 首先遍历两个链表，计算它们的长度。</span><br><span class="line"><span class="bullet">   -</span> 如果长度不同，它们肯定不相交。</span><br><span class="line"><span class="bullet">   -</span> 如果长度相同，将较长链表的头指针（实际上是相同长度，这里只是为了表述）向前移动它们长度差的步数，使两个指针处于相同“起跑线”。</span><br><span class="line"><span class="bullet">   -</span> 然后同时遍历两个链表，如果在某一步两个指针指向同一节点，则说明链表相交，否则不相交。</span><br><span class="line"></span><br><span class="line"><span class="bullet">2.</span> 哈希表法:</span><br><span class="line"><span class="bullet">   -</span> 遍历第一个链表，将所有节点的地址存入哈希表。</span><br><span class="line"><span class="bullet">   -</span> 遍历第二个链表，检查每个节点的地址是否已经在哈希表中出现过，如果出现过则说明相交。</span><br><span class="line"></span><br><span class="line"><span class="bullet">3.</span> 直接遍历法:</span><br><span class="line"><span class="bullet">   -</span> 将一个链表的尾部连接到另一个链表头部，形成一个环，然后使用快慢指针检测环的存在。如果形成环，则说明原链表相交；如果没有形成环，则不相交。此方法需谨慎使用，因为它改变了原链表结构，使用后要恢复原状。</span><br><span class="line"></span><br><span class="line"><span class="section">### 对于有环链表</span></span><br><span class="line"></span><br><span class="line">如果有环，情况会稍微复杂，但根据题目描述，通常假设相交的链表要么都是无环的，要么都是有环的。对于有环链表相交的情况，可以先确定环的存在和位置，然后通过特定逻辑判断两个链表是否通过相同的环相交。</span><br><span class="line"></span><br><span class="line"><span class="section">### 综合考虑</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 环的检测:</span><br><span class="line"><span class="bullet">  -</span> 使用快慢指针（Floyd判圈算法）来检测链表是否有环，快指针每次移动两步，慢指针每次移动一步，如果相遇则链表有环。</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 相交判断:</span><br><span class="line"><span class="bullet">  -</span> 如果两个链表都有环，可以进一步判断环内的节点是否相同，这通常需要先找到环的入口点，然后通过特定逻辑比较。</span><br><span class="line"></span><br><span class="line">总之，判断链表相交的关键在于理解链表的结构，选择合适的方法，如果是无环链表，通常采用长度计算或哈希表法较为直接有效；而对于有环链表，则需要先解决环的问题再进行相交判断。</span><br></pre></td></tr></table></figure>

<h4 id="求给定数组中第k大的数"><a href="#求给定数组中第k大的数" class="headerlink" title="求给定数组中第k大的数"></a>求给定数组中第k大的数</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">找到给定数组中第k大的数的方法主要有以下几种：</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 排序后直接访问</span><br><span class="line"><span class="bullet">   -</span> 将数组排序（可以使用快速排序、归并排序等算法）。</span><br><span class="line"><span class="bullet">   -</span> 排序后，第k大的数就是数组中倒数第k个元素（即第n-k+1个元素，其中n是数组长度）。</span><br><span class="line"><span class="bullet">   -</span> 时间复杂度通常是O(nlogn)，其中n是数组长度。</span><br><span class="line"></span><br><span class="line"><span class="bullet">2.</span> 快速选择算法（QuickSelect）</span><br><span class="line"><span class="bullet">   -</span> 类似于快速排序的划分过程，但不需要完全排序整个数组。</span><br><span class="line"><span class="bullet">   -</span> 选择一个基准元素，将数组划分为两部分，一部分包含所有小于基准的元素，另一部分包含所有大于基准的元素。</span><br><span class="line"><span class="bullet">   -</span> 根据基准元素的位置与k的关系，递归地在左侧或右侧子数组中进行快速选择。</span><br><span class="line"><span class="bullet">   -</span> 时间复杂度平均情况下是O(n)，最坏情况下是O(n^2)，但可以通过随机化基准元素的选择来降低最坏情况的发生概率。</span><br><span class="line"></span><br><span class="line"><span class="bullet">3.</span> 部分排序（Partial Sorting）</span><br><span class="line"><span class="bullet">   -</span> 使用如堆排序、堆选择等算法，只排序或选择出数组中的前k个最大元素。</span><br><span class="line"><span class="bullet">   -</span> 这种方法通常不需要对整个数组进行排序，因此时间复杂度可以低于O(nlogn)。</span><br><span class="line"><span class="bullet">   -</span> 具体实现上，可以使用最小堆来维护当前最大的k个数，遍历数组并将元素与堆顶元素比较，如果当前元素更大，则弹出堆顶元素并将当前元素入堆。</span><br><span class="line"></span><br><span class="line"><span class="bullet">4.</span> 使用STL库</span><br><span class="line"><span class="bullet">   -</span> 在C++中，可以使用STL库中的<span class="code">`nth_element`</span>算法，该算法可以在线性时间内将第k大的元素移动到其最终排序位置，但并不会对整个数组进行排序。</span><br><span class="line"><span class="bullet">   -</span> <span class="code">`nth_element`</span>算法使用了类似于快速选择的思想，但不需要递归。</span><br><span class="line"></span><br><span class="line"><span class="bullet">5.</span> 桶排序或计数排序（如果数值范围有限）</span><br><span class="line"><span class="bullet">   -</span> 如果数组中的数值范围有限，可以使用桶排序或计数排序等线性时间复杂度的排序算法。</span><br><span class="line"><span class="bullet">   -</span> 排序后，同样可以通过访问倒数第k个元素来找到第k大的数。</span><br><span class="line"></span><br><span class="line">以上方法各有优缺点，具体选择哪种方法取决于数组的大小、数值的分布情况以及性能要求等因素。</span><br></pre></td></tr></table></figure>

<h4 id="32位和64位系统下成员变量和对象各种区别和细节"><a href="#32位和64位系统下成员变量和对象各种区别和细节" class="headerlink" title="32位和64位系统下成员变量和对象各种区别和细节"></a>32位和64位系统下成员变量和对象各种区别和细节</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">在C++中，32位和64位系统的区别主要体现在以下几个方面，这些区别会影响到成员变量和对象的处理：</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 数据类型大小：</span><br><span class="line"><span class="bullet">   -</span> 基本数据类型的大小可能不同。例如，在32位系统中，<span class="code">`int`</span>和<span class="code">`pointer`</span>（指针）通常为32位（4字节），而在64位系统中，<span class="code">`int`</span>可能仍然是32位（取决于编译器和平台），但指针通常是64位（8字节）。<span class="code">`long`</span>和<span class="code">`long long`</span>的大小也可能因系统而异。</span><br><span class="line"><span class="bullet">   -</span> <span class="code">`sizeof`</span>运算符返回的成员变量或对象的大小会根据系统架构和编译器有所不同。</span><br><span class="line"></span><br><span class="line"><span class="bullet">2.</span> 内存对齐：</span><br><span class="line"><span class="bullet">   -</span> 内存对齐规则可能会导致相同结构体或类在不同系统下的总大小不同。64位系统可能要求更严格的对齐，从而可能导致结构体内存占用增加。</span><br><span class="line"><span class="bullet">   -</span> 空类在任何系统下至少占用1字节，但在有成员变量的情况下，对齐要求会影响整体大小。</span><br><span class="line"></span><br><span class="line"><span class="bullet">3.</span> 性能和寻址能力：</span><br><span class="line"><span class="bullet">   -</span> 64位系统能直接寻址更多内存（理论上可达18EB），而32位系统寻址能力上限通常为4GB。这影响了处理大规模数据结构的能力。</span><br><span class="line"><span class="bullet">   -</span> 由于更宽的寄存器，64位系统在某些计算上可能比32位系统更高效。</span><br><span class="line"></span><br><span class="line"><span class="bullet">4.</span> 编译器和库支持：</span><br><span class="line"><span class="bullet">   -</span> 64位和32位系统可能需要不同的编译器设置和库文件。某些库可能只针对特定位宽优化，影响到性能和兼容性。</span><br><span class="line"></span><br><span class="line"><span class="bullet">5.</span> 对象布局和虚函数：</span><br><span class="line"><span class="bullet">   -</span> 对象的内存布局，尤其是含有虚函数的对象，会包含指向虚函数表的指针。在64位系统中，这个指针也会增大到8字节。</span><br><span class="line"><span class="bullet">   -</span> 类的继承和虚继承可能在不同位宽系统上有不同的内存布局，影响到对象的大小和访问效率。</span><br><span class="line"></span><br><span class="line"><span class="bullet">6.</span> 性能考量：</span><br><span class="line"><span class="bullet">   -</span> 在64位系统上，处理较大的数据类型（如64位指针）可能会消耗更多的缓存空间，对内存敏感的应用可能需要注意这一点。</span><br><span class="line"></span><br><span class="line">综上所述，虽然C++语言本身并不直接定义32位和64位系统的具体行为，但编译器、操作系统和硬件的组合会导致在不同位宽系统上编译和运行C++代码时产生上述差异。开发者在编写跨平台代码时，需要考虑这些因素以确保代码的兼容性和性能。</span><br></pre></td></tr></table></figure>

<h4 id="32位软件跑在64位系统上，跟64位软件跑在64位系统上有什么区别"><a href="#32位软件跑在64位系统上，跟64位软件跑在64位系统上有什么区别" class="headerlink" title="32位软件跑在64位系统上，跟64位软件跑在64位系统上有什么区别"></a>32位软件跑在64位系统上，跟64位软件跑在64位系统上有什么区别</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">32位软件跑在64位系统上与64位软件跑在64位系统上的主要区别包括：</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 内存访问能力：</span><br><span class="line"><span class="bullet">   -</span> 32位软件：受限于32位地址空间，最多能直接访问约4GB的内存。即使在64位系统上，32位程序也无法直接利用超过4GB的物理内存。</span><br><span class="line"><span class="bullet">   -</span> 64位软件：可以利用更大的内存地址空间，理论上可访问的内存大小远超4GB，使得处理大规模数据集更为高效。</span><br><span class="line"></span><br><span class="line"><span class="bullet">2.</span> 性能表现：</span><br><span class="line"><span class="bullet">   -</span> 32位软件：在64位系统上以兼容模式运行时，由于需要通过系统层的地址转换等机制来模拟32位环境，可能会有细微的性能损失，尤其是在进行大量内存操作时。不过，对于大多数日常应用，这种性能差异不明显。</span><br><span class="line"><span class="bullet">   -</span> 64位软件：可以直接利用64位架构的优势，如更宽的寄存器，允许一次性处理更多数据，理论上可以提升计算和数据处理的效率。</span><br><span class="line"></span><br><span class="line"><span class="bullet">3.</span> 系统资源利用：</span><br><span class="line"><span class="bullet">   -</span> 32位软件：可能不会充分利用64位系统提供的更高效的指令集和增强的硬件特性。</span><br><span class="line"><span class="bullet">   -</span> 64位软件：设计上能更好地匹配64位CPU的特性，利用更多寄存器和指令集扩展，从而提高执行效率。</span><br><span class="line"></span><br><span class="line"><span class="bullet">4.</span> 兼容性与运行环境：</span><br><span class="line"><span class="bullet">   -</span> 32位软件：依赖于64位系统提供的兼容层（WoW64，Windows on Windows 64-bit）来运行，系统需提供32位库和环境。</span><br><span class="line"><span class="bullet">   -</span> 64位软件：直接在64位系统环境中运行，无需兼容层，可以更紧密地与系统交互，获取最佳性能。</span><br><span class="line"></span><br><span class="line"><span class="bullet">5.</span> 数据类型和指针大小：</span><br><span class="line"><span class="bullet">   -</span> 32位软件：指针和某些数据类型的大小通常为4字节。</span><br><span class="line"><span class="bullet">   -</span> 64位软件：指针大小通常为8字节，这影响了内存使用和数据对齐，有时也会影响数据结构的大小和效率。</span><br><span class="line"></span><br><span class="line">总的来说，尽管32位软件可以在64位系统上运行，但可能无法完全发挥64位系统的潜能，特别是在内存管理和性能方面。相比之下，64位软件能够更好地利用现代硬件资源，提供更高的性能和扩展性。</span><br></pre></td></tr></table></figure>
<h4 id="vector-map-list底层原理，复杂度"><a href="#vector-map-list底层原理，复杂度" class="headerlink" title="vector/map/list底层原理，复杂度"></a>vector/map/list底层原理，复杂度</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">在C++标准模板库(STL)中，<span class="code">`vector`</span>、<span class="code">`map`</span>、和<span class="code">`list`</span>是非常常用的数据结构，它们各有不同的底层实现和操作复杂度。</span><br><span class="line"></span><br><span class="line"><span class="section">### vector</span></span><br><span class="line"><span class="bullet">-</span> 底层原理：<span class="code">`vector`</span>是一个动态数组，它在内存中分配一块连续的空间来存储元素。当元素数量超出当前容量时，它会重新分配更大的内存块，并将原有元素复制过去。因此，它支持随机访问，但插入和删除元素（特别是中间位置）可能较慢，因为可能涉及元素的移动。</span><br><span class="line"><span class="bullet">-</span> 复杂度：</span><br><span class="line"><span class="bullet">  -</span> 访问：O(1)</span><br><span class="line"><span class="bullet">  -</span> 在末尾插入：常数时间（如果未触发重新分配），否则O(n)</span><br><span class="line"><span class="bullet">  -</span> 在中间或开头插入/删除：O(n)</span><br><span class="line"><span class="bullet">  -</span> 尾部删除：O(1)</span><br><span class="line"></span><br><span class="line"><span class="section">### map</span></span><br><span class="line"><span class="bullet">-</span> 底层原理：<span class="code">`map`</span>通常实现为红黑树（一种自平衡二叉查找树），它保持了键值对之间的有序关系。这意味着查找、插入和删除操作都能保证较高的效率。</span><br><span class="line"><span class="bullet">-</span> 复杂度：</span><br><span class="line"><span class="bullet">  -</span> 查找、插入、删除：O(log n)</span><br><span class="line"><span class="bullet">  -</span> 迭代：O(n)</span><br><span class="line"></span><br><span class="line"><span class="section">### list</span></span><br><span class="line"><span class="bullet">-</span> 底层原理：<span class="code">`list`</span>是一个双向链表，每个节点包含数据和两个指针，分别指向前一个和后一个节点。这种结构使得在列表的任何位置插入和删除元素都非常迅速，但不支持随机访问。</span><br><span class="line"><span class="bullet">-</span> 复杂度：</span><br><span class="line"><span class="bullet">  -</span> 在任何位置插入/删除：O(1)</span><br><span class="line"><span class="bullet">  -</span> 访问（通过迭代）：O(n)</span><br><span class="line"><span class="bullet">  -</span> 迭代：O(n)</span><br><span class="line"></span><br><span class="line">总结而言，<span class="code">`vector`</span>适合快速随机访问和在末尾进行高效的插入和删除，<span class="code">`map`</span>适合需要键值对且关心键的有序性的场景，而<span class="code">`list`</span>则在频繁进行插入和删除操作，且不需要随机访问时表现优秀。选择哪种容器取决于具体的应用需求。</span><br></pre></td></tr></table></figure>

<h4 id="常用数据结构的应用场景"><a href="#常用数据结构的应用场景" class="headerlink" title="常用数据结构的应用场景"></a>常用数据结构的应用场景</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">C++中常用的数据结构及其应用场景如下：</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 静态数组 (Array)</span><br><span class="line"><span class="bullet">   -</span> 特点：固定大小的连续内存空间，用于存储相同类型的元素。</span><br><span class="line"><span class="bullet">   -</span> 应用场景：适用于需要快速访问和处理的数据，且数据量大小已知且不变，如小型矩阵操作、固定大小的数据缓存。</span><br><span class="line"></span><br><span class="line"><span class="bullet">2.</span> 动态数组 (Vector)</span><br><span class="line"><span class="bullet">   -</span> 特点：自动管理内存的数组，可以动态增长。</span><br><span class="line"><span class="bullet">   -</span> 应用场景：当需要在运行时动态添加或删除元素，且频繁进行随机访问时，如动态数据缓冲区、结果集存储。</span><br><span class="line"></span><br><span class="line"><span class="bullet">3.</span> 队列 (Queue)</span><br><span class="line"><span class="bullet">   -</span> 特点：遵循先进先出（FIFO）原则的线性数据结构。</span><br><span class="line"><span class="bullet">   -</span> 应用场景：任务调度、消息传递、缓存系统中的数据处理顺序控制。</span><br><span class="line"></span><br><span class="line"><span class="bullet">4.</span> 优先队列 (Priority Queue)</span><br><span class="line"><span class="bullet">   -</span> 特点：特殊队列，每个元素都有一个优先级，每次删除的是优先级最高的元素。</span><br><span class="line"><span class="bullet">   -</span> 应用场景：事件驱动编程中的事件调度、任务优先级排序、Dijkstra算法中的最短路径计算。</span><br><span class="line"></span><br><span class="line"><span class="bullet">5.</span> 栈 (Stack)</span><br><span class="line"><span class="bullet">   -</span> 特点：遵循后进先出（LIFO）原则的线性数据结构。</span><br><span class="line"><span class="bullet">   -</span> 应用场景：函数调用栈、表达式求值、撤销操作的实现、括号匹配验证。</span><br><span class="line"></span><br><span class="line"><span class="bullet">6.</span> 链表 (LinkedList)</span><br><span class="line"><span class="bullet">   -</span> 特点：非连续内存空间，每个节点包含数据和指向下一个节点的指针。</span><br><span class="line"><span class="bullet">   -</span> 应用场景：频繁的插入和删除操作，不需要随机访问，如内存管理、实现其他高级数据结构如哈希表的桶。</span><br><span class="line"></span><br><span class="line"><span class="bullet">7.</span> 哈希表 (Hash Table)</span><br><span class="line"><span class="bullet">   -</span> 特点：通过散列函数将键映射到数组的索引，实现快速查找、插入和删除。</span><br><span class="line"><span class="bullet">   -</span> 应用场景：数据库索引、缓存、字典、集合等需要快速查找的场景。</span><br><span class="line"></span><br><span class="line"><span class="bullet">8.</span> 树 (Tree)</span><br><span class="line"><span class="bullet">   -</span> 特点：分层的非线性数据结构，用于表示具有层次关系的数据。</span><br><span class="line"><span class="bullet">   -</span> 应用场景：文件系统、DOM（文档对象模型）、表达式树、各种搜索算法（如二叉查找树、AVL树、红黑树等）。</span><br><span class="line"></span><br><span class="line"><span class="bullet">9.</span> 图 (Graph)</span><br><span class="line"><span class="bullet">   -</span> 特点：由节点（顶点）和边组成，表示对象之间的多对多关系。</span><br><span class="line"><span class="bullet">   -</span> 应用场景：社交网络分析、路线规划、网络流分析、编译器中的控制流图。</span><br><span class="line"></span><br><span class="line">每种数据结构的选择依据具体问题的需求，比如数据的访问模式（随机访问还是顺序访问）、数据的增删频率、数据的组织方式（线性还是非线性）等因素。</span><br></pre></td></tr></table></figure>

<h4 id="map的key是有序的吗"><a href="#map的key是有序的吗" class="headerlink" title="map的key是有序的吗"></a>map的key是有序的吗</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">是的，在C++中，<span class="code">`map`</span>的key是有序的。<span class="code">`map`</span>容器是通过红黑树实现的，它自动按照key的升序排序（默认情况下）。当你插入元素时，<span class="code">`map`</span>会根据key值将元素插入到适当的位置，以维护树的有序性。这使得对<span class="code">`map`</span>进行遍历会得到一个按key排序的序列。如果需要，你可以自定义比较函数来改变排序标准。</span><br></pre></td></tr></table></figure>

<h4 id="C-里面的内存分配方式，堆区和栈区的区别"><a href="#C-里面的内存分配方式，堆区和栈区的区别" class="headerlink" title="C++里面的内存分配方式，堆区和栈区的区别"></a>C++里面的内存分配方式，堆区和栈区的区别</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">C++中的内存分配方式主要涉及堆区（heap）和栈区（stack），它们有以下几点关键区别：</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 内存分配与管理：</span><br><span class="line"><span class="bullet">   -</span> 栈区：由编译器自动管理。当你声明局部变量或函数参数时，它们通常被分配在栈上。栈区的内存分配和释放非常快速，因为它只是调整栈指针。当函数调用结束或局部变量的作用域结束时，编译器会自动释放栈上分配的内存。</span><br><span class="line"><span class="bullet">   -</span> 堆区：需要程序员显式管理。通过<span class="code">`new`</span>运算符分配内存，并且必须使用<span class="code">`delete`</span>来释放内存。如果不释放，会导致内存泄漏。堆内存的分配和释放相对慢一些，因为系统需要维护一个空闲内存链表，并在分配时搜索合适的内存块，分配后还需更新链表。</span><br><span class="line"></span><br><span class="line"><span class="bullet">2.</span> 内存空间大小与连续性：</span><br><span class="line"><span class="bullet">   -</span> 栈区：空间相对较小，通常几兆字节，并且是连续的内存区域。栈溢出是常见的问题，尤其是当递归过深或局部变量过大时。</span><br><span class="line"><span class="bullet">   -</span> 堆区：空间更大，理论上仅受系统可用内存限制，内存分配不连续，通过链接不同的内存块来满足不同大小的请求。</span><br><span class="line"></span><br><span class="line"><span class="bullet">3.</span> 数据生命周期：</span><br><span class="line"><span class="bullet">   -</span> 栈区：数据生命周期与作用域相关，当作用域结束时，数据自动销毁。</span><br><span class="line"><span class="bullet">   -</span> 堆区：数据生命周期由程序员控制，直到显式释放或程序结束时由操作系统回收。</span><br><span class="line"></span><br><span class="line"><span class="bullet">4.</span> 访问速度：</span><br><span class="line"><span class="bullet">   -</span> 栈区：访问速度快，因为栈数据通常位于CPU的高速缓存附近。</span><br><span class="line"><span class="bullet">   -</span> 堆区：访问相对较慢，因为堆内存可能分布于内存的任何位置。</span><br><span class="line"></span><br><span class="line"><span class="bullet">5.</span> 用途：</span><br><span class="line"><span class="bullet">   -</span> 栈区：适用于短期、大小固定的内存需求，如局部变量、函数参数等。</span><br><span class="line"><span class="bullet">   -</span> 堆区：适用于长期、大小可变或未知的内存需求，如动态数组、大型数据结构、长时间存活的对象等。</span><br><span class="line"></span><br><span class="line">理解堆区和栈区的区别有助于编写更高效、更稳定的C++程序，合理选择内存分配方式对于程序性能和资源管理至关重要。</span><br></pre></td></tr></table></figure>

<h4 id="TCP-UDP的区别，三次握手四次分手"><a href="#TCP-UDP的区别，三次握手四次分手" class="headerlink" title="TCP/UDP的区别，三次握手四次分手"></a>TCP/UDP的区别，三次握手四次分手</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">TCP（Transmission Control Protocol）和UDP（User Datagram Protocol）是两种主要的传输层协议，它们在网络通信中扮演着不同的角色，主要区别在于连接性、可靠性、顺序保证和速度等方面：</span><br><span class="line"></span><br><span class="line"><span class="section">### TCP（传输控制协议）</span></span><br><span class="line"><span class="bullet">-</span> 连接性：TCP是面向连接的协议，它在数据传输前需要通过三次握手建立连接，确保两端准备好进行数据交换。</span><br><span class="line"><span class="bullet">-</span> 可靠性：TCP提供可靠的服务，通过确认、重传机制以及错误校验来确保数据正确无误地到达接收端。</span><br><span class="line"><span class="bullet">-</span> 顺序保证：TCP保证数据包按序到达，即使在网络中乱序，接收端也会根据序列号重新排序。</span><br><span class="line"><span class="bullet">-</span> 流量控制：TCP有流量控制机制，可以防止发送方过快发送数据导致接收方无法处理。</span><br><span class="line"><span class="bullet">-</span> 拥塞控制：TCP还实现了拥塞控制，以适应网络条件的变化，避免网络拥塞。</span><br><span class="line"></span><br><span class="line"><span class="section">### UDP（用户数据报协议）</span></span><br><span class="line"><span class="bullet">-</span> 连接性：UDP是无连接的协议，数据发送前无需建立连接，直接发送数据报。</span><br><span class="line"><span class="bullet">-</span> 可靠性：UDP不保证数据包一定能到达接收端，也不保证数据包的顺序，适用于对实时性要求高而能容忍一定丢包的场景。</span><br><span class="line"><span class="bullet">-</span> 头部开销：UDP头部比TCP简单，开销小，因此在某些情况下可以提供更高的传输效率。</span><br><span class="line"><span class="bullet">-</span> 应用：常用于多媒体流、DNS查询、在线游戏等对延迟敏感且可以容忍少量数据丢失的应用。</span><br><span class="line"></span><br><span class="line"><span class="section">### 三次握手</span></span><br><span class="line">TCP的三次握手过程如下：</span><br><span class="line"><span class="bullet">1.</span> 客户端发送一个带SYN（同步序列编号，Synchronize Sequence Number）标志的数据包给服务器，请求建立连接。</span><br><span class="line"><span class="bullet">2.</span> 服务器收到SYN后，回应一个SYN/ACK（确认序列编号，Acknowledgment Number）标志的数据包，确认客户端的请求并要求客户端确认。</span><br><span class="line"><span class="bullet">3.</span> 客户端收到服务器的SYN/ACK后，再发送一个ACK数据包给服务器，确认连接请求。至此，连接建立完成。</span><br><span class="line"></span><br><span class="line"><span class="section">### 四次挥手</span></span><br><span class="line">TCP的四次挥手（连接释放）过程如下：</span><br><span class="line"><span class="bullet">1.</span> 当一方完成数据传输后，发送一个FIN（结束标志，Finish）报文给另一方，表明自己已经没有数据发送了。</span><br><span class="line"><span class="bullet">2.</span> 另一方收到FIN后，发送一个ACK报文作为应答，表示确认收到FIN。</span><br><span class="line"><span class="bullet">3.</span> 当另一方也完成数据发送后，同样发送一个FIN报文给对方。</span><br><span class="line"><span class="bullet">4.</span> 最初发送FIN的一方收到这个FIN后，发送ACK报文作为应答，此时等待一段时间（通常是2个最大段生存期，MSL）后，连接彻底关闭。</span><br><span class="line"></span><br><span class="line">综上所述，TCP通过三次握手建立连接保证了数据传输的可靠性，而四次挥手确保了连接的优雅关闭，释放资源。相比之下，UDP则更为轻量，牺牲了一定的可靠性来换取更低的延迟和更简单的实现。</span><br></pre></td></tr></table></figure>

<h4 id="p2p协议选tcp还是udp"><a href="#p2p协议选tcp还是udp" class="headerlink" title="p2p协议选tcp还是udp"></a>p2p协议选tcp还是udp</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">如果我来设计一个P2P（点对点）系统，我会考虑同时使用TCP和UDP，因为两者各有优势，结合使用可以更好地适应不同的网络环境和应用场景。</span><br><span class="line"></span><br><span class="line">使用TCP的原因：</span><br><span class="line"><span class="bullet">1.</span> 可靠性：TCP提供了数据传输的可靠性保障，通过确认、重传、错误校验和流量控制机制，确保数据能够准确无误地到达对端，这对于需要高数据完整性的应用非常重要。</span><br><span class="line"><span class="bullet">2.</span> 有序性：TCP保证数据包按照发送顺序到达，适合那些对数据顺序有严格要求的场景。</span><br><span class="line"><span class="bullet">3.</span> 连接管理：TCP的连接状态可以帮助追踪和管理对等点之间的连接，简化了会话管理和控制逻辑。</span><br><span class="line"></span><br><span class="line">使用UDP的原因：</span><br><span class="line"><span class="bullet">1.</span> 低延迟：UDP没有TCP的握手和确认过程，也没有复杂的拥塞控制，因此传输数据的延迟更低，适合实时性和交互性要求高的应用，如VoIP、在线游戏和视频流。</span><br><span class="line"><span class="bullet">2.</span> 穿透NAT：UDP相较于TCP更容易实现NAT穿越，通过UDP打洞技术可以在不支持UPnP或NAT-T等协议的网络环境下建立P2P连接。</span><br><span class="line"><span class="bullet">3.</span> 灵活性：UDP的无连接特性允许更灵活的数据包格式和传输策略，开发者可以自定义控制逻辑，实现特定应用的需求，如自定义的流量控制和错误恢复机制。</span><br><span class="line"></span><br><span class="line">综合策略：</span><br><span class="line">理想情况下，P2P系统可以采用TCP作为基础通信协议，确保数据传输的可靠性和有序性；同时利用UDP作为辅助，特别是在需要优化延迟、实现NAT穿越或者对数据包的控制有特殊需求的情况下。此外，系统可以根据网络环境的检测结果动态选择或切换协议，例如对于有良好网络条件且对实时性要求较高的场景优先使用UDP，而对于需要高度可靠传输的环境则依赖TCP。这样的混合策略可以最大化地提升P2P系统的适应性和性能。</span><br></pre></td></tr></table></figure>

<h4 id="http协议（http请求和http响应协议）"><a href="#http协议（http请求和http响应协议）" class="headerlink" title="http协议（http请求和http响应协议）"></a>http协议（http请求和http响应协议）</h4><h4 id="UDP如何实现可靠性"><a href="#UDP如何实现可靠性" class="headerlink" title="UDP如何实现可靠性"></a>UDP如何实现可靠性</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">UDP（User Datagram Protocol）本身是一个无连接的、不可靠的传输层协议，它不提供像TCP那样的确认、重传、排序等机制来确保数据包的可靠传输。然而，如果需要在UDP基础上实现可靠性，可以通过在应用层增加额外的逻辑来模拟TCP的部分功能，以下是实现UDP可靠性传输的一些常见策略：</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 序列号（Sequence Numbers）：为每个发送的数据包分配一个唯一的序列号，接收端可以依据序列号来检测数据包的丢失、重复或乱序，并通知发送端进行相应的处理。</span><br><span class="line"></span><br><span class="line"><span class="bullet">2.</span> 确认（Acknowledgments）：接收端接收到数据包后，向发送端发送一个确认包，告知哪些数据包已经收到。发送端可以根据这些确认信息判断是否需要重传未被确认的数据包。</span><br><span class="line"></span><br><span class="line"><span class="bullet">3.</span> 超时重传（Retransmission on Timeout）：发送数据包时启动一个计时器，如果在预定时间内没有收到对应的确认，就重传该数据包。超时时间的设置需要权衡网络延迟和重传效率。</span><br><span class="line"></span><br><span class="line"><span class="bullet">4.</span> 流量控制（Flow Control）：虽然不是直接保证可靠性，但通过控制发送速率以匹配接收端的处理能力，可以间接减少数据丢失的可能性。这可以通过接收端发送窗口通告实现，告诉发送端当前能接收多少数据。</span><br><span class="line"></span><br><span class="line"><span class="bullet">5.</span> 拥塞控制（Congestion Control）：监测网络状况并相应调整发送速率，以避免过多的数据包在网络中积压导致丢包。这在多跳网络和公共互联网中尤为重要。</span><br><span class="line"></span><br><span class="line"><span class="bullet">6.</span> 滑动窗口（Sliding Window）：这是一种流量控制和拥塞控制的机制，通过维护发送和接收窗口来控制数据的流动，确保不会因为发送过快而导致接收方无法处理。</span><br><span class="line"></span><br><span class="line"><span class="bullet">7.</span> 校验和（Checksums）：虽然UDP自身包含了头部校验和来检测数据损坏，但在应用层也可以实施更高级的错误检测和纠正编码，以提高数据的完整性。</span><br><span class="line"></span><br><span class="line">通过上述机制的组合，可以在应用层构建出一个相对可靠的UDP传输系统，尽管这样做会增加实现的复杂度并可能降低传输效率。实际上，已经有一些协议和框架（如RUDP、RTP、UDT等）在UDP的基础上实现了这些机制，以提供更为可靠的数据传输服务。</span><br></pre></td></tr></table></figure>


<h4 id="C-11-17新特性"><a href="#C-11-17新特性" class="headerlink" title="C++ 11 /17新特性"></a>C++ 11 /17新特性</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">C++11和C++17是C++编程语言现代化过程中非常重要的两个版本，它们引入了大量新特性，显著提高了代码的简洁性、效率和安全性。以下是这两个版本中的一些关键新特性概览：</span><br><span class="line"></span><br><span class="line"><span class="section">### C++11新特性</span></span><br><span class="line"><span class="bullet">1.</span> 自动类型推导（Auto）: 允许编译器根据初始值推断变量的类型，简化了类型声明，特别是对于复杂类型。</span><br><span class="line"><span class="bullet">2.</span> Lambda表达式: 引入了匿名函数，可以直接在代码中定义并立即使用。</span><br><span class="line"><span class="bullet">3.</span> 右值引用与移动语义: 支持转移而非复制对象，提升了性能，尤其是在处理临时对象和大对象时。</span><br><span class="line"><span class="bullet">4.</span> 范围for循环（Range-based for loop）: 提供了一种简洁的遍历容器或数组元素的方式。</span><br><span class="line"><span class="bullet">5.</span> 智能指针（Smart Pointers）: 如<span class="code">`std::unique_ptr`</span>和<span class="code">`std::shared_ptr`</span>，自动管理内存，减少了内存泄露的风险。</span><br><span class="line"><span class="bullet">6.</span> 线程库（Thread Library）: 标准化了多线程编程的支持，包括<span class="code">`std::thread`</span>、互斥锁、条件变量等。</span><br><span class="line"><span class="bullet">7.</span> 枚举类（Enum Classes）: 更安全的枚举类型，避免了枚举值的隐式转换。</span><br><span class="line"></span><br><span class="line"><span class="section">### C++17新特性</span></span><br><span class="line"><span class="bullet">1.</span> 结构化绑定（Structured Binding）: 允许从数组、tuple或自定义类型中解构绑定到多个变量，提高代码的可读性。</span><br><span class="line"><span class="bullet">2.</span> 泛型Lambda表达式: 扩展了Lambda表达式的能力，使其可以声明模板参数，从而处理任意类型。</span><br><span class="line"><span class="bullet">3.</span> std::optional: 表示可能缺失的值，提供了一种更安全的空值处理方式。</span><br><span class="line"><span class="bullet">4.</span> std::variant: 类似于加强版的联合体，能够安全地存储多种类型之一，并且知道当前存储的是哪种类型。</span><br><span class="line"><span class="bullet">5.</span> 文件系统库（Filesystem Library）: 标准化了文件操作接口，跨平台处理文件路径、目录等。</span><br><span class="line"><span class="bullet">6.</span> 并行算法（Parallel Algorithms）: 在<span class="code">`&lt;algorithm&gt;`</span>头文件中增加了并行版本的算法，如<span class="code">`std::sort`</span>，利用多核处理器加速计算。</span><br><span class="line"><span class="bullet">7.</span> 折叠表达式（Fold Expressions）: 使得模板元编程更加灵活，可以更简洁地实现元编程中的折叠操作。</span><br><span class="line"></span><br><span class="line">这些新特性不仅丰富了C++的标准库，还使得编写现代C++代码变得更加高效和安全。开发者应考虑利用这些特性来提升代码的质量和开发效率。</span><br></pre></td></tr></table></figure>

<h4 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">深拷贝和浅拷贝是计算机编程中关于对象复制的概念，主要涉及如何处理对象的属性，特别是指针或引用类型的成员变量。它们主要出现在面向对象编程语言中，如C++、Java等。理解深拷贝和浅拷贝的区别对于避免内存泄漏、数据不一致等问题至关重要。</span><br><span class="line"></span><br><span class="line"><span class="section">### 浅拷贝（Shallow Copy）</span></span><br><span class="line"><span class="bullet">-</span> 定义：浅拷贝只复制对象的指针或引用，而不复制指针所指向的数据。这意味着原始对象和拷贝对象共享同一份数据。如果一个对象被修改，另一个对象也会受到影响。</span><br><span class="line"><span class="bullet">-</span> 实现：在C++中，如果类没有自定义拷贝构造函数或赋值运算符，编译器会自动生成一个浅拷贝版本。</span><br><span class="line"><span class="bullet">-</span> 例子：假设有两个类对象，其中一个对象的指针成员指向一块动态分配的内存，浅拷贝只会复制这个指针，导致两个对象都指向同一块内存。</span><br><span class="line"></span><br><span class="line"><span class="section">### 深拷贝（Deep Copy）</span></span><br><span class="line"><span class="bullet">-</span> 定义：深拷贝不仅复制对象本身，还递归地复制对象内部的所有指针变量所指向的数据。结果是原始对象和拷贝对象拥有完全独立的数据副本，互不影响。</span><br><span class="line"><span class="bullet">-</span> 实现：在C++中，通常需要手动定义拷贝构造函数或赋值运算符来实现深拷贝，确保指针成员所指向的数据也被复制。</span><br><span class="line"><span class="bullet">-</span> 例子：同样是两个类对象，深拷贝会为指针成员指向的数据分配新的内存，复制数据内容，使得两个对象各自拥有独立的数据副本。</span><br><span class="line"></span><br><span class="line"><span class="section">### 区别总结</span></span><br><span class="line"><span class="bullet">-</span> 数据独立性：深拷贝的两个对象数据完全独立，修改一个对象不会影响另一个；而浅拷贝的对象共享数据，一个对象的修改会影响到另一个。</span><br><span class="line"><span class="bullet">-</span> 内存使用：深拷贝会占用更多的内存，因为它需要复制所有数据；浅拷贝则不复制数据，只是复制指针，节省内存但可能导致数据不一致问题。</span><br><span class="line"><span class="bullet">-</span> 适用场景：当对象包含动态分配的内存或资源时，应使用深拷贝以确保数据的完整性和独立性。对于简单类型或不需要独立副本的情况，浅拷贝可能更合适。</span><br><span class="line"></span><br><span class="line">在实际编程中，根据对象的特性正确选择和实现拷贝方式是非常重要的。</span><br></pre></td></tr></table></figure>

<h4 id="C-的多态是怎么实现的"><a href="#C-的多态是怎么实现的" class="headerlink" title="C++的多态是怎么实现的"></a>C++的多态是怎么实现的</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">C++中的多态主要通过虚函数（virtual functions）和动态绑定（dynamic binding，也称作迟绑定或运行时绑定）来实现。以下是其实现原理的详细说明：</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 虚函数（Virtual Functions）:</span><br><span class="line"><span class="bullet">   -</span> 虚函数是在基类中声明的，使用关键字<span class="code">`virtual`</span>标识。它的主要目的是允许在派生类中重写该函数，以实现不同的行为。</span><br><span class="line"><span class="bullet">   -</span> 每个含有虚函数的类都会有一个虚函数表（Virtual Table，简称vtable），这是一个存储类中所有虚函数指针的表。vtable在编译时期由编译器生成。</span><br><span class="line"><span class="bullet">   -</span> 当创建一个类的实例时，该实例会包含一个指向其所属类vtable的指针（称为vptr）。这个指针通常在对象的内存布局中是隐藏的。</span><br><span class="line"></span><br><span class="line"><span class="bullet">2.</span> 动态绑定（Dynamic Binding）:</span><br><span class="line"><span class="bullet">   -</span> 动态绑定意味着在运行时决定调用哪个函数实现，这取决于对象的实际类型而不是引用或指针的类型。</span><br><span class="line"><span class="bullet">   -</span> 当通过基类的指针或引用来调用虚函数时，程序不是直接跳转到编译时期确定的地址，而是通过对象的vptr查找vtable，然后根据vtable中对应虚函数的地址调用函数。</span><br><span class="line"><span class="bullet">   -</span> 如果派生类重写了基类的虚函数，则调用时会执行派生类中的版本，实现了多态行为。</span><br><span class="line"></span><br><span class="line"><span class="bullet">3.</span> 重写（Overriding）:</span><br><span class="line"><span class="bullet">   -</span> 在派生类中，你可以重写基类的虚函数，提供自己的实现。为了正确实现重写，派生类中的函数需要与基类中的虚函数具有相同的签名（函数名、返回类型及参数列表）。</span><br><span class="line"><span class="bullet">   -</span> 重写的函数默认也是虚函数，除非明确使用<span class="code">`final`</span>关键字禁止进一步重写。</span><br><span class="line"></span><br><span class="line"><span class="bullet">4.</span> 纯虚函数与抽象类:</span><br><span class="line"><span class="bullet">   -</span> 纯虚函数是在基类中声明但没有具体实现的虚函数，需要在派生类中实现。声明纯虚函数的类不能实例化，此类被称为抽象类。</span><br><span class="line"><span class="bullet">   -</span> 抽象类通常作为接口使用，定义了一组需要派生类实现的接口规范。</span><br><span class="line"></span><br><span class="line">通过上述机制，C++允许程序员编写灵活且可扩展的代码，其中基类的指针或引用可以指向不同派生类的对象，并且能够调用这些对象的特定实现，而无需显式地知道对象的确切类型，从而实现了多态性。</span><br></pre></td></tr></table></figure>

<h4 id="C-继承的实现原理"><a href="#C-继承的实现原理" class="headerlink" title="C++继承的实现原理"></a>C++继承的实现原理</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">C++中的继承实现原理主要是通过以下几个方面体现的：</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 内存布局：当一个派生类从基类继承时，派生类的对象内存布局会首先包含基类的全部非静态数据成员，接着才是派生类自己新增的数据成员。这意味着，派生类对象中包含了基类的所有数据，从而能够访问和操作这些数据。</span><br><span class="line"></span><br><span class="line"><span class="bullet">2.</span> 虚函数表：C++中，如果基类或派生类中定义了至少一个虚函数，则编译器会为该类生成一个虚函数表（vtable）。这个表是一个函数指针数组，存储了所有虚函数的地址。每个具有虚函数的类都有自己的虚函数表，派生类的虚函数表会从基类继承，并在其基础上添加或覆盖相应的函数指针。派生类对象会有一个指向自己虚函数表的隐藏指针（称为vptr），这使得在运行时能够根据对象的实际类型动态调用正确的虚函数。</span><br><span class="line"></span><br><span class="line"><span class="bullet">3.</span> 构造函数和析构函数的调用顺序：构造函数的调用顺序是从基类到派生类，即先调用基类的构造函数，再调用派生类自己的构造函数。析构函数的调用顺序则相反，先调用派生类的析构函数，再调用基类的析构函数。这种顺序确保了资源的正确初始化和释放。</span><br><span class="line"></span><br><span class="line"><span class="bullet">4.</span> 访问权限：继承时，基类的公有（public）和保护（protected）成员对派生类是可见的，而私有（private）成员则不可见。派生类可以进一步指定继承的方式（public, protected, private），影响派生类对象对基类成员的访问权限以及派生类的继承性。</span><br><span class="line"></span><br><span class="line"><span class="bullet">5.</span> 多态性：通过虚函数，C++实现了动态多态。派生类可以重写基类的虚函数，当通过基类指针或引用来调用这些函数时，实际执行的是派生类中的实现。这是通过运行时解析虚函数表来实现的。</span><br><span class="line"></span><br><span class="line"><span class="bullet">6.</span> 虚继承（virtual inheritance）：为了解决多继承情况下基类的重复问题（菱形问题），C++提供了虚继承机制。虚继承使得无论派生类有多少条路径继承同一个基类，基类的子对象在派生类中只有一份，从而解决了二义性和存储浪费的问题。</span><br><span class="line"></span><br><span class="line">通过上述机制，C++的继承不仅允许代码的复用，而且支持了面向对象的三大特性之一——多态，使得程序设计更加灵活和高效。</span><br></pre></td></tr></table></figure>

<h4 id="C-的整个编译过程"><a href="#C-的整个编译过程" class="headerlink" title="C++的整个编译过程"></a>C++的整个编译过程</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">C++的编译过程可以大致分为以下几个阶段：</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 预处理（Preprocessing）:</span><br><span class="line"><span class="bullet">   -</span> 这是编译的第一步，编译器使用预处理器（如cpp）处理源代码文件。预处理器负责展开宏定义、处理条件编译指令（如<span class="code">`#ifdef`</span>, <span class="code">`#endif`</span>）、移除注释、插入头文件（通过<span class="code">`#include`</span>指令）等。经过预处理后，生成一个没有预处理指令的纯源代码文件，通常以<span class="code">`.i`</span>或<span class="code">`.ii`</span>为扩展名。</span><br><span class="line"></span><br><span class="line"><span class="bullet">2.</span> 编译（Compilation）:</span><br><span class="line"><span class="bullet">   -</span> 在这个阶段，编译器（如g++或clang++）将预处理后的源代码转换为汇编语言。这个过程包括词法分析、语法分析、语义分析等，检查源代码的语法错误和类型错误，并进行各种优化。完成后，生成汇编代码文件，扩展名为<span class="code">`.s`</span>或<span class="code">`.asm`</span>。</span><br><span class="line"></span><br><span class="line"><span class="bullet">3.</span> 汇编（Assembly）:</span><br><span class="line"><span class="bullet">   -</span> 汇编器将汇编代码转换为目标代码（或目标对象文件），这是机器语言的一种低级表示形式，但还不是可执行文件。每个源文件通常会编译成一个单独的目标文件，扩展名可能是<span class="code">`.o`</span>或<span class="code">`.obj`</span>。</span><br><span class="line"></span><br><span class="line"><span class="bullet">4.</span> 链接（Linking）:</span><br><span class="line"><span class="bullet">   -</span> 链接器将所有目标文件以及任何所需的库文件连接在一起，形成最终的可执行文件。这个过程包括解析未解决的符号引用（如外部函数或全局变量）、调整代码段和数据段的地址、去除未使用的代码（如果开启了相应选项）等。链接成功后，就得到了可以直接运行的可执行文件，其扩展名依赖于操作系统，如Windows下的<span class="code">`.exe`</span>，Linux下的无扩展名或<span class="code">`.out`</span>等。</span><br><span class="line"></span><br><span class="line"><span class="bullet">5.</span> 可选的优化步骤:</span><br><span class="line"><span class="bullet">   -</span> 在编译和链接过程中，编译器和链接器可能会执行各种级别的优化，以提高生成代码的效率。这些优化可能包括循环优化、内联函数展开、常量传播等，旨在减少代码大小、提高执行速度或降低能耗。</span><br><span class="line"></span><br><span class="line">综上所述，C++的整个编译过程涉及从高级语言源代码到可执行文件的多个转换步骤，确保了代码的平台兼容性和高效执行。</span><br></pre></td></tr></table></figure>


<h4 id="cpu-1ghz数每毫秒运行几次"><a href="#cpu-1ghz数每毫秒运行几次" class="headerlink" title="cpu 1ghz数每毫秒运行几次"></a>cpu 1ghz数每毫秒运行几次</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CPU的时钟频率，也就是这里的1GHz（千兆赫兹），表示CPU每秒钟可以进行10亿（1,000,000,000）个周期。要计算每毫秒（千分之一秒）能执行多少个周期，我们可以做如下换算：</span><br><span class="line"></span><br><span class="line">1GHz = 1,000,000,000Hz</span><br><span class="line"></span><br><span class="line">这意味着每秒10亿个周期，那么每毫秒的周期数为：</span><br><span class="line"></span><br><span class="line">1,000,000,000Hz/1,000 = 1,000,000周期/毫秒</span><br><span class="line"></span><br><span class="line">所以，一个1GHz的CPU每毫秒可以执行1百万个周期。</span><br><span class="line"></span><br><span class="line">然而，要注意的是，这仅是指CPU的时钟周期，并不直接等同于指令执行次数。一条C++指令可能需要一个或多个时钟周期来完成，具体取决于CPU架构、指令类型及是否发生缓存命中等因素。因此，实际的C++指令执行次数会少于这个理论值。为了得到更精确的每毫秒指令执行次数，还需要考虑程序的具体情况和CPU的性能特征。</span><br></pre></td></tr></table></figure>

<h4 id="CPU时间片"><a href="#CPU时间片" class="headerlink" title="CPU时间片"></a>CPU时间片</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CPU时间片（Time Slice）是操作系统中用于实现进程（或线程）调度的基本概念之一。在现代多任务操作系统中，CPU时间被划分为多个微小的时间片段，每个正在执行的进程或线程被分配一段这样的时间片来使用CPU。当一个进程或线程用完它的时间片后，操作系统会暂停其执行，保存其上下文（即当前的执行状态），然后将CPU控制权交给下一个进程或线程，这个过程称为上下文切换。</span><br><span class="line"></span><br><span class="line">CPU时间片机制的主要目的和作用包括：</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 实现多任务处理：通过快速地在多个进程或线程间切换，给用户一种多个任务同时运行的错觉，即使在单CPU或多核CPU系统上也能实现并发执行。</span><br><span class="line"></span><br><span class="line"><span class="bullet">2.</span> 公平性：确保系统中的每个进程都有机会使用CPU，防止某个进程长时间独占CPU资源，从而保证了系统整体的响应性和公平性。</span><br><span class="line"></span><br><span class="line"><span class="bullet">3.</span> 提高系统响应性：即使有长时间运行或等待某些事件（如I/O操作）的进程，通过时间片轮转，可以让其他准备好的进程有机会执行，减少系统延迟。</span><br><span class="line"></span><br><span class="line"><span class="bullet">4.</span> 灵活性：操作系统可以根据进程的不同需求和优先级动态调整时间片的长度，比如对实时性要求高的进程可以分配较短的时间片以减少响应延迟，而对于批处理任务可以给予较长的时间片。</span><br><span class="line"></span><br><span class="line">CPU时间片的长度由操作系统的设计者设定，通常在几毫秒到几十毫秒之间，具体取决于系统的设计目标和负载情况。较短的时间片可以提高系统的响应速度和交互性，但会增加上下文切换的开销；较长的时间片减少了切换频率，提高了CPU效率，但可能导致某些进程等待时间变长。</span><br></pre></td></tr></table></figure>


<h4 id="对称和非对称加密"><a href="#对称和非对称加密" class="headerlink" title="对称和非对称加密"></a>对称和非对称加密</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">对称加密和非对称加密是现代密码学中两种基本的加密方法，它们在确保数据的安全传输和存储中扮演着至关重要的角色，但工作原理和适用场景有所不同。</span><br><span class="line"></span><br><span class="line"><span class="section">### 对称加密</span></span><br><span class="line"><span class="bullet">-</span> 原理：对称加密使用相同的密钥进行数据的加密和解密。这意味着发送方和接收方必须共享同一个密钥，并且在通信前需要通过安全的渠道交换这个密钥。</span><br><span class="line"><span class="bullet">-</span> 优点：对称加密算法通常处理速度快，加密和解密效率高，适合处理大量数据。</span><br><span class="line"><span class="bullet">-</span> 缺点：密钥管理是其主要挑战，因为所有参与方都需要相同的密钥，一旦密钥泄露，加密数据的安全性就会受到威胁。</span><br><span class="line"><span class="bullet">-</span> 典型应用：对称加密常用于如TLS/SSL协议中的数据传输加密、数据库加密、磁盘加密等场景。</span><br><span class="line"></span><br><span class="line"><span class="section">### 非对称加密</span></span><br><span class="line"><span class="bullet">-</span> 原理：非对称加密使用一对密钥，分别是公钥和私钥。公钥用于加密数据，私钥用于解密数据。公钥可以公开分享，而私钥必须保密。</span><br><span class="line"><span class="bullet">-</span> 优点：安全性高，因为私钥不需要在网络中传输，降低了密钥泄露的风险。此外，非对称加密还支持数字签名，增强信息的完整性和验证发送者的身份。</span><br><span class="line"><span class="bullet">-</span> 缺点：相比对称加密，非对称加密的计算复杂度高，处理速度慢，不适合直接用于大量数据的加密。</span><br><span class="line"><span class="bullet">-</span> 典型应用：非对称加密常用于密钥交换（如TLS握手阶段）、数字签名、加密电子邮件、软件签名等场景。</span><br><span class="line"></span><br><span class="line"><span class="section">### 结合使用</span></span><br><span class="line">在实际应用中，对称加密和非对称加密经常结合使用以互补优缺点。例如，在TLS协议中，首先使用非对称加密来安全地交换对称密钥，随后使用这个对称密钥来高效地加密大量数据传输，这样既保证了密钥交换的安全性，又保证了数据传输的效率。</span><br></pre></td></tr></table></figure>


<h4 id="进程间通信常见几种方式和他们之间的区别、优缺点，详述"><a href="#进程间通信常见几种方式和他们之间的区别、优缺点，详述" class="headerlink" title="进程间通信常见几种方式和他们之间的区别、优缺点，详述"></a>进程间通信常见几种方式和他们之间的区别、优缺点，详述</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">进程间通信（IPC, Inter-Process Communication）是多进程系统中实现数据交换和协调的关键机制。下面详细介绍几种常见的进程间通信方式及其区别、优缺点：</span><br><span class="line"></span><br><span class="line"><span class="section">### 1. 共享内存（Shared Memory）</span></span><br><span class="line"><span class="bullet">-</span> 概念：多个进程共享同一块物理内存区域，通过读写这块内存来进行数据交换。</span><br><span class="line"><span class="bullet">-</span> 优点：</span><br><span class="line"><span class="bullet">  -</span> 速度快，因为数据直接在内存中交换，不需要通过内核进行复制。</span><br><span class="line"><span class="bullet">  -</span> 适用于大量数据的快速传输。</span><br><span class="line"><span class="bullet">-</span> 缺点：</span><br><span class="line"><span class="bullet">  -</span> 需要处理同步和互斥问题，避免数据一致性问题，可能导致竞态条件和死锁。</span><br><span class="line"><span class="bullet">  -</span> 对共享内存的访问控制复杂，需要使用信号量、互斥锁等机制来保证数据的正确性。</span><br><span class="line"></span><br><span class="line"><span class="section">### 2. 信号量（Semaphores）</span></span><br><span class="line"><span class="bullet">-</span> 概念：一种用于控制多个进程对共享资源访问的同步机制，通过计数来决定是否允许进程进入临界区。</span><br><span class="line"><span class="bullet">-</span> 优点：</span><br><span class="line"><span class="bullet">  -</span> 可以实现对共享资源的独占访问，有效避免竞态条件和死锁。</span><br><span class="line"><span class="bullet">  -</span> 适用于同步和互斥问题的解决。</span><br><span class="line"><span class="bullet">-</span> 缺点：</span><br><span class="line"><span class="bullet">  -</span> 相比直接的数据交换方式，增加了实现的复杂度。</span><br><span class="line"><span class="bullet">  -</span> 需要仔细管理信号量的使用，否则可能导致死锁或资源泄漏。</span><br><span class="line"></span><br><span class="line"><span class="section">### 3. 套接字（Sockets）</span></span><br><span class="line"><span class="bullet">-</span> 概念：最初用于网络通信，但也可用于同一主机上的进程间通信。</span><br><span class="line"><span class="bullet">-</span> 优点：</span><br><span class="line"><span class="bullet">  -</span> 跨平台性强，可在不同计算机或同一计算机的不同进程中通信。</span><br><span class="line"><span class="bullet">  -</span> 支持TCP和UDP等协议，适应不同的通信需求。</span><br><span class="line"><span class="bullet">-</span> 缺点：</span><br><span class="line"><span class="bullet">  -</span> 实现和管理相对复杂。</span><br><span class="line"><span class="bullet">  -</span> 需要考虑网络延迟和数据包丢失问题，可能影响实时性和可靠性。</span><br><span class="line"></span><br><span class="line"><span class="section">### 4. 管道（Pipes）</span></span><br><span class="line"><span class="bullet">-</span> 概念：分为无名管道和有名管道，是半双工的通信方式，数据只能单向流动。</span><br><span class="line"><span class="bullet">  -</span> 无名管道：主要用于有亲缘关系的进程间（如父子进程）。</span><br><span class="line"><span class="bullet">  -</span> 有名管道：允许无亲缘关系的进程间通信。</span><br><span class="line"><span class="bullet">-</span> 优点：</span><br><span class="line"><span class="bullet">  -</span> 实现简单，易于使用。</span><br><span class="line"><span class="bullet">  -</span> 有名管道可用于非亲缘进程通信。</span><br><span class="line"><span class="bullet">-</span> 缺点：</span><br><span class="line"><span class="bullet">  -</span> 半双工，数据只能单向传输，双向通信需建立两条管道。</span><br><span class="line"><span class="bullet">  -</span> 无名管道局限于亲缘进程间。</span><br><span class="line"></span><br><span class="line"><span class="section">### 5. 消息队列（Message Queues）</span></span><br><span class="line"><span class="bullet">-</span> 概念：消息按先进先出（FIFO）原则存储，进程间通过发送和接收消息进行通信。</span><br><span class="line"><span class="bullet">-</span> 优点：</span><br><span class="line"><span class="bullet">  -</span> 支持消息的异步发送和接收。</span><br><span class="line"><span class="bullet">  -</span> 可以实现进程间的解耦。</span><br><span class="line"><span class="bullet">-</span> 缺点：</span><br><span class="line"><span class="bullet">  -</span> 相对于共享内存，消息队列的通信效率较低。</span><br><span class="line"><span class="bullet">  -</span> 系统需要维护消息队列的额外开销。</span><br><span class="line"></span><br><span class="line"><span class="section">### 6. 信号（Signals）</span></span><br><span class="line"><span class="bullet">-</span> 概念：一种进程间轻量级的异步通信方式，用于通知进程发生了某种事件。</span><br><span class="line"><span class="bullet">-</span> 优点：</span><br><span class="line"><span class="bullet">  -</span> 简单、轻量，适用于简单的通知和紧急处理。</span><br><span class="line"><span class="bullet">-</span> 缺点：</span><br><span class="line"><span class="bullet">  -</span> 传递的信息有限，仅能携带少量数据（通常是信号编号）。</span><br><span class="line"><span class="bullet">  -</span> 不适合复杂的数据传输和通信。</span><br><span class="line"></span><br><span class="line"><span class="section">### 7. 共享文件（Shared Files）</span></span><br><span class="line"><span class="bullet">-</span> 概念：通过文件系统中的文件进行数据交换，如管道文件。</span><br><span class="line"><span class="bullet">-</span> 优点：</span><br><span class="line"><span class="bullet">  -</span> 实现简单，易于理解和使用。</span><br><span class="line"><span class="bullet">  -</span> 可以跨越网络共享。</span><br><span class="line"><span class="bullet">-</span> 缺点：</span><br><span class="line"><span class="bullet">  -</span> 同步问题复杂，易产生竞态条件。</span><br><span class="line"><span class="bullet">  -</span> 数据交换效率相对较低。</span><br><span class="line"></span><br><span class="line">每种方式都有其适用场景，选择合适的进程间通信方式需考虑通信的数据量、实时性要求、同步需求以及系统环境等因素。</span><br></pre></td></tr></table></figure>


<h4 id="单例模式怎么实现，能拷贝构造吗，单例的优点是什么"><a href="#单例模式怎么实现，能拷贝构造吗，单例的优点是什么" class="headerlink" title="单例模式怎么实现，能拷贝构造吗，单例的优点是什么"></a>单例模式怎么实现，能拷贝构造吗，单例的优点是什么</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">单例模式通常有几种实现方式，包括但不限于：</span><br><span class="line"></span><br><span class="line">饿汉式（静态实例）：在类加载时就完成了实例化，避免了线程同步问题。</span><br><span class="line">懒汉式（双重检查锁定）：延迟加载，在第一次使用时进行实例化，并通过双重检查锁定避免多次实例化。</span><br><span class="line">静态内部类：利用了classloader的机制来保证初始化instance时只有一个线程。</span><br><span class="line">枚举：在Java中推荐使用，C++中虽不常用，但也是一种实现方式。</span><br><span class="line">能拷贝构造吗？</span><br><span class="line"></span><br><span class="line">单例模式通常不允许拷贝构造和赋值操作，以确保只有一个实例存在。因此，单例类的拷贝构造函数和赋值操作符通常被声明为delete（在C++11及以后版本中）或声明为私有并不实现（在C++11之前）。</span><br><span class="line"></span><br><span class="line">单例的优点是什么？</span><br><span class="line"></span><br><span class="line">全局访问：可以在任何地方访问，无需频繁创建和销毁对象。</span><br><span class="line">节省资源：由于只有一个实例，避免了重复创建和销毁对象带来的资源消耗。</span><br><span class="line">管理方便：可以控制实例的创建和销毁，方便管理和维护。</span><br><span class="line">简化设计：在某些场景中，单例模式可以简化系统设计，如日志系统、配置管理等。</span><br></pre></td></tr></table></figure>


<h4 id="静态全局变量和静态局部变量"><a href="#静态全局变量和静态局部变量" class="headerlink" title="静态全局变量和静态局部变量"></a>静态全局变量和静态局部变量</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">静态全局变量和静态局部变量是C/C++编程中两种特殊的存储类别，它们的特点和区别主要体现在作用域、生命周期和存储位置上：</span><br><span class="line"></span><br><span class="line"><span class="section">### 静态全局变量</span></span><br><span class="line"><span class="bullet">-</span> 作用域：静态全局变量具有文件作用域，这意味着它只在定义它的源文件内是可见的。即便在多文件程序中，其他文件中的代码无法直接访问这个静态全局变量，除非通过extern关键字声明。</span><br><span class="line"><span class="bullet">-</span> 生命周期：静态全局变量的生命周期是整个程序的运行期间。从程序开始执行时创建，直到程序结束时才被销毁。</span><br><span class="line"><span class="bullet">-</span> 初始化：静态全局变量如果没有显式初始化，默认初始化为0（或相应的默认值，如NULL对于指针）。</span><br><span class="line"><span class="bullet">-</span> 存储位置：存储在程序的静态存储区域，不在堆栈上，因此不会因为函数调用结束而消失。</span><br><span class="line"></span><br><span class="line"><span class="section">### 静态局部变量</span></span><br><span class="line"><span class="bullet">-</span> 作用域：静态局部变量具有局部作用域，即它只在定义它的函数或代码块内可见。</span><br><span class="line"><span class="bullet">-</span> 生命周期：虽然作用域是局部的，但静态局部变量的生命周期却是整个程序的运行期间。这意味着即使函数被多次调用，静态局部变量也只会被初始化一次，并且在函数调用间保持其值。</span><br><span class="line"><span class="bullet">-</span> 初始化：同样地，如果没有显式初始化，静态局部变量也会被初始化为0（或相应的默认值）。</span><br><span class="line"><span class="bullet">-</span> 存储位置：和静态全局变量一样，存储在静态存储区域，不会因为函数返回而释放其存储空间。</span><br><span class="line"></span><br><span class="line"><span class="section">### 总结</span></span><br><span class="line">两者之间的主要差异在于作用域的不同：静态全局变量在整个文件内可见，而静态局部变量的作用域局限于定义它的函数或代码块。然而，它们都具有跨越函数调用的持久存储特性，存储在静态存储区，且生命周期都是整个程序执行期间。此外，静态局部变量因其局部作用域的特性，常用于需要在函数多次调用间保持状态的场景，而又不希望该状态对函数外部可见的情况。</span><br></pre></td></tr></table></figure>


<h4 id="简单的实现一个string类"><a href="#简单的实现一个string类" class="headerlink" title="简单的实现一个string类"></a>简单的实现一个string类</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 默认构造函数，初始化为空字符串</span></span><br><span class="line">    <span class="built_in">String</span>() : <span class="built_in">data_</span>(<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>]), <span class="built_in">length_</span>(<span class="number">0</span>) &#123;</span><br><span class="line">        data_[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化为指定C字符串的构造函数</span></span><br><span class="line">    <span class="built_in">String</span>(<span class="keyword">const</span> <span class="keyword">char</span>* str) &#123;</span><br><span class="line">        length_ = <span class="built_in">strlen</span>(str);</span><br><span class="line">        data_ = <span class="keyword">new</span> <span class="keyword">char</span>[length_ + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(data_, str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">String</span>(<span class="keyword">const</span> String&amp; other) &#123;</span><br><span class="line">        length_ = other.length_;</span><br><span class="line">        data_ = <span class="keyword">new</span> <span class="keyword">char</span>[length_ + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(data_, other.data_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动构造函数（C++11及以上）</span></span><br><span class="line">    <span class="built_in">String</span>(String&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        data_ = other.data_;</span><br><span class="line">        length_ = other.length_;</span><br><span class="line">        other.data_ = <span class="literal">nullptr</span>;</span><br><span class="line">        other.length_ = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">String</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] data_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值运算符重载</span></span><br><span class="line">    String&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> String&amp; other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] data_;</span><br><span class="line">            length_ = other.length_;</span><br><span class="line">            data_ = <span class="keyword">new</span> <span class="keyword">char</span>[length_ + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(data_, other.data_);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取字符串长度</span></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> length_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; data_ &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* data_;   <span class="comment">// 指向字符串数据的指针</span></span><br><span class="line">    <span class="keyword">size_t</span> length_; <span class="comment">// 字符串长度</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">s1</span><span class="params">(<span class="string">&quot;Hello, World!&quot;</span>)</span></span>;</span><br><span class="line">    s1.<span class="built_in">print</span>(); <span class="comment">// 输出: Hello, World!</span></span><br><span class="line">    String s2 = s1; <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">    s2.<span class="built_in">print</span>(); <span class="comment">// 输出: Hello, World!</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<hr>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h5 id="1-智能指针"><a href="#1-智能指针" class="headerlink" title="1.智能指针"></a>1.智能指针</h5><ul>
<li>底层实现</li>
<li>QPointer、QScopedPointer、QSharedDataPointer</li>
</ul>
<h5 id="2-指针"><a href="#2-指针" class="headerlink" title="2.指针"></a>2.指针</h5><ul>
<li>指针常量和常量指针的区别</li>
</ul>
<h5 id="3-构造析构"><a href="#3-构造析构" class="headerlink" title="3.构造析构"></a>3.构造析构</h5><ul>
<li>基类构造, 子类构造, 子类成员变量的构造顺序是什么</li>
</ul>
<h5 id="4-虚函数"><a href="#4-虚函数" class="headerlink" title="4.虚函数"></a>4.<strong>虚函数</strong></h5><ul>
<li>多态中，父类与子类的虚表一样吗？如果一个子类的方法用了override关键字呢，虚表又是否相同</li>
<li>多继承下的虚函数表</li>
<li>虚表指针的大小</li>
<li>虚函数和纯虚函数的区别</li>
</ul>
<h5 id="5-线程和进程"><a href="#5-线程和进程" class="headerlink" title="5.线程和进程"></a>5.<strong>线程和进程</strong></h5><ul>
<li>多线程用过吗, 交互有哪些方式</li>
<li>多线程读写同一个静态变量你是怎么解决的</li>
<li><code>QTimer</code>是在哪个线程？<code>QTimer</code>为什么启动和停止要在同一个线程？</li>
<li><code>qt</code>中生成线程的方式？继承<code>QThread</code>,重写<code>run</code>函数与<code>moveToThread</code>的区别？</li>
<li>进程通信，共享内存如何实现进程安全</li>
<li>线程池了解吗</li>
<li>linux 查看进程</li>
<li>linux 线程和进程的调度</li>
<li>一个线程1在读文件，主线程退出了，怎么让线程1也退出不继续读</li>
<li>为什么要用qthread管理多线程？windows自己也有回调机制？</li>
<li>线程池，申请多少个线程池，比较合适?会不会使用GPU?</li>
<li>多线程加锁，会劣化性能，请问有什么优化的手段？</li>
<li>写一个线程不安全的例子, 再把它改为线程安全</li>
<li>进程间通信方式？线程呢？</li>
<li>QT的多线程，你用了哪些技术.哪些是只有Qthread能做的，QtConcurrent办不到的.</li>
<li>如果同时有1000个访问请求，线程池只有8个线程的情况下怎么处理</li>
</ul>
<h5 id="6-Qt"><a href="#6-Qt" class="headerlink" title="6.Qt"></a>6.Qt</h5><ul>
<li>对qt有啥了解，使用qt线程池做过什么</li>
<li>QT的object类作为所有控件的基类，做了哪些工作，发挥了什么作用</li>
<li>qobject parent的用处</li>
<li>qt mfc这种框架怎么和计算机底层交互的</li>
<li>写一个用户登录界面的逻辑 要求实现多个方法的验证(用户名密码, 手机验证码, 人脸登录等) 并可以后序添加模块</li>
<li>消息循环机制 消息队列为空怎么办</li>
<li>写QT的时候尝试用过cmake吗</li>
<li>Qt内存管理机制</li>
<li>Qt如何只释放子窗口</li>
<li>Qt中一些类的构造函数中经常有一个指针参数，用过吗</li>
<li>moc元编译器元对象</li>
<li>多线程中是如何使用信号槽的</li>
<li>项目中如何维护各控件的生命周期</li>
<li>如何保证只打开一个exe.当打开了exe1的时候，如果再打开exe1第二次，会将exe1之前打开的旧窗口调出，并最大化显示.</li>
<li>QWidget和QML的区别，在渲染层面</li>
<li>GPU渲染和CPU渲染，之间的区别是什么</li>
<li>兄弟窗口，想刷新他们的重叠部分，请问流程是什么样的，刷新的顺序是什么样的</li>
<li>父子窗口间的刷新管理？兄弟窗口间的刷新管理?如何让子窗口刷新，父窗口不刷新</li>
<li>show() exec()区别</li>
<li>Qt Remote Object的序列化与反序列化</li>
<li>软件如果出现问题，如何去定位的，如何处理的?静态扫描和动态检测，有哪些方法.</li>
<li>用QT实现一个三角形的按钮，会如何实现?</li>
<li>使用QT渲染的时候，有没有遇到显卡适配的问题？</li>
<li>制作一个按钮，会躲避鼠标，鼠标一旦移动上去，按钮就会跑</li>
<li>除了用鼠标移动去控制指针以外，我们还有很多方式去控制，他都会触发mouseMove事件吗</li>
<li>鼠标指针，可以移动，除了鼠标键盘可以控制，某些触摸板/触控屏，他们触发的都是mouseEvent吗？</li>
<li>qgraphscene/ qgraphitem的填充模式，任意一个多边形，它的填充模式有哪些?</li>
<li>qgraphscene的内存开销，刷新的性能</li>
</ul>
<h5 id="7-信号槽"><a href="#7-信号槽" class="headerlink" title="7.信号槽"></a>7.信号槽</h5><ul>
<li>Qt槽函数在单线程和多线程的区别</li>
<li>信号与槽，是如何去提高它的匹配性能的，一个信号，如何高效地去找它的槽函数</li>
<li>一个线程上的对象发出signal，另一个线程上的对象响应slot，这其中会有多线程相关的问题吗</li>
</ul>
<h5 id="8-数据结构"><a href="#8-数据结构" class="headerlink" title="8.数据结构"></a>8.数据结构</h5><ul>
<li>数组的存放方式有: 链表,索引,顺序?</li>
<li>图搜索,dfs</li>
<li>B+树和B树的区别？数据库的几个隔离级别，具体如何实现的？</li>
<li>二分查找</li>
<li>大端小端判定</li>
<li>左值和右值</li>
<li>二叉树如何求深度</li>
<li>如何求第k大的元素</li>
<li>unicode和utf-8</li>
<li>数组/链表区别</li>
<li>二维数组按行、按列读取速度的差异</li>
<li>vector 动态扩容底层，扩容机制</li>
<li>两个 vector 一个放普通数据类型一个放指针，扩容有什么区别</li>
<li>malloc 和 free 如何知道释放内存具体大小</li>
<li>宏定义放在哪里</li>
<li>为什么要内存对齐</li>
<li>vector和map查找效率</li>
<li>栈溢出的产生与避免</li>
<li>内存布局，静态变量和全局变量会放在哪里</li>
<li>常用的stl容器</li>
<li>stl的map和hashmap有什么区别，效率方面</li>
<li>weak_ptr的例子，简单写一下会出现的问题并介绍下</li>
<li>unordered_map的实现和map的实现</li>
<li>vector和list的区别</li>
<li>vector删除一个元素需要注意些什么</li>
<li>左右值转换</li>
<li>双向链表和环形链表用在什么场景</li>
<li>手写自己设计的vector</li>
<li>用过哪些容器，迭代器失效？</li>
<li>.int，long long占多少字节</li>
</ul>
<h5 id="9-网络基础"><a href="#9-网络基础" class="headerlink" title="9.网络基础"></a>9.网络基础</h5><ul>
<li>ping的底层原理</li>
<li>除了ping还有什么命令可以去检测该主机网络是否正常，具体命令</li>
<li>http1.1相比1.0 http2.0相比1.x的区别</li>
<li>http和https的区别</li>
<li>一个https的url输入到浏览器到页面显示 发生了什么</li>
<li>抓过包吗 https抓包会抓到什么</li>
<li>我们用腾讯会议聊天的话，用TCP还是UDP，为什么</li>
<li>计算机网络七层</li>
<li>GET和POST</li>
<li>浏览器输入URL后会经历什么过程</li>
</ul>
<h5 id="10-其他"><a href="#10-其他" class="headerlink" title="10.其他"></a>10.其他</h5><ul>
<li>操作系统常见的文件操作函数</li>
<li>传入派生类的引用, 调用谁的成员函数</li>
<li>for ++i i++区别</li>
<li>编程：排序,奇数全放前面</li>
<li>做过的项目里哪一个是最满意的, 讲一下这个项目</li>
<li>原子操作有用过吗, 有什么作用</li>
<li>函数有几种传参方式, 哪种情况用哪种方式</li>
<li>有用过linux吗, 755权限代表什么含义</li>
<li>vector的reserve函数和resize函数有什么区别</li>
<li>什么情况下会使用静态变量</li>
<li>用过无锁编程吗，知道原子量吗</li>
<li>你知道MQTT吗？</li>
<li> Linux系统中阻塞和非阻塞的区别</li>
<li>volatile关键字的作用</li>
<li>window的消息队列</li>
<li>项目中心跳检测机制如何实现的</li>
<li>说一下C++的move构造和拷贝构造是怎么实现的</li>
<li>C++模板元编程中的 enable_if 说一下，有什么应用</li>
<li>多态是如何实现的</li>
<li>动态绑定与静态绑定说一下，哪个更高效</li>
<li>结构体和class的区别</li>
<li>程序编译过程</li>
<li>函数模板用过吗</li>
<li>wondows 消息循环</li>
<li>预防内存泄漏方式</li>
<li>了解json格式吗</li>
<li>类中的引用计数</li>
<li>Lambda表达式</li>
<li>动态链接、静态链接</li>
<li>C++面向对象的特性</li>
<li>MVC和MVVM</li>
<li>怎么保证生成的随机数是均匀分布的</li>
<li>抽奖会得到四种道具概率分别不同，该怎么实现这个程序</li>
<li>假设有几万个号码算出来他们的MD5以16进制存储，然后有一个新的号码算出来它的MD5值，现在要判断这个值在不在之前的数据当中，该怎么实现不能调用库函数</li>
<li>有没有自己重写过自定义控件</li>
<li>宏定义如何使用（直接替换），嵌套宏定义如何使用，展开顺序</li>
<li>关键字inline、类与结构的区别、explicit关键字.</li>
<li>C++的类型转换</li>
<li>一个浏览器的网页，包含前进和后退功能，使用哪种数据结构来存放历史网页，比较合适</li>
<li>windows系统下，是怎么实现窗口刷新(窗口刷新机制);是立即刷新，还是异步刷新;每次我需要一个窗口刷新，他都能立马刷新吗</li>
<li>说说windows系统的内存管理，怎么实现共享内存？操作系统层面是如何完成这个过程的</li>
<li>如何分析dump文件</li>
<li>如何排查出代码里已经存在的内存泄漏问题，线上的内存泄漏</li>
<li>class前项申明和include的区别</li>
<li>什么情况下，delete需要加一个中括号[]</li>
<li>装饰器模式/门面模式/中介者模式，他们的代码实现和优缺点</li>
<li>共享内存的流程(底层原理)</li>
<li>自己有没有实现过读写锁?</li>
<li>乐观锁和悲观锁的区别，自旋锁，是一种乐观锁吗?</li>
<li>dynamic_cast怎么保证安全的？</li>
<li>如果有一块内存，如何知道内存是被人正在使用的，还是忘记delete导致内存泄漏的?</li>
<li>堆内存分配的时候，需要找寻足够大的内存，如果没有足够大的内存怎么办</li>
<li>const成员如何进行初始化</li>
</ul>

        </div>

        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/C-%E5%8E%9F%E7%94%9F/"># C++原生</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/article/427bdb52.html">Linux下开发之动态库加载</a>
            
            
            <a class="next" rel="next" href="/article/74ffeb25.html">C++原生int和string互换</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>蒋胜达 © 
            2021 - 2025 | 
            <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<span class="site-uv">
    访客量:
    <i class="busuanzi-value" id="busuanzi_value_site_uv"></i>
</span>&nbsp;


        </span>
    </div>
</footer>

    </div>
</body>

</html>