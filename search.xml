<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>KDE全局快捷键</title>
      <link href="/article/32821987.html"/>
      <url>/article/32821987.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Linux下边做全局快捷键比较麻烦，Qt没有自带的库，Windows可以直接用Win API，但是这个理论到了Linux稍微有点问题，就是现在Linux的桌面环境分X11和Wayland，这两个桌面环境的接口不一样。如果实现其中一套另外一个环境就完全失效；如果两套都实现，Wayland因为还不是很成熟，用Wayland的原生接口来做又很麻烦。我经过一些努力后有一些阶段性的成果，就比如麒麟系统用的是KDE桌面环境，其实KDE桌面是有全局快捷键的接口的，用这个实现的话，就可以同时兼容X11/Wayland环境了。缺点就是只有KDE生效  </p><p>至于KDE是怎么兼容X11/Wayland环境的，有待后续深入研究</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>用到了KGlobalAccel库<br>.h头文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GLOBALKEY_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GLOBALKEY_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QObject&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QAction&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QKeyEvent&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;KF5/KGlobalAccel/KGlobalAccel&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GlobalKey</span> :</span> <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">GlobalKey</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">RegisterKey</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">UnregisterKey</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sigKeyTriggered</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QAction *m_pAction = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// GLOBALKEY_H</span></span></span><br></pre></td></tr></table></figure><p>.cpp实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;globalkey.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line">GlobalKey::<span class="built_in">GlobalKey</span>(QObject *parent) : QObject&#123;parent&#125;</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GlobalKey::RegisterKey</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_pAction != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="built_in">tr</span>(<span class="string">&quot;shortcut key already create&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_pAction = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="keyword">this</span>);</span><br><span class="line">    m_pAction-&gt;<span class="built_in">setText</span>(<span class="built_in">tr</span>(<span class="string">&quot;GlobalKey&quot;</span>));</span><br><span class="line">    m_pAction-&gt;<span class="built_in">setObjectName</span>(<span class="built_in">QStringLiteral</span>(<span class="string">&quot;GlobalKeyAction&quot;</span>));</span><br><span class="line">    <span class="comment">//when shortcut key had changed must restart kglobalaccel5</span></span><br><span class="line">    m_pAction-&gt;<span class="built_in">setProperty</span>(<span class="string">&quot;compoentName&quot;</span>, <span class="built_in">QStringLiteral</span>(<span class="string">&quot;KylinNoteAction&quot;</span>));</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="built_in">tr</span>(<span class="string">&quot;check has:&quot;</span>)&lt;&lt;KGlobalAccel::<span class="built_in">self</span>()-&gt;<span class="built_in">hasShortcut</span>(m_pAction);</span><br><span class="line"></span><br><span class="line">    KGlobalAccel::<span class="built_in">self</span>()-&gt;<span class="built_in">setShortcut</span>(m_pAction, QList&lt;QKeySequence&gt;&#123;Qt::META + Qt::Key_Space&#125;);</span><br><span class="line">    KGlobalAccel::<span class="built_in">self</span>()-&gt;<span class="built_in">setDefaultShortcut</span>(m_pAction, QList&lt;QKeySequence&gt;&#123;Qt::META + Qt::Key_Space&#125;);</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;key register successful.&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">connect</span>(m_pAction, &amp;QAction::triggered, <span class="keyword">this</span>, [<span class="keyword">this</span>]()&#123;</span><br><span class="line">       <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;注册的shutkey快捷键被触发&quot;</span>;</span><br><span class="line">       emit <span class="built_in">sigKeyTriggered</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GlobalKey::UnregisterKey</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_pAction == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (KGlobalAccel::<span class="built_in">self</span>()-&gt;<span class="built_in">hasShortcut</span>(m_pAction))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="built_in">tr</span>(<span class="string">&quot;ready unregister it&quot;</span>);</span><br><span class="line">        KGlobalAccel::<span class="built_in">self</span>()-&gt;<span class="built_in">removeAllShortcuts</span>(m_pAction);</span><br><span class="line">        <span class="keyword">delete</span> m_pAction;</span><br><span class="line">        m_pAction = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="built_in">tr</span>(<span class="string">&quot;can&#x27;t find..the key&quot;</span>)&lt;&lt;m_pAction-&gt;<span class="built_in">objectName</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工程动态加载库之QLibrary解耦编译</title>
      <link href="/article/9e62072f.html"/>
      <url>/article/9e62072f.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Linux下做Qt工程经常遇到需要依赖某某动态库的问题，而且这个动态库还一般不内置到工程里，都是放在什么/usr/之类的地方，如果动态库没有安装的话，不管是编译和运行都会有问题。<br>所以就要用QLibrary来做动态加载，就彻底和动态库解耦了，工程里设计到动态库相关的部分，也不会直接#include之类的，相关逻辑也会先判断动态加载有没有成功</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>这里以动态加载一个语音录入库为例：<br>头文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QObject&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QLibrary&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="comment">//speech,这些本来是库的头文件，现在不能直接引用</span></span><br><span class="line"><span class="comment">//#include &lt;kylin-ai/coreai/speech/recognizer.h&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;kylin-ai/coreai/speech/synthesizer.h&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;kylin-ai/coreai/speech/result.h&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;kylin-ai/coreai/speech/audioconfig.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这些本来是头文件里的一些定义，也要搬过来，不然库里某些接口的返回值是这些，运行会有问题</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    SPEECH_ERROR_OCCURRED = <span class="number">1</span>,</span><br><span class="line">    SPEECH_RECOGNITION_STARTED = <span class="number">2</span>,</span><br><span class="line">    SPEECH_RECOGNIZING = <span class="number">3</span>,</span><br><span class="line">    SPEECH_RECOGNIZED = <span class="number">4</span>,</span><br><span class="line">    SPEECH_RECOGNITION_COMPLETED = <span class="number">5</span>,</span><br><span class="line">    SPEECH_SYNTHESIS_STARTED = <span class="number">6</span>,</span><br><span class="line">    SPEECH_SYNTHESIZING = <span class="number">7</span>,</span><br><span class="line">    SPEECH_SYNTHESIS_COMPLETED = <span class="number">8</span>,</span><br><span class="line">&#125; SpeechResultReason;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SpeechRecognitionSession</span> <span class="title">SpeechRecognitionSession</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SpeechRecognitionResult</span> <span class="title">SpeechRecognitionResult</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SpeechSynthesisResult</span> <span class="title">SpeechSynthesisResult</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">AudioConfig</span> <span class="title">AudioConfig</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*SpeechRecognitionResultCallback)</span><span class="params">(SpeechRecognitionResult *result, <span class="keyword">void</span> *user_data)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*SpeechSynthesisResultCallback)</span><span class="params">(SpeechSynthesisResult *result, <span class="keyword">void</span> *user_data)</span></span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>* (*CreateSessionFunc)();</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*InitSessionFunc)</span><span class="params">(<span class="keyword">void</span>*)</span></span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">const</span> <span class="keyword">char</span> *(*GetTextFunc)(SpeechRecognitionResult *result);</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">SpeechResultReason</span><span class="params">(*GetReasonFunc)</span><span class="params">(SpeechRecognitionResult *result)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*SetCallbackFunc)</span><span class="params">(<span class="keyword">void</span>*, <span class="keyword">void</span>(*callback)(SpeechRecognitionResult*, <span class="keyword">void</span>*), <span class="keyword">void</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*StartRecognitionFunc)</span><span class="params">(<span class="keyword">void</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*StopRecognitionFunc)</span><span class="params">(<span class="keyword">void</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*SetAudioConfigFunc)</span><span class="params">(<span class="keyword">void</span>*, <span class="keyword">void</span>*)</span></span>;</span><br><span class="line"><span class="keyword">typedef</span> AudioConfig* (*CreateAudioConfigFunc)();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QMutex</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PUBLICDATA_EXPORT</span> <span class="title">Speech</span> :</span> <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Speech* <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">beginListening</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">endListening</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSpeechSetup</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSpeechListening</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Speech</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sigSpeechCallBack</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">warning</span><span class="params">(QString)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">loadSpeechLibrary</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">callback</span><span class="params">(SpeechRecognitionResult *result, <span class="keyword">void</span> *user_data)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> Speech* m_pSpeech;</span><br><span class="line">    <span class="keyword">static</span> QMutex mutex_m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QLibrary m_speechLibrary;</span><br><span class="line">    CreateSessionFunc speech_recognizer_create_session = <span class="literal">nullptr</span>;</span><br><span class="line">    InitSessionFunc speech_recognizer_init_session = <span class="literal">nullptr</span>;</span><br><span class="line">    SetCallbackFunc speech_recognizer_result_set_callback = <span class="literal">nullptr</span>;</span><br><span class="line">    StartRecognitionFunc speech_recognizer_start_continuous_recognition_async = <span class="literal">nullptr</span>;</span><br><span class="line">    StopRecognitionFunc speech_recognizer_stop_continuous_recognition_async = <span class="literal">nullptr</span>;</span><br><span class="line">    GetTextFunc speech_recognition_result_get_text = <span class="literal">nullptr</span>;</span><br><span class="line">    GetReasonFunc speech_recognition_result_get_reason = <span class="literal">nullptr</span>;</span><br><span class="line">    CreateAudioConfigFunc audio_config_create_continuous_audio_input_from_default_microphone = <span class="literal">nullptr</span>;</span><br><span class="line">    SetAudioConfigFunc speech_recognizer_set_audio_config = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *m_session = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> m_bSpeechSetup;</span><br><span class="line">    <span class="keyword">bool</span> m_isListening;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;speech.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QMutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QMessageBox&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDBusInterface&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDBusReply&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">Speech* Speech::m_pSpeech = <span class="literal">nullptr</span>;</span><br><span class="line">QMutex Speech::mutex_m;</span><br><span class="line"></span><br><span class="line">Speech::<span class="built_in">Speech</span>(QObject *parent) : <span class="built_in">QObject</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    m_bSpeechSetup = <span class="literal">false</span>;</span><br><span class="line">    m_isListening = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">loadSpeechLibrary</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Speech *<span class="title">Speech::getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_pSpeech == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        mutex_m.<span class="built_in">lock</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(m_pSpeech == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_pSpeech = <span class="keyword">new</span> <span class="built_in">Speech</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mutex_m.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> m_pSpeech;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Speech::isSpeechSetup</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_bSpeechSetup;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Speech::isSpeechListening</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_isListening;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Speech::loadSpeechLibrary</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_speechLibrary.<span class="built_in">setFileName</span>(<span class="string">&quot;/usr/lib/x86_64-linux-gnu/libkysdk-coreai-speech.so&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!m_speechLibrary.<span class="built_in">load</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">qWarning</span>() &lt;&lt; <span class="string">&quot;Failed to load speech library:&quot;</span> &lt;&lt; m_speechLibrary.<span class="built_in">errorString</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取函数符号</span></span><br><span class="line">    speech_recognizer_create_session = <span class="keyword">reinterpret_cast</span>&lt;CreateSessionFunc&gt;(m_speechLibrary.<span class="built_in">resolve</span>(<span class="string">&quot;speech_recognizer_create_session&quot;</span>));</span><br><span class="line">    speech_recognizer_init_session = <span class="keyword">reinterpret_cast</span>&lt;InitSessionFunc&gt;(m_speechLibrary.<span class="built_in">resolve</span>(<span class="string">&quot;speech_recognizer_init_session&quot;</span>));</span><br><span class="line">    speech_recognizer_result_set_callback = <span class="keyword">reinterpret_cast</span>&lt;SetCallbackFunc&gt;(m_speechLibrary.<span class="built_in">resolve</span>(<span class="string">&quot;speech_recognizer_result_set_callback&quot;</span>));</span><br><span class="line">    speech_recognizer_start_continuous_recognition_async = <span class="keyword">reinterpret_cast</span>&lt;StartRecognitionFunc&gt;(m_speechLibrary.<span class="built_in">resolve</span>(<span class="string">&quot;speech_recognizer_start_continuous_recognition_async&quot;</span>));</span><br><span class="line">    speech_recognizer_stop_continuous_recognition_async = <span class="keyword">reinterpret_cast</span>&lt;StopRecognitionFunc&gt;(m_speechLibrary.<span class="built_in">resolve</span>(<span class="string">&quot;speech_recognizer_stop_continuous_recognition_async&quot;</span>));</span><br><span class="line">    speech_recognizer_set_audio_config = <span class="keyword">reinterpret_cast</span>&lt;SetAudioConfigFunc&gt;(m_speechLibrary.<span class="built_in">resolve</span>(<span class="string">&quot;speech_recognizer_set_audio_config&quot;</span>));</span><br><span class="line">    speech_recognition_result_get_text = <span class="keyword">reinterpret_cast</span>&lt;GetTextFunc&gt;(m_speechLibrary.<span class="built_in">resolve</span>(<span class="string">&quot;speech_recognition_result_get_text&quot;</span>));</span><br><span class="line">    speech_recognition_result_get_reason = <span class="keyword">reinterpret_cast</span>&lt;GetReasonFunc&gt;(m_speechLibrary.<span class="built_in">resolve</span>(<span class="string">&quot;speech_recognition_result_get_reason&quot;</span>));</span><br><span class="line">    audio_config_create_continuous_audio_input_from_default_microphone = <span class="keyword">reinterpret_cast</span>&lt;CreateAudioConfigFunc&gt;(m_speechLibrary.<span class="built_in">resolve</span>(<span class="string">&quot;audio_config_create_continuous_audio_input_from_default_microphone&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!speech_recognizer_create_session || !speech_recognizer_init_session || !speech_recognition_result_get_text ||</span><br><span class="line">        !speech_recognizer_result_set_callback || !speech_recognizer_start_continuous_recognition_async ||</span><br><span class="line">        !speech_recognizer_stop_continuous_recognition_async || !speech_recognizer_set_audio_config)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">qWarning</span>() &lt;&lt; <span class="string">&quot;Failed to resolve one or more speech library symbols&quot;</span>;</span><br><span class="line">        m_speechLibrary.<span class="built_in">unload</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Speech::beginListening</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_isListening = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!speech_recognizer_create_session || !speech_recognizer_init_session ||</span><br><span class="line">        !speech_recognizer_result_set_callback || !speech_recognizer_start_continuous_recognition_async ||</span><br><span class="line">        !speech_recognizer_set_audio_config)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">qWarning</span>() &lt;&lt; <span class="string">&quot;Speech library functions not loaded&quot;</span>;</span><br><span class="line">        m_isListening = <span class="literal">false</span>;</span><br><span class="line">        <span class="function">emit <span class="title">warning</span><span class="params">(tr(<span class="string">&quot;Voice-to-text is currently unavailable.&quot;</span>))</span></span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_session = <span class="built_in">speech_recognizer_create_session</span>();</span><br><span class="line">    <span class="keyword">int</span> result = <span class="built_in">speech_recognizer_init_session</span>(m_session);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;result&quot;</span> &lt;&lt; result;</span><br><span class="line">    <span class="keyword">if</span>(result == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_isListening = <span class="literal">false</span>;</span><br><span class="line">        <span class="function">emit <span class="title">warning</span><span class="params">(tr(<span class="string">&quot;The network is abnormal. Check whether the system is connected to the network&quot;</span>))</span></span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="number">0</span> &amp;&amp; result != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_isListening = <span class="literal">false</span>;</span><br><span class="line">        <span class="function">emit <span class="title">warning</span><span class="params">(tr(<span class="string">&quot;Voice-to-text is currently unavailable.&quot;</span>))</span></span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">speech_recognizer_result_set_callback</span>(m_session, callback, <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">auto</span> *config = <span class="built_in">audio_config_create_continuous_audio_input_from_default_microphone</span>();</span><br><span class="line">    <span class="built_in">speech_recognizer_set_audio_config</span>(m_session, config);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">speech_recognizer_start_continuous_recognition_async</span>(m_session);</span><br><span class="line">    GMainLoop *pMainLoop = <span class="built_in">g_main_loop_new</span>(<span class="literal">nullptr</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">g_main_loop_run</span>(pMainLoop);</span><br><span class="line">    <span class="built_in">g_main_loop_unref</span>(pMainLoop);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Speech::endListening</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(speech_recognizer_stop_continuous_recognition_async)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">speech_recognizer_stop_continuous_recognition_async</span>(m_session);</span><br><span class="line">        m_isListening = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Speech::callback</span><span class="params">(SpeechRecognitionResult *result, <span class="keyword">void</span> *user_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Speech *self = <span class="keyword">static_cast</span>&lt;Speech*&gt;(user_data);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;************************************&quot;</span> &lt;&lt; self-&gt;<span class="built_in">speech_recognition_result_get_text</span>(result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(self-&gt;<span class="built_in">speech_recognition_result_get_reason</span>(result) == SPEECH_RECOGNIZED)<span class="comment">//这个是正在进行语音修正后的结果</span></span><br><span class="line">    &#123;</span><br><span class="line">        self-&gt;<span class="built_in">sigSpeechCallBack</span>(self-&gt;<span class="built_in">speech_recognition_result_get_text</span>(result));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024年总结</title>
      <link href="/article/795668d8.html"/>
      <url>/article/795668d8.html</url>
      
        <content type="html"><![CDATA[<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>24年的这篇总结写的比之前的都要早，现在是6月5日，就已经开始起笔了，先写写上半年发生的事吧  </p><p>首先是谈判成功了，拿到了n+1和年终，其次是，我的leader也被裁了；裁了之后就是过年了，因为之前老早就定好了去成都重庆的旅游，所以回去了在见了双方父母爷爷奶奶姥姥姥爷之后，初二就坐飞机去成都了，然后去的重庆，值得一提的是成都的巴蜀大宅门没有想象的那么好吃了，可能过去的几年一直在心里神话它的味道，实际吃到还是跟心里的神话有点落差的，再有就是重庆的白象居好玩，嗯，把玥玥吓得够呛hh  </p><p>旅游回来之后差不多2月底，就开始搬家了，从之前的小区搬到了隔壁小区，租金没怎么变，但变成了复式，家具也全都是实木的，比之前跟仓库一样的小屋强多了，两个人兴奋的布置了好多东西，现在的布局合理多了  </p><p>后来因为玥玥的23年假快到期了，两个人又去了深圳，香港和澳门，印象很深（深圳除外），香港给玥玥拍了很多好看的照片，确实感觉跟内地很不一样；澳门也很好玩，还吃到了一家超级好吃的牛杂面  </p><p>回来之后就是3月底了，想着开始复习准备找工作了，但总感觉时间还早，有种拖延的感觉，感觉还没怎么调整过来，就到了4月初清明节了，因为放假时间的特殊，玥玥问我还想不想出去玩，我其实一方面确实是很喜欢出去旅游长见识，另一方面有种失落感在，自从失业后，整个人感觉跟社会脱节了，而且每天看着媳妇上下班处理各种事情，就感觉自己没有参与感，所以商量好后媳妇又请了3天年假，两个人花了6天时间去了昆明、大理、丽江和香格里拉，看了很多的景，吃了好多之前没吃过的好吃的，确实是玩的最尽兴的一次  </p><p>回来之后，就快到4月中了，接下来一直到5月底，就是每天各种复杂的情绪搀和在一起，有时候觉得真的不想找工作，歇到这个时候了打心底里是厌恶上班的，觉得上班很没有意义；有时候觉得都4月下半旬了，金三银四，再不找就完蛋了，又开始恐慌；有时候又感到深深的失落，觉得自己能力明明没有问题，前三年表现的很好，为什么就把我给裁了，为什么会轮到我，然后又想leader也被裁了，又想大家本来在嘉华的时候都开开心心的，怎么突然就都散了呢；又觉得自己好没用，意识到原来挣钱这么难，之前一路工作过来太顺了，觉得每个月拿上万的工资是理所应当的，失业之后才发现原来有那么多人，挣钱是那么困难；开始反思以后自己的路怎么办，现在不用担心，到了35了再失业了，还能干什么呢，是去卖烤肠，还是跑滴滴，跑滴滴也没京牌；大白天的走出去就会想会不会有异样的眼光在看我，年轻的小伙子大白天闲逛，每当这个时候就会想到终于知道什么叫无业游民了；中午下午出去转，发现街上没几个人，感觉自己跟社会脱节了一样，心在想这个时候大家都在上班吗···</p><p>后来没憋住找了同样被裁的前同事，问了问他的情况，心里状况也没比我好到哪里去， 那还能怎么办呢，投简历吧，刷题吧，准备知识点吧  </p><p>熬到5月中的时候，感觉焦虑到了巅峰，之前大大小小能投的几十分简历全投出去了，要么石沉大海，要么一面二面没过，感到深深的绝望；跟媳妇讨论这些事的时候，她有说到，如果我一直到年底都找不到工作，可能两个人就留不到北京了 （而我们这个刚新建的小家庭，因为我的后腿，就要走下坡路了，没说，自己领会的），两个人就这个事发生了争吵，一方面我是在想她怎么能这么说，另一方面我觉得说的是事实，只是由她说出来了  </p><p>到5月底的时候，不知道为什么情况突然好起来了，先后广联达和麒麟软件找我面试，广联达是去线下，我有点紧张，就在仅有的一天时间里把之前面试过的所有问题答案都准备了一份，一遍一遍的背，背完了发现原来这些所谓的底层原理也就那样，只是我之前一直浮躁看不进去，最后先是GLD二面全通过，但是被一个履历比我好的顶下去了；然后QL面试官对我评价挺高，当天就到了谈薪资的阶段了，而且给的挺高（行业不算高，比我心理预期高），接下来就是乖乖等offer了   </p><p>到6月3号，我就来报道了，结束了前半年坎坷的经历。目前入职了3天，还没有什么特别的感觉，希望下半年顺利些吧！接下来马上就要端午节，两个人定了机票去长沙玩，希望能玩的开心，也希望下半年的我能把下半年写的好一些  </p><p>端午节，两个人去长沙玩了，湘菜没有想象中的那么好吃，很多地方也没有想象的好玩，但两个人出来玩总归是比闷在家里好的；7月初，两个人去了大同，看了云冈石窟，悬空寺，华严寺，应县木塔，这次是真真的看到古迹了，而不是那种翻修的新东西愣说是老的，给了我俩很大的震撼，大同的东西也都很好吃，感觉很棒  </p><p>接下来写的就是在25年1月5号了，后边就是很顺利的转正了，出乎意料的被重视，而且专业能力受到了认可。而且还当上了小组长，虽然就管俩人，但都是之前完全没有料到的</p><p>11月份又长沙出了趟差，呆了两周吃了不少湘菜。回来后基本就是日常的上下班干活了，所以没有特别值得记录的事情</p><h3 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h3><p>感觉真的是起伏特别大的一年，经历了很多很多。前快30年都没有今年旅游的次数多。而且经历了年初的裁员后，我的心态也发生了一些变化，时常会有一种被抛弃的感觉，对待公司这个主体也没有那么的“感觉公司和我是一体”了。而且对加班现在的态度就是能不加就不加，加了也没用，到时候还是被裁；对公司本身发展的一些事情也不太关心和重视了，现在就是我每天上班、好好干活、下班、发工资，就齐活了，其他的我也不关心。当然最后还是要感谢我的夫人，在我裁员期间，和工作期间，一如既往的给我巨大的情感支持，没有让我感觉到被嫌弃，被社会抛弃。</p><p>最后就是，感觉人生的容错真的很大，工作在整个人生中，其实不管是意义还是重要性都没有想象的那么高。旅游时候看到人多种多样的人生，原来大家在同一片土地和时间可以这样的活着。现在的心态总结来就是不喜不悲，心怀满足。希望25年事业能更进一步吧，更重要的是我跟我的夫人能够开开心心的把日子过好，感觉其他的也都不太重要了。</p>]]></content>
      
      
      <categories>
          
          <category> 感悟 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 年度总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下开发之动态库加载</title>
      <link href="/article/427bdb52.html"/>
      <url>/article/427bdb52.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在Linux下进行Qt开发时，习惯性的分了几个模块（1个主工程，3个共享动态库），编译通过了但运行时遇到了问题，虽然二进制可执行文件和动态库在同一目录下，但是就是提示找不到对应的动态库，在一番尝试后，需要用rpath来执行最高优先搜索动态库的路径就行</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">QT += widgets core gui</span><br><span class="line"></span><br><span class="line">TEMPLATE = app</span><br><span class="line">CONFIG += c++<span class="number">17</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">CONFIG</span>(release, debug|release): &#123;</span><br><span class="line">    DESTDIR = $$PWD/../Bin/Release</span><br><span class="line">    LIBS += $$PWD/../Bin/Release/libUIElement.so</span><br><span class="line">    LIBS += $$PWD/../Bin/Release/libPublicData.so</span><br><span class="line">    LIBS += $$PWD/../Bin/Release/libAIModule.so</span><br><span class="line">&#125; <span class="keyword">else</span>: <span class="built_in">CONFIG</span>(debug, debug|release): &#123;</span><br><span class="line">    DESTDIR = $$PWD/../Bin/Debug</span><br><span class="line">    LIBS += $$PWD/../Bin/Debug/libUIElement.so</span><br><span class="line">    LIBS += $$PWD/../Bin/Debug/libPublicData.so</span><br><span class="line">    LIBS += $$PWD/../Bin/Debug/libAIModule.so</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#这句一定要放在上边逻辑的后边，因为上边重新指定了DESTDIR的路径</span><br><span class="line">QMAKE_RPATHDIR += $$DESTDIR</span><br><span class="line"></span><br><span class="line">HEADERS = \</span><br><span class="line">    mainwindow.h \</span><br><span class="line"></span><br><span class="line">SOURCES = \</span><br><span class="line">    main.cpp \</span><br><span class="line">    mainwindow.cpp</span><br><span class="line"></span><br><span class="line">RESOURCES += textedit.qrc</span><br><span class="line"></span><br><span class="line">FORMS += \</span><br><span class="line">    finddialog.ui</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024.05社招面经</title>
      <link href="/article/9a4ee461.html"/>
      <url>/article/9a4ee461.html</url>
      
        <content type="html"><![CDATA[<h2 id="全部都是实际面试中被问到的"><a href="#全部都是实际面试中被问到的" class="headerlink" title="全部都是实际面试中被问到的"></a>全部都是实际面试中被问到的</h2><h3 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h3><h4 id="智能指针的几种类型，分别的作用和场景"><a href="#智能指针的几种类型，分别的作用和场景" class="headerlink" title="智能指针的几种类型，分别的作用和场景"></a>智能指针的几种类型，分别的作用和场景</h4><p>类型：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">C++中的智能指针主要是为了解决原始指针可能导致的内存泄漏和悬挂指针问题，通过封装和自动管理动态分配的内存来提高代码的安全性和可靠性。以下是几种常见的智能指针类型及其作用：</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 1.std::unique<span class="emphasis">_ptr:</span></span><br><span class="line"><span class="emphasis">作用: 提供独占所有权的智能指针。一个unique_</span>ptr实例在任何时候都拥有它所指向对象的唯一所有权，并且在其生命周期结束时自动删除所指向的对象。这确保了资源的唯一性和自动清理，防止了资源的重复释放。</span><br><span class="line"><span class="code">    </span></span><br><span class="line"><span class="code">- 2.std::shared_ptr:</span></span><br><span class="line"><span class="code">作用: 实现共享所有权的智能指针。允许多个shared_ptr实例共享同一个对象的所有权。通过引用计数机制管理对象的生命周期，当最后一个指向对象的shared_ptr销毁时，对象会被自动删除。适合于多个对象或作用域需要共享资源的场景。</span></span><br><span class="line"><span class="code">    </span></span><br><span class="line"><span class="code">- 3.std::weak_ptr:</span></span><br><span class="line"><span class="code">作用: 是一种非拥有型的智能指针，用于解决shared_ptr循环引用的问题。weak_ptr可以观察但不增加它所指向对象的引用计数。通常与shared_ptr配合使用，当需要访问一个对象但又不想影响其生命周期时非常有用。</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>场景：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//unique_ptr: 想象一下你正在编写一个简单的游戏，游戏中每个玩家都有一个独一无二的武器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Weapon</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Weapon</span>(<span class="keyword">const</span> std::string&amp; name) : <span class="built_in">name_</span>(name) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Weapon</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Weapon &quot;</span> &lt;&lt; name_ &lt;&lt; <span class="string">&quot; is destroyed.&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">use</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Firing &quot;</span> &lt;&lt; name_ &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Player</span>(std::unique_ptr&lt;Weapon&gt; weapon) : <span class="built_in">weapon_</span>(std::<span class="built_in">move</span>(weapon)) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">attack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( ) &#123;</span><br><span class="line">            weapon_-&gt;<span class="built_in">use</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;No weapon to use!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unique_ptr&lt;Weapon&gt; weapon_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> sword = std::make_unique&lt;Weapon&gt;(<span class="string">&quot;Sword of Darkness&quot;</span>);</span><br><span class="line">    <span class="function">Player <span class="title">player</span><span class="params">(std::move(sword))</span></span>; <span class="comment">// 将剑的所有权转移给玩家</span></span><br><span class="line">    player.<span class="built_in">attack</span>(); <span class="comment">// 使用剑攻击</span></span><br><span class="line">    <span class="comment">// 此时sword已经无效，剑的生命周期完全由Player管理</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在这个例子中，每个玩家通过 unique_ptr 拥有一把独特的武器。当玩家对象被销毁时，其所拥有的武器也会自动被销毁，实现了资源的自动管理。</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//shared_ptr: 考虑一个文档编辑软件，其中多个标签页可以打开并共享同一个文档。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Document</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Document</span>(<span class="keyword">const</span> std::string&amp; title) : <span class="built_in">title_</span>(title) &#123; std::cout &lt;&lt; <span class="string">&quot;Document &quot;</span> &lt;&lt; title_ &lt;&lt; <span class="string">&quot; created.&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    ~<span class="built_in">Document</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Document &quot;</span> &lt;&lt; title_ &lt;&lt; <span class="string">&quot; closed.&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string title_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tab</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Tab</span>(std::shared_ptr&lt;Document&gt; doc) : <span class="built_in">document_</span>(doc) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;Document&gt; document_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> doc = std::make_shared&lt;Document&gt;(<span class="string">&quot;My Important Document&quot;</span>); <span class="comment">// 创建一个文档</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">Tab <span class="title">tab1</span><span class="params">(doc)</span></span>; <span class="comment">// 新建一个标签页，共享文档</span></span><br><span class="line">        <span class="function">Tab <span class="title">tab2</span><span class="params">(doc)</span></span>; <span class="comment">// 再新建一个标签页，同样共享文档</span></span><br><span class="line">        <span class="comment">// 当tab1和tab2离开作用域时，它们不会删除文档，因为文档还在被共享</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当所有标签页关闭且没有其他共享者时，文档才会被自动销毁</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在这个场景中，多个 Tab（标签页）对象通过 shared_ptr 共享同一个 Document（文档）对象。只有当所有引用该文档的标签页都被关闭（即没有更多的 shared_ptr 引用它）时，文档才会被自动删除，确保了资源的有效共享和管理。</span></span><br></pre></td></tr></table></figure><h4 id="智能指针的常用接口"><a href="#智能指针的常用接口" class="headerlink" title="智能指针的常用接口"></a>智能指针的常用接口</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">`unique_ptr`</span> 和 <span class="code">`shared_ptr`</span> 是 C++ 中两种常用的智能指针，它们都用于自动管理动态分配的内存，但各自有不同的特性和接口设计来满足不同的使用场景。</span><br><span class="line"></span><br><span class="line">unique<span class="emphasis">_ptr 常用接口</span></span><br><span class="line"><span class="emphasis">1. 构造和析构</span></span><br><span class="line"><span class="emphasis">   - `unique_</span>ptr<span class="xml"><span class="tag">&lt;<span class="name">T</span>&gt;</span></span>`：默认构造函数，创建一个不持有任何对象的 unique<span class="emphasis">_ptr。</span></span><br><span class="line"><span class="emphasis">   - `unique_</span>ptr<span class="xml"><span class="tag">&lt;<span class="name">T</span>&gt;</span></span>(new T(args...))`：直接在构造时分配并持有对象。</span><br><span class="line"><span class="bullet">   -</span> 析构函数：自动删除所持有的对象。</span><br><span class="line"><span class="bullet">2.</span> 移动语义</span><br><span class="line"><span class="bullet">   -</span> <span class="code">`unique_ptr&lt;T&gt;(unique_ptr&lt;T&gt;&amp;&amp;)`</span>：移动构造函数，将另一个 unique<span class="emphasis">_ptr 的资源转移给自己。</span></span><br><span class="line"><span class="emphasis">   - `unique_</span>ptr&amp; operator=(unique<span class="emphasis">_ptr<span class="xml"><span class="tag">&lt;<span class="name">T</span>&gt;</span></span>&amp;&amp;)`：移动赋值运算符，类似移动构造，转移资源并清空右值。</span></span><br><span class="line"><span class="emphasis">3. 获取原始指针</span></span><br><span class="line"><span class="emphasis">   - `T* get() const noexcept`：返回所指向的对象的原始指针。</span></span><br><span class="line"><span class="emphasis">4. 释放所有权</span></span><br><span class="line"><span class="emphasis">   - `T* release()`：释放所有权但不删除对象，返回原始指针。</span></span><br><span class="line"><span class="emphasis">   - `void reset(T* ptr = nullptr)`：释放当前持有的对象（如果有的话），并可选地持有新对象的指针。</span></span><br><span class="line"><span class="emphasis">5. 自定义删除器</span></span><br><span class="line"><span class="emphasis">   - `template <span class="xml"><span class="tag">&lt;<span class="name">class</span> <span class="attr">D</span>&gt;</span></span> unique_</span>ptr<span class="xml">&lt;T, D&gt;</span>(T<span class="emphasis">* ptr, D deleter)`：构造函数，使用自定义删除器。</span></span><br><span class="line"><span class="emphasis">   - `template <span class="xml"><span class="tag">&lt;<span class="name">class</span> <span class="attr">D</span>&gt;</span></span> void reset(T*</span> ptr, D deleter)`：重置智能指针并设置新的删除器。</span><br><span class="line"></span><br><span class="line">shared<span class="emphasis">_ptr 常用接口</span></span><br><span class="line"><span class="emphasis">1. 构造和析构</span></span><br><span class="line"><span class="emphasis">   - 与 `unique_</span>ptr` 类似，但 shared<span class="emphasis">_ptr 还支持拷贝构造和赋值，因为它是共享所有权的。</span></span><br><span class="line"><span class="emphasis">2. 拷贝和赋值</span></span><br><span class="line"><span class="emphasis">   - `shared_</span>ptr(const shared<span class="emphasis">_ptr<span class="xml"><span class="tag">&lt;<span class="name">T</span>&gt;</span></span>&amp;)`：拷贝构造函数，共享同一个控制块和对象。</span></span><br><span class="line"><span class="emphasis">   - `shared_</span>ptr&amp; operator=(const shared<span class="emphasis">_ptr<span class="xml"><span class="tag">&lt;<span class="name">T</span>&gt;</span></span>&amp;)`：拷贝赋值运算符，同样共享控制块和对象。</span></span><br><span class="line"><span class="emphasis">3. 引用计数</span></span><br><span class="line"><span class="emphasis">   - 无直接操作引用计数的接口，但可以通过 `use_</span>count()` 查询当前引用计数。</span><br><span class="line"><span class="bullet">   -</span> <span class="code">`long use_count() const noexcept`</span>：返回当前引用计数。</span><br><span class="line"><span class="bullet">4.</span> 获取原始指针</span><br><span class="line"><span class="bullet">   -</span> <span class="code">`T* get() const noexcept`</span>：同 <span class="code">`unique_ptr`</span>。</span><br><span class="line"><span class="bullet">5.</span> 释放所有权</span><br><span class="line"><span class="bullet">   -</span> 无需手动释放，当引用计数降至0时，自动删除对象。</span><br><span class="line"><span class="bullet">6.</span> 自定义删除器</span><br><span class="line"><span class="bullet">   -</span> 构造函数和 <span class="code">`reset()`</span> 方法同样支持传递自定义删除器。</span><br><span class="line"><span class="bullet">7.</span> 其他</span><br><span class="line"><span class="bullet">   -</span> <span class="code">`bool unique() const noexcept`</span>：检查是否只有一个 shared<span class="emphasis">_ptr 实例指向对象。</span></span><br><span class="line"><span class="emphasis">   - `void swap(shared_</span>ptr<span class="xml"><span class="tag">&lt;<span class="name">T</span>&gt;</span></span>&amp; other) noexcept`：交换两个 shared<span class="emphasis">_ptr 的资源。</span></span><br></pre></td></tr></table></figure><h4 id="shared-ptr内部的引用计数，怎么实现的"><a href="#shared-ptr内部的引用计数，怎么实现的" class="headerlink" title="shared_ptr内部的引用计数，怎么实现的"></a>shared_ptr内部的引用计数，怎么实现的</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">`shared_ptr`</span> 的内部引用计数机制是通过一个称为“控制块”（control block）的数据结构来实现的，这个控制块通常包含以下几个关键部分：</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 引用计数器（Reference Count）：记录当前有多少个 <span class="code">`shared_ptr`</span> 实例共享同一个对象。当创建一个新的 <span class="code">`shared_ptr`</span> 实例或者拷贝现有的 <span class="code">`shared_ptr`</span> 时，引用计数会递增；当一个 <span class="code">`shared_ptr`</span> 实例被销毁或者被重置时，引用计数会递减。</span><br><span class="line"><span class="bullet">2.</span> 弱引用计数器（Weak Reference Count）：专门用于跟踪 <span class="code">`weak_ptr`</span> 实例，与 <span class="code">`shared_ptr`</span> 的引用计数独立。这个计数不影响对象的生命周期，但可以用来判断对象是否已经被销毁。</span><br><span class="line"><span class="bullet">3.</span> 对象指针：指向被管理的实际对象的指针。</span><br><span class="line"><span class="bullet">4.</span> 自定义删除器（可选）：存储用户提供的删除器，用于在对象不再被任何 <span class="code">`shared_ptr`</span> 引用时正确地释放对象资源。</span><br><span class="line"></span><br><span class="line"><span class="code">`shared_ptr`</span> 内部的引用计数通常是线程安全的，这意味着即使是多线程环境下，对引用计数的修改也是原子操作，防止了数据竞争和一致性问题。这通常通过使用原子操作（如 <span class="code">`std::atomic`</span>）来保证。</span><br><span class="line"></span><br><span class="line">实现细节上，<span class="code">`shared_ptr`</span> 类中通常会有一个指向控制块的指针（有时称为 <span class="code">`_M_refcount`</span> 或 <span class="code">`_internal`</span> 等），这个指针在 <span class="code">`shared_ptr`</span> 构造时被初始化。每次创建新的 <span class="code">`shared_ptr`</span> 实例或拷贝时，控制块中的引用计数器会通过原子加操作递增。相应的，当 <span class="code">`shared_ptr`</span> 实例被销毁或其 <span class="code">`reset`</span> 方法被调用时，引用计数器会通过原子减操作递减。当引用计数降为零时，控制块会负责调用删除器来释放对象资源，并最终自我销毁。</span><br><span class="line"></span><br><span class="line">此外，为了效率考虑，<span class="code">`shared_ptr`</span> 和控制块的实现可能还会利用小型对象优化（Small Object Optimization, SSO）策略，尝试将小型对象直接嵌入控制块中，以减少内存分配和间接寻址的开销。但这一点依赖于具体实现和编译器。</span><br></pre></td></tr></table></figure><h4 id="shared-ptr：我拿一个裸指针指向这个对像，其他已经指向这个对象的共享指针能知道吗"><a href="#shared-ptr：我拿一个裸指针指向这个对像，其他已经指向这个对象的共享指针能知道吗" class="headerlink" title="shared_ptr：我拿一个裸指针指向这个对像，其他已经指向这个对象的共享指针能知道吗"></a>shared_ptr：我拿一个裸指针指向这个对像，其他已经指向这个对象的共享指针能知道吗</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">当你使用裸指针指向一个由 <span class="code">`shared_ptr`</span> 管理的对象时，这个裸指针操作本身并不会直接影响到原有的 <span class="code">`shared_ptr`</span> 对象。换句话说，通过裸指针访问该对象，并不会让 <span class="code">`shared_ptr`</span> 自动感知到这一行为，也不会改变 <span class="code">`shared_ptr`</span> 内部的引用计数。</span><br><span class="line"></span><br><span class="line"><span class="code">`shared_ptr`</span> 通过其内部的引用计数来跟踪对该对象的所有权共享情况，但这个机制仅限于那些通过 <span class="code">`shared_ptr`</span> 实例进行的管理。直接使用裸指针访问对象，绕过了 <span class="code">`shared_ptr`</span> 的管理机制，因此：</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 裸指针无法增加或减少 <span class="code">`shared_ptr`</span> 的引用计数。</span><br><span class="line"><span class="bullet">-</span> 其他已经指向该对象的 <span class="code">`shared_ptr`</span> 不会知道有裸指针正在访问或修改该对象。</span><br><span class="line"><span class="bullet">-</span> 如果所有 <span class="code">`shared_ptr`</span> 实例因为生命周期结束或被重置而导致引用计数归零，即使还有裸指针指向该对象，该对象也会被自动释放，这可能导致裸指针成为悬挂指针（dangling pointer）。</span><br><span class="line"></span><br><span class="line">因此，尽管可以直接使用裸指针访问 <span class="code">`shared_ptr`</span> 管理的对象，这种做法并不推荐，因为它可能导致内存管理混乱和未定义行为。如果需要共享访问，应当继续使用 <span class="code">`shared_ptr`</span> 或在必要时使用 <span class="code">`weak_ptr`</span>，以维持对象生命周期的正确管理。</span><br></pre></td></tr></table></figure><h4 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">指针和引用是C++中两种重要的概念，它们都允许你间接访问内存中的数据，但它们之间存在一些根本性的差异：</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 定义和初始化：</span><br><span class="line"><span class="bullet">   -</span> 指针：指针是一个变量，其存储的是另一个变量的地址。指针可以在定义时初始化也可以不初始化，但不初始化的指针可能指向任意位置，使用时容易引发错误。如果指针指向<span class="code">`nullptr`</span>（或早期的实现中的<span class="code">`NULL`</span>），则表示它不指向任何对象。</span><br><span class="line"><span class="bullet">   -</span> 引用：引用实质上是一个已存在对象的别名，必须在定义时初始化，并且一旦初始化后就不能改变引用的对象。引用没有空值，总是必须关联到一个有效的对象。</span><br><span class="line"><span class="bullet">2.</span> 可变性：</span><br><span class="line"><span class="bullet">   -</span> 指针：指针本身可以改变，使其指向另一个对象的地址。也就是说，指针可以在其生命周期内指向不同的对象。</span><br><span class="line"><span class="bullet">   -</span> 引用：一旦引用被初始化为一个对象，它就不能被重新绑定到另一个对象。引用始终指向同一个对象。</span><br><span class="line"><span class="bullet">3.</span> 空值：</span><br><span class="line"><span class="bullet">   -</span> 指针：可以指向<span class="code">`nullptr`</span>，表示不指向任何有效对象。</span><br><span class="line"><span class="bullet">   -</span> 引用：总是必须关联到一个有效的对象，不能为<span class="code">`nullptr`</span>。</span><br><span class="line"><span class="bullet">4.</span> 内存占用：</span><br><span class="line"><span class="bullet">   -</span> 指针：指针有自己的内存空间，存储的是地址，其大小是固定的（通常是机器字长，例如在32位系统上是4字节，在64位系统上是8字节）。</span><br><span class="line"><span class="bullet">   -</span> 引用：严格意义上讲，引用本身不占用额外的内存空间，它更像是一个对象的另一个名字。但实际上，编译器可能会为引用实现内部的指针机制，但这对外部是透明的。</span><br><span class="line"><span class="bullet">5.</span> 使用便捷性：</span><br><span class="line"><span class="bullet">   -</span> 指针：访问指针所指对象的值时，需要解引用操作（如<span class="code">`*ptr`</span>）。</span><br><span class="line"><span class="bullet">   -</span> 引用：使用引用就像直接使用原始变量一样，不需要解引用，更直观易用。</span><br><span class="line"><span class="bullet">6.</span> 安全性：</span><br><span class="line"><span class="bullet">   -</span> 指针：由于指针可以为空，且可以随意改变，使用不当可能导致野指针、悬挂指针等问题，增加了程序出错的风险。</span><br><span class="line"><span class="bullet">   -</span> 引用：由于引用必须初始化且不能改变绑定，因此使用起来相对安全。</span><br><span class="line"></span><br><span class="line">综上，引用提供了一种更安全且易于使用的间接访问方式，而指针则提供了更底层、更灵活的内存操作能力，但也伴随着更高的风险。在选择使用指针还是引用时，应根据具体需求和上下文来决定。</span><br></pre></td></tr></table></figure><h4 id="为什么要用指针，用static变量-普通成员变量可以吗"><a href="#为什么要用指针，用static变量-普通成员变量可以吗" class="headerlink" title="为什么要用指针，用static变量/普通成员变量可以吗"></a>为什么要用指针，用static变量/普通成员变量可以吗</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">指针之所以在C++中被广泛使用，是因为它们提供了一些独特的能力，是静态变量（static variables）和普通成员变量所不具备的。以下是使用指针的一些主要原因：</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 动态内存分配：指针允许在程序运行时动态地分配和释放内存，这对于不确定所需内存大小或需要在程序运行过程中调整内存使用的情况非常有用。静态变量和普通成员变量的内存是在编译时或对象构造时分配的，大小固定且生命周期受限。</span><br><span class="line"><span class="bullet">2.</span> 灵活性和间接访问：通过指针，你可以改变所指向的对象，这为数据结构（如链表、树、图等）的实现提供了灵活性。静态变量和普通成员变量的地址是固定的，不能重新指向其他对象。</span><br><span class="line"><span class="bullet">3.</span> 函数间传递大型对象：传递指针或引用比复制整个对象更为高效，特别是当对象很大或复制成本较高时。静态变量不属于任何特定对象实例，而普通成员变量的传递通常意味着对象本身的传递或引用传递。</span><br><span class="line"><span class="bullet">4.</span> 实现多态：通过指向基类的指针或引用，可以指向派生类对象，这是实现多态的基础。这种方法允许编写通用代码，提高了代码的可重用性和灵活性。静态变量和普通成员变量不直接支持这种动态类型的行为。</span><br><span class="line"><span class="bullet">5.</span> 资源共享：多个指针可以指向同一块内存，允许不同部分的代码共享数据，而不必担心数据的独立副本问题。静态变量虽然也能实现某种程度上的共享，但它的作用域和生命周期限制了共享的方式。</span><br><span class="line"><span class="bullet">6.</span> 内存管理和控制：指针提供了直接操作内存的能力，比如通过指针算术可以遍历数组或在连续内存块中移动。这在某些底层编程和系统编程任务中至关重要，而静态变量和普通成员变量不提供这样的底层访问能力。</span><br><span class="line"></span><br><span class="line">虽然静态变量和普通成员变量在某些情况下足够使用，但指针提供了额外的灵活性和功能，使得C++能够支持更复杂的程序设计模式和系统级编程。在决定使用指针之前，应该权衡其带来的灵活性和潜在的安全风险。</span><br></pre></td></tr></table></figure><h4 id="父类和派生类的构造顺序"><a href="#父类和派生类的构造顺序" class="headerlink" title="父类和派生类的构造顺序"></a>父类和派生类的构造顺序</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">在C++中，当创建一个派生类对象时，构造函数的调用顺序遵循以下规则：</span><br><span class="line"></span><br><span class="line">1.基类（父类）构造函数：首先，会调用基类的构造函数。调用哪个基类的构造函数取决于派生类构造函数的初始化列表中是如何指定的。如果没有显式指定，将会调用基类的默认构造函数（如果有的话）。如果有多个基类，那么这些基类的构造函数将按照它们在派生类继承列表中声明的顺序被调用。</span><br><span class="line"></span><br><span class="line">2.成员变量：接下来，派生类自身的非静态成员变量将按照它们在类定义中的声明顺序依次被构造。</span><br><span class="line"></span><br><span class="line">3.派生类构造函数：最后，派生类自己的构造函数体被执行。</span><br><span class="line"></span><br><span class="line">这个过程确保了当派生类的构造函数开始执行时，基类的成员已经完全初始化，派生类可以安全地访问这些成员（如果访问权限允许的话）。</span><br></pre></td></tr></table></figure><h4 id="构造函数和析构函数能是虚函数吗，如果反着来会有什么问题"><a href="#构造函数和析构函数能是虚函数吗，如果反着来会有什么问题" class="headerlink" title="构造函数和析构函数能是虚函数吗，如果反着来会有什么问题"></a>构造函数和析构函数能是虚函数吗，如果反着来会有什么问题</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">在C++中，构造函数不能是虚函数，而析构函数可以是虚函数，但不是必须的。</span><br><span class="line"></span><br><span class="line"><span class="section">### 构造函数为什么不能是虚函数？</span></span><br><span class="line"><span class="bullet">1.</span> 构造时机：虚函数的调用是基于对象的实际类型，这要求对象已经完全构造完成，包括其虚函数表的建立。但在构造函数执行过程中，对象还处于构建阶段，其类型信息可能尚未完全确定，尤其是涉及到多态时。因此，构造期间无法确定应该调用哪个派生类的虚函数实现。</span><br><span class="line"><span class="bullet">2.</span> 构造目的：构造函数的主要目的是初始化对象，包括基类和派生类的数据成员。虚函数机制是为了实现多态，而构造时还未到达使用多态的阶段，更多的是关注对象状态的正确建立。</span><br><span class="line"></span><br><span class="line"><span class="section">### 析构函数可以是虚函数吗？</span></span><br><span class="line"><span class="bullet">1.</span> 多态性：析构函数可以并且建议在基类中声明为虚函数，以便当通过基类指针或引用删除派生类对象时，能够正确调用派生类的析构函数，完成派生类特有的资源清理工作。这是实现多态性的一部分，确保所有资源得到恰当释放。</span><br><span class="line"></span><br><span class="line"><span class="section">### 反过来会怎样？</span></span><br><span class="line"><span class="bullet">-</span> 如果构造函数是虚函数：实际上这是不允许的，C++标准明确禁止构造函数为虚函数，因此这个问题在技术上不成立。试图强制实现这样的逻辑会导致编译错误。</span><br><span class="line"><span class="bullet">-</span> 如果析构函数不是虚函数：</span><br><span class="line"><span class="bullet">  -</span> 多态问题：当使用基类指针或引用管理派生类对象时，如果析构函数不是虚函数，则通过基类指针删除对象时，只会调用基类的析构函数，而派生类特有的资源可能得不到释放，导致内存泄漏或其他资源管理问题。</span><br><span class="line"><span class="bullet">  -</span> 资源泄露风险：特别是在涉及复杂继承结构和资源管理的场景下，忘记将基类析构函数声明为虚函数，会大大增加资源泄露的风险。</span><br><span class="line"></span><br><span class="line">总之，构造函数因其本质和执行时机的特殊性不能是虚函数，而析构函数虽不是必须为虚函数，但在实现多态的类层次结构中，将其声明为虚函数是最佳实践，以确保资源的正确释放。</span><br></pre></td></tr></table></figure><h4 id="虚函数底层原理"><a href="#虚函数底层原理" class="headerlink" title="虚函数底层原理"></a>虚函数底层原理</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">C++中虚函数的底层原理基于两个核心概念：虚函数表（Virtual Table，简称vtable）和虚指针（Virtual Pointer，简称vptr）。下面是对这个机制的详细解析：</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 虚函数表（vtable）</span><br><span class="line"><span class="bullet">-</span> 创建：编译器为每个含有虚函数的类自动生成一个虚函数表。这个表是一个静态的数据结构，存放了该类所有虚函数的地址（即函数指针）。</span><br><span class="line"><span class="bullet">-</span> 内容：不仅包括本类定义的虚函数地址，还可能包括从基类继承而来的虚函数地址。如果子类重写了基类的虚函数，子类的虚函数表中会替换为子类函数的地址。</span><br><span class="line"><span class="bullet">-</span> 布局：虚函数表中的函数按声明顺序排列，且通常第一个条目是用于RTTI（运行时类型信息）的类型信息指针。</span><br><span class="line"></span><br><span class="line"><span class="bullet">2.</span> 虚指针（vptr）</span><br><span class="line"><span class="bullet">-</span> 初始化：每个含有虚函数的类实例在创建时，都会自动分配一个隐藏的成员变量——虚指针vptr。这个指针在对象构造时被初始化，指向该对象对应的虚函数表。</span><br><span class="line"><span class="bullet">-</span> 位置：虚指针通常放置在对象内存布局的最开始处，但这取决于编译器实现。</span><br><span class="line"></span><br><span class="line"><span class="bullet">3.</span> 函数调用过程</span><br><span class="line"><span class="bullet">-</span> 静态绑定与动态绑定：非虚函数调用通过静态绑定在编译时确定，而虚函数调用则通过动态绑定在运行时确定。</span><br><span class="line"><span class="bullet">-</span> 调用路径：当通过基类指针或引用来调用虚函数时，编译器生成的代码首先访问对象的vptr，然后通过vptr找到虚函数表，最后根据表中记录的地址调用正确的虚函数实现。</span><br><span class="line"></span><br><span class="line"><span class="bullet">4.</span> 效率考量</span><br><span class="line"><span class="bullet">-</span> 性能影响：相比直接调用非虚函数，通过虚函数表的间接调用会有轻微的性能开销。但在现代CPU高速缓存和优化技术下，除非频繁调用或在极端性能敏感的应用中，这种开销通常可以接受。</span><br><span class="line"><span class="bullet">-</span> 设计权衡：虽然虚函数带来了一定的运行时开销，但它提供了动态多态的关键能力，使得程序设计更加灵活和可扩展。</span><br><span class="line"></span><br><span class="line"><span class="bullet">5.</span> 特殊情况</span><br><span class="line"><span class="bullet">-</span> 纯虚函数：含有纯虚函数的类不能实例化，它是作为接口使用，强制派生类必须实现这些函数。</span><br><span class="line"><span class="bullet">-</span> 虚析构函数：确保通过基类指针删除派生类对象时，派生类的析构函数会被正确调用。</span><br><span class="line"></span><br><span class="line">综上所述，虚函数的底层机制通过虚函数表和虚指针的配合，实现了在运行时根据对象的实际类型动态选择并调用函数的功能，从而支持了面向对象编程中的多态性。</span><br></pre></td></tr></table></figure><h4 id="虚表指针和虚表什么时候创建的"><a href="#虚表指针和虚表什么时候创建的" class="headerlink" title="虚表指针和虚表什么时候创建的"></a>虚表指针和虚表什么时候创建的</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">在C++中，虚表指针（vptr）和虚表的创建时机如下：</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 虚表（VTable）的创建时机： 虚表是在编译时期由编译器生成的。当一个类定义了至少一个虚函数时，编译器会为该类创建一个虚函数表，这个表中包含了类中所有虚函数的地址。这个过程在程序的编译阶段完成，虚函数表会被存放在程序的只读数据段（如.rdata段），供程序运行时使用。虚函数表属于类，类的所有对象共享这个类的虚函数表。</span><br><span class="line"></span><br><span class="line"><span class="bullet">2.</span> 虚表指针（VPtr）的创建时机： 虚表指针是在对象创建的运行时期初始化的。每当一个包含虚函数的类的对象被创建时，编译器会在对象的内存布局的最前面（通常）放置一个隐藏的指针，即虚表指针。这个指针在对象构造时被初始化，指向该类的虚函数表。如果类有构造函数，虚表指针的初始化通常发生在构造函数的开始部分；如果没有显式定义构造函数，编译器会生成一个默认构造函数来完成这项工作。这样，每个对象都有自己的虚表指针，但它们都指向同一个类的虚函数表。</span><br><span class="line"></span><br><span class="line">总结来说，虚表在编译时期静态生成，而虚表指针则在每个对象的运行时期动态初始化。</span><br></pre></td></tr></table></figure><h4 id="你认为在多线程编程中最重要的东西？互斥锁和信号量的区别？"><a href="#你认为在多线程编程中最重要的东西？互斥锁和信号量的区别？" class="headerlink" title="你认为在多线程编程中最重要的东西？互斥锁和信号量的区别？"></a>你认为在多线程编程中最重要的东西？互斥锁和信号量的区别？</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">多线程编程中最重要的几个要素包括：</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 同步与通信：确保多个线程能够有效地协同工作，防止数据竞争和不一致问题。这通常通过同步机制（如互斥锁、信号量）实现。</span><br><span class="line"><span class="bullet">2.</span> 资源共享：合理管理线程间共享的数据资源，确保并发访问的安全性。</span><br><span class="line"><span class="bullet">3.</span> 线程生命周期管理：创建、运行、同步、停止和销毁线程的控制。</span><br><span class="line"><span class="bullet">4.</span> 死锁与竞态条件的预防：识别并避免可能导致程序挂起或行为异常的并发问题。</span><br><span class="line"><span class="bullet">5.</span> 性能考量：平衡线程数量与系统资源，避免过度的上下文切换，提高效率。</span><br><span class="line"></span><br><span class="line">互斥锁（Mutex）和信号量（Semaphore）都是多线程编程中常用的同步机制，但它们之间存在一些关键区别：</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 用途：</span><br><span class="line"><span class="bullet">  -</span> 互斥锁主要用于互斥，即确保同一时间只有一个线程可以访问共享资源。它提供了一个简单的锁定机制，当一个线程获得了锁，其他试图获取同一锁的线程必须等待，直到锁被释放。</span><br><span class="line"><span class="bullet">  -</span> 信号量则用于更广泛的同步需求，不仅限于互斥访问。它可以用来控制多个线程访问有限数量的相同资源。信号量维护一个计数器，线程可以通过减小计数器来请求访问资源，通过增大计数器来释放资源。当计数器为非负时，线程可以获取信号量；当计数器为负时，线程必须等待，直到计数器变为非负。</span><br><span class="line"><span class="bullet">-</span> 功能：</span><br><span class="line"><span class="bullet">  -</span> 互斥锁只有两种状态：锁定和未锁定，适用于一对一的资源保护。</span><br><span class="line"><span class="bullet">  -</span> 信号量可以有多个单位，可以实现一对多的资源管理，适用于更复杂的同步场景，比如生产者-消费者模型。</span><br><span class="line"><span class="bullet">-</span> 复杂度：</span><br><span class="line"><span class="bullet">  -</span> 互斥锁的操作相对简单，通常用于简单的互斥访问控制。</span><br><span class="line"><span class="bullet">  -</span> 信号量提供了更复杂的同步机制，能够解决更复杂数量的资源管理和访问控制问题。</span><br><span class="line"></span><br><span class="line">在实际应用中，选择使用互斥锁还是信号量取决于具体的需求，如是否需要控制资源的访问数量、同步复杂度等因素。</span><br></pre></td></tr></table></figure><h4 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">进程与线程是现代操作系统中实现并发执行和资源管理的两个基本概念，它们有以下几方面的区别：</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 资源拥有和独立性：</span><br><span class="line"><span class="bullet">   -</span> 进程是资源分配的最小单位，拥有独立的地址空间，包括内存、文件描述符、打开的文件、信号处理器等。每个进程都是独立的，不共享内存，需要通过进程间通信（IPC）机制来交换数据。</span><br><span class="line"><span class="bullet">   -</span> 线程是CPU调度的最小单位，存在于进程内部，共享所属进程的地址空间和资源。线程之间可以直接访问同一进程内的数据，无需IPC，从而简化了通信和数据共享的复杂度。</span><br><span class="line"><span class="bullet">2.</span> 创建和销毁开销：</span><br><span class="line"><span class="bullet">   -</span> 创建和销毁进程的开销远大于线程，因为进程需要分配独立的地址空间和系统资源。</span><br><span class="line"><span class="bullet">   -</span> 线程的创建和销毁相对轻量级，因为它不需要分配单独的地址空间，只需分配栈和少量的线程控制块。</span><br><span class="line"><span class="bullet">3.</span> 上下文切换：</span><br><span class="line"><span class="bullet">   -</span> 进程之间的上下文切换比线程更耗时，因为它涉及到切换整个地址空间，保存和恢复更多的状态信息。</span><br><span class="line"><span class="bullet">   -</span> 线程上下文切换更快，因为它通常只涉及保存和恢复寄存器状态，共享同一地址空间。</span><br><span class="line"><span class="bullet">4.</span> 并发与并行：</span><br><span class="line"><span class="bullet">   -</span> 进程和线程都可以实现并发执行，即交替执行，给人一种同时运行的错觉。</span><br><span class="line"><span class="bullet">   -</span> 在多核处理器系统中，线程可以真正并行执行，即同时在不同的CPU核心上运行，充分利用硬件资源。</span><br><span class="line"><span class="bullet">5.</span> 通信：</span><br><span class="line"><span class="bullet">   -</span> 进程间通信（IPC）通常需要使用管道、消息队列、共享内存等机制，实现起来较为复杂。</span><br><span class="line"><span class="bullet">   -</span> 线程间可以直接读写同一进程内的数据，或者使用简单的锁和条件变量进行同步，通信效率更高。</span><br><span class="line"><span class="bullet">6.</span> 控制和管理：</span><br><span class="line"><span class="bullet">   -</span> 进程提供了一定程度的隔离，一个进程崩溃通常不会直接影响其他进程。</span><br><span class="line"><span class="bullet">   -</span> 线程之间缺乏这种隔离，一个线程的错误可能导致整个进程（包括其他线程）崩溃。</span><br><span class="line"></span><br><span class="line">根据具体的应用场景，开发者可以选择使用进程或线程来达到并发处理的目的，考虑因素包括资源需求、通信复杂度、性能要求以及安全隔离需求等。</span><br></pre></td></tr></table></figure><h4 id="从操作系统的角度解释线程比进程切换的快的原因"><a href="#从操作系统的角度解释线程比进程切换的快的原因" class="headerlink" title="从操作系统的角度解释线程比进程切换的快的原因"></a>从操作系统的角度解释线程比进程切换的快的原因</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">从操作系统的角度来看，线程比进程切换更快的原因主要在于线程共享地址空间和减少了上下文切换时需要保存和恢复的信息量。下面是详细解释：</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 地址空间: 进程切换涉及到虚拟地址空间的切换。每个进程都有自己的独立虚拟地址空间，这意味着在进程切换时，操作系统需要更新内存管理单元（MMU）的页表，以映射新进程的地址空间到物理内存。这一操作包括刷新TLB（Translation Lookaside Buffer，转换旁路缓存），它是快速查找虚拟地址到物理地址映射的硬件缓存。TLB刷新会导致后续内存访问变慢，直到TLB重新被填充。而线程共享所在进程的地址空间，因此在线程间切换时，不需要改变页表，也就不需要刷新TLB，从而减少了切换时间。</span><br><span class="line"><span class="bullet">2.</span> 上下文信息: 进程上下文包括了更多需要保存和恢复的信息，如独立的栈、全局变量、打开的文件描述符、信号处理器等。在进程切换时，所有这些信息都需要被保存和恢复。相比之下，线程上下文主要是栈（包括寄存器状态）、线程局部存储器等，而栈顶指针、程序计数器等关键寄存器信息是主要需要保存和恢复的部分。由于线程共享进程的资源，因此，相比进程，线程切换时需要保存和恢复的信息量少很多。</span><br><span class="line"><span class="bullet">3.</span> 硬件栈: 进程切换时，除了软件层面的上下文信息保存，还需要硬件栈的切换。而线程共享同一进程的内核栈，因此，线程切换时通常只需要切换用户栈，有时甚至用户栈也不需要切换，进一步减少了开销。</span><br><span class="line"><span class="bullet">4.</span> 系统开销: 创建和销毁进程需要分配和回收系统资源，如内存空间、文件描述符等，这涉及到复杂的系统调用和资源管理，开销较大。而线程的创建和销毁由于共享资源，开销相对较小。</span><br><span class="line"></span><br><span class="line">综上所述，由于线程在地址空间、上下文信息量、硬件栈使用以及系统开销等方面的特性，使得线程之间的切换比进程切换更快，更高效。这对于需要频繁切换的高并发场景特别有利，能够提升系统的响应速度和整体性能。</span><br></pre></td></tr></table></figure><h4 id="死锁问题"><a href="#死锁问题" class="headerlink" title="死锁问题"></a>死锁问题</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">死锁是指在多线程或多进程的并发系统中，两个或多个进程（或线程）因为互相等待对方占有的资源而永久阻塞的状态，导致这些进程都无法继续执行下去。死锁发生的必要条件通常包括：</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 互斥条件：资源只能被一个进程（或线程）占用。</span><br><span class="line"><span class="bullet">2.</span> 请求与保持条件：一个进程（或线程）持有资源并请求其他资源。</span><br><span class="line"><span class="bullet">3.</span> 不可剥夺条件：资源只能在进程（或线程）主动释放后才能被其他进程（或线程）获取。</span><br><span class="line"><span class="bullet">4.</span> 循环等待条件：存在一个进程（或线程）的资源请求序列形成了一个循环等待的环。</span><br><span class="line"></span><br><span class="line">解决死锁问题的方法主要包括以下几种策略：</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 预防死锁：</span><br><span class="line"><span class="bullet">   -</span> 破坏上述死锁的四个必要条件之一，如通过静态分配资源避免请求与保持条件，规定资源的分配顺序以破坏循环等待条件，或者允许资源剥夺。</span><br><span class="line"><span class="bullet">2.</span> 避免死锁：</span><br><span class="line"><span class="bullet">   -</span> 利用银行家算法等预先判断资源分配请求是否会导致死锁，只在安全状态下分配资源。</span><br><span class="line"><span class="bullet">3.</span> 检测死锁：</span><br><span class="line"><span class="bullet">   -</span> 运行时系统定期检查是否存在死锁，例如通过检测循环等待条件。一旦检测到死锁，采取相应措施解除。</span><br><span class="line"><span class="bullet">4.</span> 解除死锁：</span><br><span class="line"><span class="bullet">   -</span> 进程撤销法：终止一部分死锁进程，释放其资源。</span><br><span class="line"><span class="bullet">   -</span> 进程回退法：让进程回退到安全状态，释放资源后重新尝试。</span><br><span class="line"><span class="bullet">   -</span> 剥夺资源：强制从某些进程那里剥夺资源分配给其他进程，但这可能影响被剥夺进程的正确性。</span><br><span class="line"><span class="bullet">   -</span> 死锁忽略：在某些情况下，如果死锁发生的概率很小或影响不大，可以选择忽略死锁问题。</span><br><span class="line"></span><br><span class="line">选择合适的策略需根据具体的应用场景和系统需求来决定，通常需要在系统设计初期就考虑死锁预防机制，以减少运行时处理死锁的复杂性和风险。</span><br></pre></td></tr></table></figure><h4 id="动态库和静态库的区别"><a href="#动态库和静态库的区别" class="headerlink" title="动态库和静态库的区别"></a>动态库和静态库的区别</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">动态库和静态库是程序开发中用于代码复用的两种不同类型的库文件，它们在链接方式、运行时行为、资源占用、更新维护等方面有着显著的区别：</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 链接时机:</span><br><span class="line"><span class="bullet">   -</span> 静态库：在编译期间（link time），静态库的代码会被直接整合到目标应用程序中，生成的可执行文件是自包含的，不依赖于库文件本身。</span><br><span class="line"><span class="bullet">   -</span> 动态库：动态库在编译时并不被直接合并到可执行文件中，而是在程序运行时（runtime）由操作系统加载到内存中，并与应用程序链接。这意味着动态库不成为可执行文件的一部分。</span><br><span class="line"><span class="bullet">2.</span> 内存占用与代码共享:</span><br><span class="line"><span class="bullet">   -</span> 静态库：每个使用静态库的应用程序都会包含库代码的一份拷贝，这会增加最终可执行文件的大小，并且不能在不同程序间共享相同的库代码，导致内存占用较高。</span><br><span class="line"><span class="bullet">   -</span> 动态库：多个程序可以共享同一份动态库的代码段，只需在内存中载入一次，节省了内存空间，尤其是在多个程序同时运行且都使用同一动态库的情况下。</span><br><span class="line"><span class="bullet">3.</span> 更新与维护:</span><br><span class="line"><span class="bullet">   -</span> 静态库：如果静态库需要更新，所有依赖它的应用程序都需要重新编译和链接，这在大型项目或部署环境中可能会非常不便。</span><br><span class="line"><span class="bullet">   -</span> 动态库：更新动态库时，只需替换相应的库文件，无需重新编译依赖它的应用程序，这大大简化了软件的升级和维护过程。</span><br><span class="line"><span class="bullet">4.</span> 文件扩展名与平台差异:</span><br><span class="line"><span class="bullet">   -</span> 静态库：常见的文件扩展名有<span class="code">`.a`</span>（Unix-like系统）和<span class="code">`.lib`</span>（Windows系统）。</span><br><span class="line"><span class="bullet">   -</span> 动态库：在Unix-like系统中通常为<span class="code">`.so`</span>（Shared Object），Windows系统中为<span class="code">`.dll`</span>（Dynamic Link Library）。</span><br><span class="line"><span class="bullet">5.</span> 性能:</span><br><span class="line"><span class="bullet">   -</span> 静态库：因为代码已经集成在可执行文件中，启动时不需要额外的加载步骤，可能会有更快的启动时间。</span><br><span class="line"><span class="bullet">   -</span> 动态库：虽然可能有轻微的加载延迟，但在某些情况下，如代码共享，可以减少总的内存使用，从而提高整体系统性能。</span><br><span class="line"></span><br><span class="line">根据项目的具体需求，开发者可以选择使用静态库或动态库，以平衡开发便利性、资源占用、更新灵活性和运行时性能等因素。</span><br></pre></td></tr></table></figure><h4 id="qt的事件循环讲一下"><a href="#qt的事件循环讲一下" class="headerlink" title="qt的事件循环讲一下"></a>qt的事件循环讲一下</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Qt的事件循环是其框架内用于处理各种用户交互和系统事件的核心机制。它基于事件驱动编程模型，允许应用程序响应如鼠标点击、键盘输入、窗口调整大小、定时器触发等多种事件，而不是按照固定的线性流程执行。</span><br><span class="line"></span><br><span class="line">在Qt中，事件循环的工作原理大致如下：</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 事件生成：当用户进行操作（如点击鼠标、敲击键盘）或系统发生某种状态变化（如时间到达定时器设定值）时，Qt会生成相应的事件对象。这些事件对象是从基类<span class="code">`QEvent`</span>派生的，比如<span class="code">`QMouseEvent`</span>、<span class="code">`QKeyEvent`</span>、<span class="code">`QTimerEvent`</span>等。</span><br><span class="line"><span class="bullet">2.</span> 事件队列：生成的事件被放置到一个事件队列中。这个队列负责存储等待处理的所有事件，确保事件按先进先出（FIFO）的顺序被处理。</span><br><span class="line"><span class="bullet">3.</span> 事件循环启动：通过调用<span class="code">`QApplication::exec()`</span>方法，事件循环开始运行。这个方法会进入一个循环，不断地检查事件队列是否为空。</span><br><span class="line"><span class="bullet">4.</span> 事件分发与处理：在循环中，事件循环会从队列顶部取出一个事件，并分发给对应的对象进行处理。对象通过重写<span class="code">`QObject::event()`</span>方法或特定事件处理函数（如<span class="code">`mousePressEvent()`</span>、<span class="code">`keyPressEvent()`</span>）来响应这些事件。</span><br><span class="line"><span class="bullet">5.</span> 同步与异步处理：Qt支持事件的同步和异步处理。<span class="code">`postEvent`</span>函数用于将事件添加到队列中异步处理，而<span class="code">`sendEvent`</span>则尝试直接调用事件处理函数同步处理事件，不经过队列。</span><br><span class="line"><span class="bullet">6.</span> 循环终止：当事件队列为空，且没有其他活动的事件源时，事件循环可能会阻塞等待新事件。此外，可以通过调用<span class="code">`QApplication::exit()`</span>显式退出事件循环，这通常是应用程序关闭时的操作。</span><br><span class="line"><span class="bullet">7.</span> 资源清理：事件循环结束时，Qt会自动清理一些资源，包括关闭打开的文件、释放内存等，确保程序优雅地退出。</span><br><span class="line"></span><br><span class="line">简而言之，Qt的事件循环机制使得应用程序能够高效、有序地处理外部输入和内部状态变化，是构建响应式和交互式GUI应用程序的基础。</span><br></pre></td></tr></table></figure><h4 id="qt的消息机制和windows的消息机制有什么关联吗"><a href="#qt的消息机制和windows的消息机制有什么关联吗" class="headerlink" title="qt的消息机制和windows的消息机制有什么关联吗"></a>qt的消息机制和windows的消息机制有什么关联吗</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Qt的消息机制和Windows的消息机制虽然服务于相似的目的——即实现应用程序的事件驱动编程，但它们在实现细节和设计理念上有所不同，同时又存在着紧密的关联，特别是在Qt应用于Windows平台时。</span><br><span class="line"></span><br><span class="line">Windows消息机制：</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 基于C语言风格，更底层，直接与操作系统交互。</span><br><span class="line"><span class="bullet">-</span> 消息通过消息队列传递，应用程序通过调用如<span class="code">`GetMessage`</span>, <span class="code">`TranslateMessage`</span>, 和 <span class="code">`DispatchMessage`</span>等API函数来处理消息队列中的消息。</span><br><span class="line"><span class="bullet">-</span> 每个窗口过程（Window Procedure）是一个回调函数，负责处理发送给窗口的消息。</span><br><span class="line"><span class="bullet">-</span> 消息由一个消息标识符（message ID）、附加的WPARAM和LPARAM参数以及一个指向窗口实例的HWND组成，封装在一个MSG结构中。</span><br><span class="line"></span><br><span class="line">Qt事件机制：</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 更高层，面向对象，提供了更加抽象和易于使用的API。</span><br><span class="line"><span class="bullet">-</span> 基于事件（<span class="code">`QEvent`</span>）和事件处理器（如<span class="code">`QObject::event()`</span>）的概念。</span><br><span class="line"><span class="bullet">-</span> 事件循环由<span class="code">`QEventLoop`</span>管理，通过调用<span class="code">`QApplication::exec()`</span>启动。</span><br><span class="line"><span class="bullet">-</span> 事件处理通常通过重写<span class="code">`QObject`</span>的<span class="code">`event()`</span>函数或特定事件处理函数（如<span class="code">`mousePressEvent`</span>）来完成。</span><br><span class="line"><span class="bullet">-</span> Qt的事件机制在不同平台（如Windows、Linux、macOS）上提供了统一的接口，隐藏了底层系统的差异。</span><br><span class="line"></span><br><span class="line">关联点：</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 当Qt应用运行在Windows平台上时，Qt的消息机制需要与Windows的消息机制对接。Qt通过一个名为<span class="code">`QEventDispatcherWin32`</span>的类（它是<span class="code">`QAbstractEventDispatcher`</span>的子类）来桥接Qt的事件循环与Windows消息循环。</span><br><span class="line"><span class="bullet">-</span> <span class="code">`QEventDispatcherWin32`</span>会监听Windows消息队列，将Windows消息转换为Qt事件（<span class="code">`QEvent`</span>），并放入Qt的事件队列中，这样Qt应用就可以通过统一的事件处理接口来响应原本来自Windows的消息。</span><br><span class="line"><span class="bullet">-</span> Qt还提供了接口，允许开发者直接处理Windows消息，例如通过重写<span class="code">`QWidget::winEvent()`</span>或使用native event filters，这样可以在保持Qt编程风格的同时，处理特定于Windows的低级消息。</span><br><span class="line"></span><br><span class="line">因此，尽管Qt提供了一个跨平台的事件处理模型，但在Windows平台上，它依然依赖于Windows的消息机制作为与操作系统交互的基础，并在此之上构建了一层更为高级和抽象的事件处理框架。</span><br></pre></td></tr></table></figure><h4 id="Qt架构相较于C-标准库有哪些不同吗，多了哪些东西，有哪些优势"><a href="#Qt架构相较于C-标准库有哪些不同吗，多了哪些东西，有哪些优势" class="headerlink" title="Qt架构相较于C++标准库有哪些不同吗，多了哪些东西，有哪些优势"></a>Qt架构相较于C++标准库有哪些不同吗，多了哪些东西，有哪些优势</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Qt架构与C++标准库（STL）之间有一些本质上的不同，主要体现在目标、功能范围和提供的特性上。以下是它们之间的一些关键区别以及Qt所增添的优势：</span><br><span class="line"></span><br><span class="line"><span class="section">### 不同之处</span></span><br><span class="line"><span class="bullet">1.</span> 目标和范围：</span><br><span class="line"><span class="bullet">   -</span> C++标准库：主要关注于提供基础的数据结构（如vector, list, map等）、算法（排序、查找等）、输入输出流、字符串处理等通用编程组件。它是C++语言的组成部分，旨在提升编程效率和代码质量。</span><br><span class="line"><span class="bullet">   -</span> Qt库：是一个全面的应用程序开发框架，不仅包含数据结构和算法，还提供了用于图形用户界面（GUI）开发、网络编程、数据库访问、多线程、文件I/O、XML处理、JSON解析、国际化和本地化等高级功能。Qt特别强调跨平台能力，允许开发者编写一次代码，在多种操作系统上编译运行。</span><br><span class="line"></span><br><span class="line"><span class="bullet">2.</span> 用户界面支持：</span><br><span class="line"><span class="bullet">   -</span> C++标准库：不包含直接用于创建图形用户界面的组件。</span><br><span class="line"><span class="bullet">   -</span> Qt库：拥有强大的GUI开发工具和组件，如QWidget、QML等，使得UI设计变得直观且高效。</span><br><span class="line"></span><br><span class="line"><span class="bullet">3.</span> 信号与槽机制：</span><br><span class="line"><span class="bullet">   -</span> C++标准库：没有内置的事件驱动编程机制。</span><br><span class="line"><span class="bullet">   -</span> Qt库：引入了独特的信号（Signals）和槽（Slots）机制，这是一种灵活的事件处理方式，允许对象之间的松耦合通信，是Qt框架的一大特色。</span><br><span class="line"></span><br><span class="line"><span class="bullet">4.</span> 跨平台能力：</span><br><span class="line"><span class="bullet">   -</span> C++标准库：虽然大部分是跨平台的，但它不直接提供平台无关的UI或系统服务接口。</span><br><span class="line"><span class="bullet">   -</span> Qt库：提供了高度抽象的API，使得开发者能编写跨平台的代码，无需担心底层操作系统的差异。</span><br><span class="line"></span><br><span class="line"><span class="section">### Qt的优势</span></span><br><span class="line"><span class="bullet">1.</span> 集成开发环境：Qt Creator是一个功能丰富的集成开发环境（IDE），专为Qt开发设计，提供代码编辑、调试、UI设计、版本控制等功能。</span><br><span class="line"><span class="bullet">2.</span> 图形用户界面工具：Qt Designer等工具简化了UI设计过程，支持拖拽式布局设计。</span><br><span class="line"><span class="bullet">3.</span> 跨平台一致性：Qt确保了代码在不同操作系统上的表现一致，减少了移植工作。</span><br><span class="line"><span class="bullet">4.</span> 丰富的模块和库：Qt提供了广泛的模块，几乎覆盖了开发复杂应用所需的所有方面。</span><br><span class="line"><span class="bullet">5.</span> 信号与槽机制：简化了对象间的通信，提高了代码的可读性和可维护性。</span><br><span class="line"><span class="bullet">6.</span> 活跃的社区和文档：Qt拥有庞大的开发者社区和详尽的文档，便于学习和解决问题。</span><br><span class="line"></span><br><span class="line">综上所述，Qt不仅仅是一个库，它是一个完整的开发框架，补充了C++标准库的功能，特别是在应用程序开发尤其是GUI领域，提供了更高的生产力和更广泛的工具集。</span><br></pre></td></tr></table></figure><h4 id="qt的信号槽底层原理"><a href="#qt的信号槽底层原理" class="headerlink" title="qt的信号槽底层原理"></a>qt的信号槽底层原理</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Qt的信号槽（Signals and Slots）机制是其框架中一个核心且强大的特性，允许对象之间进行解耦通信。其底层原理涉及以下几个关键技术组件和步骤：</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 元对象系统（Meta-Object System）：Qt的信号槽机制建立在元对象系统之上，该系统为每个 QObject 类的实例提供运行时类型信息。元对象编译器（moc，Meta-Object Compiler）是一个预处理器，它扫描C++源代码中的Q<span class="emphasis">_OBJECT宏，并生成额外的C++代码来实现信号槽机制和其他元对象特性。这个过程中，moc会为信号和槽生成相应的元数据。</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">2. 动态代理（Dynamic Proxy）：为了在信号发射时调用相应的槽函数，Qt使用了一种动态代理机制。这意味着在运行时，信号和槽的连接是通过查找元数据并在必要时生成适配代码来实现的。这保证了信号和槽的连接既类型安全又灵活。</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">3. 事件驱动：信号槽机制在本质上是事件驱动的。当信号被发射（emit）时，它会产生一个事件，这个事件随后被事件循环捕获并处理，导致相应的槽函数被调用。尽管通常感觉上是即时发生的，但实际上信号的处理是通过事件循环排队和调度的。</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">4. 连接管理：信号和槽之间的连接是由`QObject::connect`方法建立的。这个方法记录了信号和槽之间的关系，包括它们的参数类型，以便在信号发射时进行类型检查和适配。连接可以是直接的也可以是队列的（在不同线程中），并且可以指定连接类型（如默认、直接、队列、阻塞）来控制调用行为。</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">5. 线程安全性：Qt信号槽机制设计时考虑到了线程安全性。在不同线程中，信号和槽的交互需要特殊处理，以确保数据同步和线程间的正确通信。Qt通过事件队列和线程间的消息传递来确保跨线程的信号槽调用是安全的。</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">6. 类型检查与转换：在连接信号和槽时，Qt会检查它们的签名（参数类型和数量）是否匹配。如果不完全匹配，但可以通过隐式类型转换达成一致，Qt也会允许这样的连接。类型检查确保了信号发送的数据能够正确地传递给槽函数。</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">总的来说，Qt的信号槽机制通过元对象系统、动态代理、事件循环等组件实现了对象间的松耦合通信，提升了代码的模块化和可维护性，同时也保证了高效率和线程安全。</span></span><br></pre></td></tr></table></figure><h4 id="qt的信号槽connect函数的参数，第五个参数是什么"><a href="#qt的信号槽connect函数的参数，第五个参数是什么" class="headerlink" title="qt的信号槽connect函数的参数，第五个参数是什么"></a>qt的信号槽connect函数的参数，第五个参数是什么</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Qt的<span class="code">`connect`</span>函数用于建立信号和槽之间的连接，其原型可以接受多个参数，其中第五个参数是<span class="code">`connectionType`</span>，用于指定信号和槽之间的连接类型。这个参数是可选的，因为默认情况下会使用<span class="code">`Qt::AutoConnection`</span>。以下是关于第五个参数<span class="code">`connectionType`</span>的可能取值及其含义：</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> Qt::AutoConnection（默认值）：连接类型会在信号发送时自动决定。如果接收者和发送者在同一个线程，则使用<span class="code">`Qt::DirectConnection`</span>；如果在不同线程，则使用<span class="code">`Qt::QueuedConnection`</span>。</span><br><span class="line"></span><br><span class="line"><span class="bullet">2.</span> Qt::DirectConnection：槽函数会在信号发送的时候直接被调用，即槽函数运行于信号发送者所在线程。这种模式下，信号发送后槽函数会立即执行，不经过事件队列。</span><br><span class="line"></span><br><span class="line"><span class="bullet">3.</span> Qt::QueuedConnection：槽函数会在控制权回到接收者所在线程的事件循环时被调用。这意味着槽函数将在接收者线程的一个后续事件循环迭代中执行，因此发送信号后槽函数不会立即执行。</span><br><span class="line"></span><br><span class="line"><span class="bullet">4.</span> Qt::BlockingQueuedConnection：类似于<span class="code">`Qt::QueuedConnection`</span>，但是发送者线程会阻塞，直到槽函数执行完毕。这种连接类型要求发送者和接收者不在同一个线程，否则会导致死锁。</span><br><span class="line"></span><br><span class="line"><span class="bullet">5.</span> Qt::UniqueConnection：这不是一个独立的连接类型，而是一个标志位，可以与上述类型通过按位或（<span class="code">`|`</span>）操作符组合使用。如果设置了这个标志，当尝试重复连接相同的信号和槽时，连接将失败，从而避免了槽函数的重复调用。</span><br><span class="line"></span><br><span class="line">在实际编程中，通过合理选择连接类型，开发者可以控制多线程环境下的执行顺序和线程安全问题，以及优化程序的响应性和性能。</span><br></pre></td></tr></table></figure><h4 id="有一串列表，怎么判断他们有没有相交的部分"><a href="#有一串列表，怎么判断他们有没有相交的部分" class="headerlink" title="有一串列表，怎么判断他们有没有相交的部分"></a>有一串列表，怎么判断他们有没有相交的部分</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">判断两个链表是否相交，通常涉及以下几种方法，具体取决于链表是否有环以及你所拥有的信息。这里假设您提到的是单链表，且希望判断它们是否在某个节点处相交。</span><br><span class="line"></span><br><span class="line"><span class="section">### 对于无环链表</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 计算长度法:</span><br><span class="line"><span class="bullet">   -</span> 首先遍历两个链表，计算它们的长度。</span><br><span class="line"><span class="bullet">   -</span> 如果长度不同，它们肯定不相交。</span><br><span class="line"><span class="bullet">   -</span> 如果长度相同，将较长链表的头指针（实际上是相同长度，这里只是为了表述）向前移动它们长度差的步数，使两个指针处于相同“起跑线”。</span><br><span class="line"><span class="bullet">   -</span> 然后同时遍历两个链表，如果在某一步两个指针指向同一节点，则说明链表相交，否则不相交。</span><br><span class="line"></span><br><span class="line"><span class="bullet">2.</span> 哈希表法:</span><br><span class="line"><span class="bullet">   -</span> 遍历第一个链表，将所有节点的地址存入哈希表。</span><br><span class="line"><span class="bullet">   -</span> 遍历第二个链表，检查每个节点的地址是否已经在哈希表中出现过，如果出现过则说明相交。</span><br><span class="line"></span><br><span class="line"><span class="bullet">3.</span> 直接遍历法:</span><br><span class="line"><span class="bullet">   -</span> 将一个链表的尾部连接到另一个链表头部，形成一个环，然后使用快慢指针检测环的存在。如果形成环，则说明原链表相交；如果没有形成环，则不相交。此方法需谨慎使用，因为它改变了原链表结构，使用后要恢复原状。</span><br><span class="line"></span><br><span class="line"><span class="section">### 对于有环链表</span></span><br><span class="line"></span><br><span class="line">如果有环，情况会稍微复杂，但根据题目描述，通常假设相交的链表要么都是无环的，要么都是有环的。对于有环链表相交的情况，可以先确定环的存在和位置，然后通过特定逻辑判断两个链表是否通过相同的环相交。</span><br><span class="line"></span><br><span class="line"><span class="section">### 综合考虑</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 环的检测:</span><br><span class="line"><span class="bullet">  -</span> 使用快慢指针（Floyd判圈算法）来检测链表是否有环，快指针每次移动两步，慢指针每次移动一步，如果相遇则链表有环。</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 相交判断:</span><br><span class="line"><span class="bullet">  -</span> 如果两个链表都有环，可以进一步判断环内的节点是否相同，这通常需要先找到环的入口点，然后通过特定逻辑比较。</span><br><span class="line"></span><br><span class="line">总之，判断链表相交的关键在于理解链表的结构，选择合适的方法，如果是无环链表，通常采用长度计算或哈希表法较为直接有效；而对于有环链表，则需要先解决环的问题再进行相交判断。</span><br></pre></td></tr></table></figure><h4 id="求给定数组中第k大的数"><a href="#求给定数组中第k大的数" class="headerlink" title="求给定数组中第k大的数"></a>求给定数组中第k大的数</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">找到给定数组中第k大的数的方法主要有以下几种：</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 排序后直接访问</span><br><span class="line"><span class="bullet">   -</span> 将数组排序（可以使用快速排序、归并排序等算法）。</span><br><span class="line"><span class="bullet">   -</span> 排序后，第k大的数就是数组中倒数第k个元素（即第n-k+1个元素，其中n是数组长度）。</span><br><span class="line"><span class="bullet">   -</span> 时间复杂度通常是O(nlogn)，其中n是数组长度。</span><br><span class="line"></span><br><span class="line"><span class="bullet">2.</span> 快速选择算法（QuickSelect）</span><br><span class="line"><span class="bullet">   -</span> 类似于快速排序的划分过程，但不需要完全排序整个数组。</span><br><span class="line"><span class="bullet">   -</span> 选择一个基准元素，将数组划分为两部分，一部分包含所有小于基准的元素，另一部分包含所有大于基准的元素。</span><br><span class="line"><span class="bullet">   -</span> 根据基准元素的位置与k的关系，递归地在左侧或右侧子数组中进行快速选择。</span><br><span class="line"><span class="bullet">   -</span> 时间复杂度平均情况下是O(n)，最坏情况下是O(n^2)，但可以通过随机化基准元素的选择来降低最坏情况的发生概率。</span><br><span class="line"></span><br><span class="line"><span class="bullet">3.</span> 部分排序（Partial Sorting）</span><br><span class="line"><span class="bullet">   -</span> 使用如堆排序、堆选择等算法，只排序或选择出数组中的前k个最大元素。</span><br><span class="line"><span class="bullet">   -</span> 这种方法通常不需要对整个数组进行排序，因此时间复杂度可以低于O(nlogn)。</span><br><span class="line"><span class="bullet">   -</span> 具体实现上，可以使用最小堆来维护当前最大的k个数，遍历数组并将元素与堆顶元素比较，如果当前元素更大，则弹出堆顶元素并将当前元素入堆。</span><br><span class="line"></span><br><span class="line"><span class="bullet">4.</span> 使用STL库</span><br><span class="line"><span class="bullet">   -</span> 在C++中，可以使用STL库中的<span class="code">`nth_element`</span>算法，该算法可以在线性时间内将第k大的元素移动到其最终排序位置，但并不会对整个数组进行排序。</span><br><span class="line"><span class="bullet">   -</span> <span class="code">`nth_element`</span>算法使用了类似于快速选择的思想，但不需要递归。</span><br><span class="line"></span><br><span class="line"><span class="bullet">5.</span> 桶排序或计数排序（如果数值范围有限）</span><br><span class="line"><span class="bullet">   -</span> 如果数组中的数值范围有限，可以使用桶排序或计数排序等线性时间复杂度的排序算法。</span><br><span class="line"><span class="bullet">   -</span> 排序后，同样可以通过访问倒数第k个元素来找到第k大的数。</span><br><span class="line"></span><br><span class="line">以上方法各有优缺点，具体选择哪种方法取决于数组的大小、数值的分布情况以及性能要求等因素。</span><br></pre></td></tr></table></figure><h4 id="32位和64位系统下成员变量和对象各种区别和细节"><a href="#32位和64位系统下成员变量和对象各种区别和细节" class="headerlink" title="32位和64位系统下成员变量和对象各种区别和细节"></a>32位和64位系统下成员变量和对象各种区别和细节</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">在C++中，32位和64位系统的区别主要体现在以下几个方面，这些区别会影响到成员变量和对象的处理：</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 数据类型大小：</span><br><span class="line"><span class="bullet">   -</span> 基本数据类型的大小可能不同。例如，在32位系统中，<span class="code">`int`</span>和<span class="code">`pointer`</span>（指针）通常为32位（4字节），而在64位系统中，<span class="code">`int`</span>可能仍然是32位（取决于编译器和平台），但指针通常是64位（8字节）。<span class="code">`long`</span>和<span class="code">`long long`</span>的大小也可能因系统而异。</span><br><span class="line"><span class="bullet">   -</span> <span class="code">`sizeof`</span>运算符返回的成员变量或对象的大小会根据系统架构和编译器有所不同。</span><br><span class="line"></span><br><span class="line"><span class="bullet">2.</span> 内存对齐：</span><br><span class="line"><span class="bullet">   -</span> 内存对齐规则可能会导致相同结构体或类在不同系统下的总大小不同。64位系统可能要求更严格的对齐，从而可能导致结构体内存占用增加。</span><br><span class="line"><span class="bullet">   -</span> 空类在任何系统下至少占用1字节，但在有成员变量的情况下，对齐要求会影响整体大小。</span><br><span class="line"></span><br><span class="line"><span class="bullet">3.</span> 性能和寻址能力：</span><br><span class="line"><span class="bullet">   -</span> 64位系统能直接寻址更多内存（理论上可达18EB），而32位系统寻址能力上限通常为4GB。这影响了处理大规模数据结构的能力。</span><br><span class="line"><span class="bullet">   -</span> 由于更宽的寄存器，64位系统在某些计算上可能比32位系统更高效。</span><br><span class="line"></span><br><span class="line"><span class="bullet">4.</span> 编译器和库支持：</span><br><span class="line"><span class="bullet">   -</span> 64位和32位系统可能需要不同的编译器设置和库文件。某些库可能只针对特定位宽优化，影响到性能和兼容性。</span><br><span class="line"></span><br><span class="line"><span class="bullet">5.</span> 对象布局和虚函数：</span><br><span class="line"><span class="bullet">   -</span> 对象的内存布局，尤其是含有虚函数的对象，会包含指向虚函数表的指针。在64位系统中，这个指针也会增大到8字节。</span><br><span class="line"><span class="bullet">   -</span> 类的继承和虚继承可能在不同位宽系统上有不同的内存布局，影响到对象的大小和访问效率。</span><br><span class="line"></span><br><span class="line"><span class="bullet">6.</span> 性能考量：</span><br><span class="line"><span class="bullet">   -</span> 在64位系统上，处理较大的数据类型（如64位指针）可能会消耗更多的缓存空间，对内存敏感的应用可能需要注意这一点。</span><br><span class="line"></span><br><span class="line">综上所述，虽然C++语言本身并不直接定义32位和64位系统的具体行为，但编译器、操作系统和硬件的组合会导致在不同位宽系统上编译和运行C++代码时产生上述差异。开发者在编写跨平台代码时，需要考虑这些因素以确保代码的兼容性和性能。</span><br></pre></td></tr></table></figure><h4 id="32位软件跑在64位系统上，跟64位软件跑在64位系统上有什么区别"><a href="#32位软件跑在64位系统上，跟64位软件跑在64位系统上有什么区别" class="headerlink" title="32位软件跑在64位系统上，跟64位软件跑在64位系统上有什么区别"></a>32位软件跑在64位系统上，跟64位软件跑在64位系统上有什么区别</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">32位软件跑在64位系统上与64位软件跑在64位系统上的主要区别包括：</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 内存访问能力：</span><br><span class="line"><span class="bullet">   -</span> 32位软件：受限于32位地址空间，最多能直接访问约4GB的内存。即使在64位系统上，32位程序也无法直接利用超过4GB的物理内存。</span><br><span class="line"><span class="bullet">   -</span> 64位软件：可以利用更大的内存地址空间，理论上可访问的内存大小远超4GB，使得处理大规模数据集更为高效。</span><br><span class="line"></span><br><span class="line"><span class="bullet">2.</span> 性能表现：</span><br><span class="line"><span class="bullet">   -</span> 32位软件：在64位系统上以兼容模式运行时，由于需要通过系统层的地址转换等机制来模拟32位环境，可能会有细微的性能损失，尤其是在进行大量内存操作时。不过，对于大多数日常应用，这种性能差异不明显。</span><br><span class="line"><span class="bullet">   -</span> 64位软件：可以直接利用64位架构的优势，如更宽的寄存器，允许一次性处理更多数据，理论上可以提升计算和数据处理的效率。</span><br><span class="line"></span><br><span class="line"><span class="bullet">3.</span> 系统资源利用：</span><br><span class="line"><span class="bullet">   -</span> 32位软件：可能不会充分利用64位系统提供的更高效的指令集和增强的硬件特性。</span><br><span class="line"><span class="bullet">   -</span> 64位软件：设计上能更好地匹配64位CPU的特性，利用更多寄存器和指令集扩展，从而提高执行效率。</span><br><span class="line"></span><br><span class="line"><span class="bullet">4.</span> 兼容性与运行环境：</span><br><span class="line"><span class="bullet">   -</span> 32位软件：依赖于64位系统提供的兼容层（WoW64，Windows on Windows 64-bit）来运行，系统需提供32位库和环境。</span><br><span class="line"><span class="bullet">   -</span> 64位软件：直接在64位系统环境中运行，无需兼容层，可以更紧密地与系统交互，获取最佳性能。</span><br><span class="line"></span><br><span class="line"><span class="bullet">5.</span> 数据类型和指针大小：</span><br><span class="line"><span class="bullet">   -</span> 32位软件：指针和某些数据类型的大小通常为4字节。</span><br><span class="line"><span class="bullet">   -</span> 64位软件：指针大小通常为8字节，这影响了内存使用和数据对齐，有时也会影响数据结构的大小和效率。</span><br><span class="line"></span><br><span class="line">总的来说，尽管32位软件可以在64位系统上运行，但可能无法完全发挥64位系统的潜能，特别是在内存管理和性能方面。相比之下，64位软件能够更好地利用现代硬件资源，提供更高的性能和扩展性。</span><br></pre></td></tr></table></figure><h4 id="vector-map-list底层原理，复杂度"><a href="#vector-map-list底层原理，复杂度" class="headerlink" title="vector/map/list底层原理，复杂度"></a>vector/map/list底层原理，复杂度</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">在C++标准模板库(STL)中，<span class="code">`vector`</span>、<span class="code">`map`</span>、和<span class="code">`list`</span>是非常常用的数据结构，它们各有不同的底层实现和操作复杂度。</span><br><span class="line"></span><br><span class="line"><span class="section">### vector</span></span><br><span class="line"><span class="bullet">-</span> 底层原理：<span class="code">`vector`</span>是一个动态数组，它在内存中分配一块连续的空间来存储元素。当元素数量超出当前容量时，它会重新分配更大的内存块，并将原有元素复制过去。因此，它支持随机访问，但插入和删除元素（特别是中间位置）可能较慢，因为可能涉及元素的移动。</span><br><span class="line"><span class="bullet">-</span> 复杂度：</span><br><span class="line"><span class="bullet">  -</span> 访问：O(1)</span><br><span class="line"><span class="bullet">  -</span> 在末尾插入：常数时间（如果未触发重新分配），否则O(n)</span><br><span class="line"><span class="bullet">  -</span> 在中间或开头插入/删除：O(n)</span><br><span class="line"><span class="bullet">  -</span> 尾部删除：O(1)</span><br><span class="line"></span><br><span class="line"><span class="section">### map</span></span><br><span class="line"><span class="bullet">-</span> 底层原理：<span class="code">`map`</span>通常实现为红黑树（一种自平衡二叉查找树），它保持了键值对之间的有序关系。这意味着查找、插入和删除操作都能保证较高的效率。</span><br><span class="line"><span class="bullet">-</span> 复杂度：</span><br><span class="line"><span class="bullet">  -</span> 查找、插入、删除：O(log n)</span><br><span class="line"><span class="bullet">  -</span> 迭代：O(n)</span><br><span class="line"></span><br><span class="line"><span class="section">### list</span></span><br><span class="line"><span class="bullet">-</span> 底层原理：<span class="code">`list`</span>是一个双向链表，每个节点包含数据和两个指针，分别指向前一个和后一个节点。这种结构使得在列表的任何位置插入和删除元素都非常迅速，但不支持随机访问。</span><br><span class="line"><span class="bullet">-</span> 复杂度：</span><br><span class="line"><span class="bullet">  -</span> 在任何位置插入/删除：O(1)</span><br><span class="line"><span class="bullet">  -</span> 访问（通过迭代）：O(n)</span><br><span class="line"><span class="bullet">  -</span> 迭代：O(n)</span><br><span class="line"></span><br><span class="line">总结而言，<span class="code">`vector`</span>适合快速随机访问和在末尾进行高效的插入和删除，<span class="code">`map`</span>适合需要键值对且关心键的有序性的场景，而<span class="code">`list`</span>则在频繁进行插入和删除操作，且不需要随机访问时表现优秀。选择哪种容器取决于具体的应用需求。</span><br></pre></td></tr></table></figure><h4 id="常用数据结构的应用场景"><a href="#常用数据结构的应用场景" class="headerlink" title="常用数据结构的应用场景"></a>常用数据结构的应用场景</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">C++中常用的数据结构及其应用场景如下：</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 静态数组 (Array)</span><br><span class="line"><span class="bullet">   -</span> 特点：固定大小的连续内存空间，用于存储相同类型的元素。</span><br><span class="line"><span class="bullet">   -</span> 应用场景：适用于需要快速访问和处理的数据，且数据量大小已知且不变，如小型矩阵操作、固定大小的数据缓存。</span><br><span class="line"></span><br><span class="line"><span class="bullet">2.</span> 动态数组 (Vector)</span><br><span class="line"><span class="bullet">   -</span> 特点：自动管理内存的数组，可以动态增长。</span><br><span class="line"><span class="bullet">   -</span> 应用场景：当需要在运行时动态添加或删除元素，且频繁进行随机访问时，如动态数据缓冲区、结果集存储。</span><br><span class="line"></span><br><span class="line"><span class="bullet">3.</span> 队列 (Queue)</span><br><span class="line"><span class="bullet">   -</span> 特点：遵循先进先出（FIFO）原则的线性数据结构。</span><br><span class="line"><span class="bullet">   -</span> 应用场景：任务调度、消息传递、缓存系统中的数据处理顺序控制。</span><br><span class="line"></span><br><span class="line"><span class="bullet">4.</span> 优先队列 (Priority Queue)</span><br><span class="line"><span class="bullet">   -</span> 特点：特殊队列，每个元素都有一个优先级，每次删除的是优先级最高的元素。</span><br><span class="line"><span class="bullet">   -</span> 应用场景：事件驱动编程中的事件调度、任务优先级排序、Dijkstra算法中的最短路径计算。</span><br><span class="line"></span><br><span class="line"><span class="bullet">5.</span> 栈 (Stack)</span><br><span class="line"><span class="bullet">   -</span> 特点：遵循后进先出（LIFO）原则的线性数据结构。</span><br><span class="line"><span class="bullet">   -</span> 应用场景：函数调用栈、表达式求值、撤销操作的实现、括号匹配验证。</span><br><span class="line"></span><br><span class="line"><span class="bullet">6.</span> 链表 (LinkedList)</span><br><span class="line"><span class="bullet">   -</span> 特点：非连续内存空间，每个节点包含数据和指向下一个节点的指针。</span><br><span class="line"><span class="bullet">   -</span> 应用场景：频繁的插入和删除操作，不需要随机访问，如内存管理、实现其他高级数据结构如哈希表的桶。</span><br><span class="line"></span><br><span class="line"><span class="bullet">7.</span> 哈希表 (Hash Table)</span><br><span class="line"><span class="bullet">   -</span> 特点：通过散列函数将键映射到数组的索引，实现快速查找、插入和删除。</span><br><span class="line"><span class="bullet">   -</span> 应用场景：数据库索引、缓存、字典、集合等需要快速查找的场景。</span><br><span class="line"></span><br><span class="line"><span class="bullet">8.</span> 树 (Tree)</span><br><span class="line"><span class="bullet">   -</span> 特点：分层的非线性数据结构，用于表示具有层次关系的数据。</span><br><span class="line"><span class="bullet">   -</span> 应用场景：文件系统、DOM（文档对象模型）、表达式树、各种搜索算法（如二叉查找树、AVL树、红黑树等）。</span><br><span class="line"></span><br><span class="line"><span class="bullet">9.</span> 图 (Graph)</span><br><span class="line"><span class="bullet">   -</span> 特点：由节点（顶点）和边组成，表示对象之间的多对多关系。</span><br><span class="line"><span class="bullet">   -</span> 应用场景：社交网络分析、路线规划、网络流分析、编译器中的控制流图。</span><br><span class="line"></span><br><span class="line">每种数据结构的选择依据具体问题的需求，比如数据的访问模式（随机访问还是顺序访问）、数据的增删频率、数据的组织方式（线性还是非线性）等因素。</span><br></pre></td></tr></table></figure><h4 id="map的key是有序的吗"><a href="#map的key是有序的吗" class="headerlink" title="map的key是有序的吗"></a>map的key是有序的吗</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">是的，在C++中，<span class="code">`map`</span>的key是有序的。<span class="code">`map`</span>容器是通过红黑树实现的，它自动按照key的升序排序（默认情况下）。当你插入元素时，<span class="code">`map`</span>会根据key值将元素插入到适当的位置，以维护树的有序性。这使得对<span class="code">`map`</span>进行遍历会得到一个按key排序的序列。如果需要，你可以自定义比较函数来改变排序标准。</span><br></pre></td></tr></table></figure><h4 id="C-里面的内存分配方式，堆区和栈区的区别"><a href="#C-里面的内存分配方式，堆区和栈区的区别" class="headerlink" title="C++里面的内存分配方式，堆区和栈区的区别"></a>C++里面的内存分配方式，堆区和栈区的区别</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">C++中的内存分配方式主要涉及堆区（heap）和栈区（stack），它们有以下几点关键区别：</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 内存分配与管理：</span><br><span class="line"><span class="bullet">   -</span> 栈区：由编译器自动管理。当你声明局部变量或函数参数时，它们通常被分配在栈上。栈区的内存分配和释放非常快速，因为它只是调整栈指针。当函数调用结束或局部变量的作用域结束时，编译器会自动释放栈上分配的内存。</span><br><span class="line"><span class="bullet">   -</span> 堆区：需要程序员显式管理。通过<span class="code">`new`</span>运算符分配内存，并且必须使用<span class="code">`delete`</span>来释放内存。如果不释放，会导致内存泄漏。堆内存的分配和释放相对慢一些，因为系统需要维护一个空闲内存链表，并在分配时搜索合适的内存块，分配后还需更新链表。</span><br><span class="line"></span><br><span class="line"><span class="bullet">2.</span> 内存空间大小与连续性：</span><br><span class="line"><span class="bullet">   -</span> 栈区：空间相对较小，通常几兆字节，并且是连续的内存区域。栈溢出是常见的问题，尤其是当递归过深或局部变量过大时。</span><br><span class="line"><span class="bullet">   -</span> 堆区：空间更大，理论上仅受系统可用内存限制，内存分配不连续，通过链接不同的内存块来满足不同大小的请求。</span><br><span class="line"></span><br><span class="line"><span class="bullet">3.</span> 数据生命周期：</span><br><span class="line"><span class="bullet">   -</span> 栈区：数据生命周期与作用域相关，当作用域结束时，数据自动销毁。</span><br><span class="line"><span class="bullet">   -</span> 堆区：数据生命周期由程序员控制，直到显式释放或程序结束时由操作系统回收。</span><br><span class="line"></span><br><span class="line"><span class="bullet">4.</span> 访问速度：</span><br><span class="line"><span class="bullet">   -</span> 栈区：访问速度快，因为栈数据通常位于CPU的高速缓存附近。</span><br><span class="line"><span class="bullet">   -</span> 堆区：访问相对较慢，因为堆内存可能分布于内存的任何位置。</span><br><span class="line"></span><br><span class="line"><span class="bullet">5.</span> 用途：</span><br><span class="line"><span class="bullet">   -</span> 栈区：适用于短期、大小固定的内存需求，如局部变量、函数参数等。</span><br><span class="line"><span class="bullet">   -</span> 堆区：适用于长期、大小可变或未知的内存需求，如动态数组、大型数据结构、长时间存活的对象等。</span><br><span class="line"></span><br><span class="line">理解堆区和栈区的区别有助于编写更高效、更稳定的C++程序，合理选择内存分配方式对于程序性能和资源管理至关重要。</span><br></pre></td></tr></table></figure><h4 id="TCP-UDP的区别，三次握手四次分手"><a href="#TCP-UDP的区别，三次握手四次分手" class="headerlink" title="TCP/UDP的区别，三次握手四次分手"></a>TCP/UDP的区别，三次握手四次分手</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">TCP（Transmission Control Protocol）和UDP（User Datagram Protocol）是两种主要的传输层协议，它们在网络通信中扮演着不同的角色，主要区别在于连接性、可靠性、顺序保证和速度等方面：</span><br><span class="line"></span><br><span class="line"><span class="section">### TCP（传输控制协议）</span></span><br><span class="line"><span class="bullet">-</span> 连接性：TCP是面向连接的协议，它在数据传输前需要通过三次握手建立连接，确保两端准备好进行数据交换。</span><br><span class="line"><span class="bullet">-</span> 可靠性：TCP提供可靠的服务，通过确认、重传机制以及错误校验来确保数据正确无误地到达接收端。</span><br><span class="line"><span class="bullet">-</span> 顺序保证：TCP保证数据包按序到达，即使在网络中乱序，接收端也会根据序列号重新排序。</span><br><span class="line"><span class="bullet">-</span> 流量控制：TCP有流量控制机制，可以防止发送方过快发送数据导致接收方无法处理。</span><br><span class="line"><span class="bullet">-</span> 拥塞控制：TCP还实现了拥塞控制，以适应网络条件的变化，避免网络拥塞。</span><br><span class="line"></span><br><span class="line"><span class="section">### UDP（用户数据报协议）</span></span><br><span class="line"><span class="bullet">-</span> 连接性：UDP是无连接的协议，数据发送前无需建立连接，直接发送数据报。</span><br><span class="line"><span class="bullet">-</span> 可靠性：UDP不保证数据包一定能到达接收端，也不保证数据包的顺序，适用于对实时性要求高而能容忍一定丢包的场景。</span><br><span class="line"><span class="bullet">-</span> 头部开销：UDP头部比TCP简单，开销小，因此在某些情况下可以提供更高的传输效率。</span><br><span class="line"><span class="bullet">-</span> 应用：常用于多媒体流、DNS查询、在线游戏等对延迟敏感且可以容忍少量数据丢失的应用。</span><br><span class="line"></span><br><span class="line"><span class="section">### 三次握手</span></span><br><span class="line">TCP的三次握手过程如下：</span><br><span class="line"><span class="bullet">1.</span> 客户端发送一个带SYN（同步序列编号，Synchronize Sequence Number）标志的数据包给服务器，请求建立连接。</span><br><span class="line"><span class="bullet">2.</span> 服务器收到SYN后，回应一个SYN/ACK（确认序列编号，Acknowledgment Number）标志的数据包，确认客户端的请求并要求客户端确认。</span><br><span class="line"><span class="bullet">3.</span> 客户端收到服务器的SYN/ACK后，再发送一个ACK数据包给服务器，确认连接请求。至此，连接建立完成。</span><br><span class="line"></span><br><span class="line"><span class="section">### 四次挥手</span></span><br><span class="line">TCP的四次挥手（连接释放）过程如下：</span><br><span class="line"><span class="bullet">1.</span> 当一方完成数据传输后，发送一个FIN（结束标志，Finish）报文给另一方，表明自己已经没有数据发送了。</span><br><span class="line"><span class="bullet">2.</span> 另一方收到FIN后，发送一个ACK报文作为应答，表示确认收到FIN。</span><br><span class="line"><span class="bullet">3.</span> 当另一方也完成数据发送后，同样发送一个FIN报文给对方。</span><br><span class="line"><span class="bullet">4.</span> 最初发送FIN的一方收到这个FIN后，发送ACK报文作为应答，此时等待一段时间（通常是2个最大段生存期，MSL）后，连接彻底关闭。</span><br><span class="line"></span><br><span class="line">综上所述，TCP通过三次握手建立连接保证了数据传输的可靠性，而四次挥手确保了连接的优雅关闭，释放资源。相比之下，UDP则更为轻量，牺牲了一定的可靠性来换取更低的延迟和更简单的实现。</span><br></pre></td></tr></table></figure><h4 id="p2p协议选tcp还是udp"><a href="#p2p协议选tcp还是udp" class="headerlink" title="p2p协议选tcp还是udp"></a>p2p协议选tcp还是udp</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">如果我来设计一个P2P（点对点）系统，我会考虑同时使用TCP和UDP，因为两者各有优势，结合使用可以更好地适应不同的网络环境和应用场景。</span><br><span class="line"></span><br><span class="line">使用TCP的原因：</span><br><span class="line"><span class="bullet">1.</span> 可靠性：TCP提供了数据传输的可靠性保障，通过确认、重传、错误校验和流量控制机制，确保数据能够准确无误地到达对端，这对于需要高数据完整性的应用非常重要。</span><br><span class="line"><span class="bullet">2.</span> 有序性：TCP保证数据包按照发送顺序到达，适合那些对数据顺序有严格要求的场景。</span><br><span class="line"><span class="bullet">3.</span> 连接管理：TCP的连接状态可以帮助追踪和管理对等点之间的连接，简化了会话管理和控制逻辑。</span><br><span class="line"></span><br><span class="line">使用UDP的原因：</span><br><span class="line"><span class="bullet">1.</span> 低延迟：UDP没有TCP的握手和确认过程，也没有复杂的拥塞控制，因此传输数据的延迟更低，适合实时性和交互性要求高的应用，如VoIP、在线游戏和视频流。</span><br><span class="line"><span class="bullet">2.</span> 穿透NAT：UDP相较于TCP更容易实现NAT穿越，通过UDP打洞技术可以在不支持UPnP或NAT-T等协议的网络环境下建立P2P连接。</span><br><span class="line"><span class="bullet">3.</span> 灵活性：UDP的无连接特性允许更灵活的数据包格式和传输策略，开发者可以自定义控制逻辑，实现特定应用的需求，如自定义的流量控制和错误恢复机制。</span><br><span class="line"></span><br><span class="line">综合策略：</span><br><span class="line">理想情况下，P2P系统可以采用TCP作为基础通信协议，确保数据传输的可靠性和有序性；同时利用UDP作为辅助，特别是在需要优化延迟、实现NAT穿越或者对数据包的控制有特殊需求的情况下。此外，系统可以根据网络环境的检测结果动态选择或切换协议，例如对于有良好网络条件且对实时性要求较高的场景优先使用UDP，而对于需要高度可靠传输的环境则依赖TCP。这样的混合策略可以最大化地提升P2P系统的适应性和性能。</span><br></pre></td></tr></table></figure><h4 id="http协议（http请求和http响应协议）"><a href="#http协议（http请求和http响应协议）" class="headerlink" title="http协议（http请求和http响应协议）"></a>http协议（http请求和http响应协议）</h4><h4 id="UDP如何实现可靠性"><a href="#UDP如何实现可靠性" class="headerlink" title="UDP如何实现可靠性"></a>UDP如何实现可靠性</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">UDP（User Datagram Protocol）本身是一个无连接的、不可靠的传输层协议，它不提供像TCP那样的确认、重传、排序等机制来确保数据包的可靠传输。然而，如果需要在UDP基础上实现可靠性，可以通过在应用层增加额外的逻辑来模拟TCP的部分功能，以下是实现UDP可靠性传输的一些常见策略：</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 序列号（Sequence Numbers）：为每个发送的数据包分配一个唯一的序列号，接收端可以依据序列号来检测数据包的丢失、重复或乱序，并通知发送端进行相应的处理。</span><br><span class="line"></span><br><span class="line"><span class="bullet">2.</span> 确认（Acknowledgments）：接收端接收到数据包后，向发送端发送一个确认包，告知哪些数据包已经收到。发送端可以根据这些确认信息判断是否需要重传未被确认的数据包。</span><br><span class="line"></span><br><span class="line"><span class="bullet">3.</span> 超时重传（Retransmission on Timeout）：发送数据包时启动一个计时器，如果在预定时间内没有收到对应的确认，就重传该数据包。超时时间的设置需要权衡网络延迟和重传效率。</span><br><span class="line"></span><br><span class="line"><span class="bullet">4.</span> 流量控制（Flow Control）：虽然不是直接保证可靠性，但通过控制发送速率以匹配接收端的处理能力，可以间接减少数据丢失的可能性。这可以通过接收端发送窗口通告实现，告诉发送端当前能接收多少数据。</span><br><span class="line"></span><br><span class="line"><span class="bullet">5.</span> 拥塞控制（Congestion Control）：监测网络状况并相应调整发送速率，以避免过多的数据包在网络中积压导致丢包。这在多跳网络和公共互联网中尤为重要。</span><br><span class="line"></span><br><span class="line"><span class="bullet">6.</span> 滑动窗口（Sliding Window）：这是一种流量控制和拥塞控制的机制，通过维护发送和接收窗口来控制数据的流动，确保不会因为发送过快而导致接收方无法处理。</span><br><span class="line"></span><br><span class="line"><span class="bullet">7.</span> 校验和（Checksums）：虽然UDP自身包含了头部校验和来检测数据损坏，但在应用层也可以实施更高级的错误检测和纠正编码，以提高数据的完整性。</span><br><span class="line"></span><br><span class="line">通过上述机制的组合，可以在应用层构建出一个相对可靠的UDP传输系统，尽管这样做会增加实现的复杂度并可能降低传输效率。实际上，已经有一些协议和框架（如RUDP、RTP、UDT等）在UDP的基础上实现了这些机制，以提供更为可靠的数据传输服务。</span><br></pre></td></tr></table></figure><h4 id="C-11-17新特性"><a href="#C-11-17新特性" class="headerlink" title="C++ 11 /17新特性"></a>C++ 11 /17新特性</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">C++11和C++17是C++编程语言现代化过程中非常重要的两个版本，它们引入了大量新特性，显著提高了代码的简洁性、效率和安全性。以下是这两个版本中的一些关键新特性概览：</span><br><span class="line"></span><br><span class="line"><span class="section">### C++11新特性</span></span><br><span class="line"><span class="bullet">1.</span> 自动类型推导（Auto）: 允许编译器根据初始值推断变量的类型，简化了类型声明，特别是对于复杂类型。</span><br><span class="line"><span class="bullet">2.</span> Lambda表达式: 引入了匿名函数，可以直接在代码中定义并立即使用。</span><br><span class="line"><span class="bullet">3.</span> 右值引用与移动语义: 支持转移而非复制对象，提升了性能，尤其是在处理临时对象和大对象时。</span><br><span class="line"><span class="bullet">4.</span> 范围for循环（Range-based for loop）: 提供了一种简洁的遍历容器或数组元素的方式。</span><br><span class="line"><span class="bullet">5.</span> 智能指针（Smart Pointers）: 如<span class="code">`std::unique_ptr`</span>和<span class="code">`std::shared_ptr`</span>，自动管理内存，减少了内存泄露的风险。</span><br><span class="line"><span class="bullet">6.</span> 线程库（Thread Library）: 标准化了多线程编程的支持，包括<span class="code">`std::thread`</span>、互斥锁、条件变量等。</span><br><span class="line"><span class="bullet">7.</span> 枚举类（Enum Classes）: 更安全的枚举类型，避免了枚举值的隐式转换。</span><br><span class="line"></span><br><span class="line"><span class="section">### C++17新特性</span></span><br><span class="line"><span class="bullet">1.</span> 结构化绑定（Structured Binding）: 允许从数组、tuple或自定义类型中解构绑定到多个变量，提高代码的可读性。</span><br><span class="line"><span class="bullet">2.</span> 泛型Lambda表达式: 扩展了Lambda表达式的能力，使其可以声明模板参数，从而处理任意类型。</span><br><span class="line"><span class="bullet">3.</span> std::optional: 表示可能缺失的值，提供了一种更安全的空值处理方式。</span><br><span class="line"><span class="bullet">4.</span> std::variant: 类似于加强版的联合体，能够安全地存储多种类型之一，并且知道当前存储的是哪种类型。</span><br><span class="line"><span class="bullet">5.</span> 文件系统库（Filesystem Library）: 标准化了文件操作接口，跨平台处理文件路径、目录等。</span><br><span class="line"><span class="bullet">6.</span> 并行算法（Parallel Algorithms）: 在<span class="code">`&lt;algorithm&gt;`</span>头文件中增加了并行版本的算法，如<span class="code">`std::sort`</span>，利用多核处理器加速计算。</span><br><span class="line"><span class="bullet">7.</span> 折叠表达式（Fold Expressions）: 使得模板元编程更加灵活，可以更简洁地实现元编程中的折叠操作。</span><br><span class="line"></span><br><span class="line">这些新特性不仅丰富了C++的标准库，还使得编写现代C++代码变得更加高效和安全。开发者应考虑利用这些特性来提升代码的质量和开发效率。</span><br></pre></td></tr></table></figure><h4 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">深拷贝和浅拷贝是计算机编程中关于对象复制的概念，主要涉及如何处理对象的属性，特别是指针或引用类型的成员变量。它们主要出现在面向对象编程语言中，如C++、Java等。理解深拷贝和浅拷贝的区别对于避免内存泄漏、数据不一致等问题至关重要。</span><br><span class="line"></span><br><span class="line"><span class="section">### 浅拷贝（Shallow Copy）</span></span><br><span class="line"><span class="bullet">-</span> 定义：浅拷贝只复制对象的指针或引用，而不复制指针所指向的数据。这意味着原始对象和拷贝对象共享同一份数据。如果一个对象被修改，另一个对象也会受到影响。</span><br><span class="line"><span class="bullet">-</span> 实现：在C++中，如果类没有自定义拷贝构造函数或赋值运算符，编译器会自动生成一个浅拷贝版本。</span><br><span class="line"><span class="bullet">-</span> 例子：假设有两个类对象，其中一个对象的指针成员指向一块动态分配的内存，浅拷贝只会复制这个指针，导致两个对象都指向同一块内存。</span><br><span class="line"></span><br><span class="line"><span class="section">### 深拷贝（Deep Copy）</span></span><br><span class="line"><span class="bullet">-</span> 定义：深拷贝不仅复制对象本身，还递归地复制对象内部的所有指针变量所指向的数据。结果是原始对象和拷贝对象拥有完全独立的数据副本，互不影响。</span><br><span class="line"><span class="bullet">-</span> 实现：在C++中，通常需要手动定义拷贝构造函数或赋值运算符来实现深拷贝，确保指针成员所指向的数据也被复制。</span><br><span class="line"><span class="bullet">-</span> 例子：同样是两个类对象，深拷贝会为指针成员指向的数据分配新的内存，复制数据内容，使得两个对象各自拥有独立的数据副本。</span><br><span class="line"></span><br><span class="line"><span class="section">### 区别总结</span></span><br><span class="line"><span class="bullet">-</span> 数据独立性：深拷贝的两个对象数据完全独立，修改一个对象不会影响另一个；而浅拷贝的对象共享数据，一个对象的修改会影响到另一个。</span><br><span class="line"><span class="bullet">-</span> 内存使用：深拷贝会占用更多的内存，因为它需要复制所有数据；浅拷贝则不复制数据，只是复制指针，节省内存但可能导致数据不一致问题。</span><br><span class="line"><span class="bullet">-</span> 适用场景：当对象包含动态分配的内存或资源时，应使用深拷贝以确保数据的完整性和独立性。对于简单类型或不需要独立副本的情况，浅拷贝可能更合适。</span><br><span class="line"></span><br><span class="line">在实际编程中，根据对象的特性正确选择和实现拷贝方式是非常重要的。</span><br></pre></td></tr></table></figure><h4 id="C-的多态是怎么实现的"><a href="#C-的多态是怎么实现的" class="headerlink" title="C++的多态是怎么实现的"></a>C++的多态是怎么实现的</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">C++中的多态主要通过虚函数（virtual functions）和动态绑定（dynamic binding，也称作迟绑定或运行时绑定）来实现。以下是其实现原理的详细说明：</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 虚函数（Virtual Functions）:</span><br><span class="line"><span class="bullet">   -</span> 虚函数是在基类中声明的，使用关键字<span class="code">`virtual`</span>标识。它的主要目的是允许在派生类中重写该函数，以实现不同的行为。</span><br><span class="line"><span class="bullet">   -</span> 每个含有虚函数的类都会有一个虚函数表（Virtual Table，简称vtable），这是一个存储类中所有虚函数指针的表。vtable在编译时期由编译器生成。</span><br><span class="line"><span class="bullet">   -</span> 当创建一个类的实例时，该实例会包含一个指向其所属类vtable的指针（称为vptr）。这个指针通常在对象的内存布局中是隐藏的。</span><br><span class="line"></span><br><span class="line"><span class="bullet">2.</span> 动态绑定（Dynamic Binding）:</span><br><span class="line"><span class="bullet">   -</span> 动态绑定意味着在运行时决定调用哪个函数实现，这取决于对象的实际类型而不是引用或指针的类型。</span><br><span class="line"><span class="bullet">   -</span> 当通过基类的指针或引用来调用虚函数时，程序不是直接跳转到编译时期确定的地址，而是通过对象的vptr查找vtable，然后根据vtable中对应虚函数的地址调用函数。</span><br><span class="line"><span class="bullet">   -</span> 如果派生类重写了基类的虚函数，则调用时会执行派生类中的版本，实现了多态行为。</span><br><span class="line"></span><br><span class="line"><span class="bullet">3.</span> 重写（Overriding）:</span><br><span class="line"><span class="bullet">   -</span> 在派生类中，你可以重写基类的虚函数，提供自己的实现。为了正确实现重写，派生类中的函数需要与基类中的虚函数具有相同的签名（函数名、返回类型及参数列表）。</span><br><span class="line"><span class="bullet">   -</span> 重写的函数默认也是虚函数，除非明确使用<span class="code">`final`</span>关键字禁止进一步重写。</span><br><span class="line"></span><br><span class="line"><span class="bullet">4.</span> 纯虚函数与抽象类:</span><br><span class="line"><span class="bullet">   -</span> 纯虚函数是在基类中声明但没有具体实现的虚函数，需要在派生类中实现。声明纯虚函数的类不能实例化，此类被称为抽象类。</span><br><span class="line"><span class="bullet">   -</span> 抽象类通常作为接口使用，定义了一组需要派生类实现的接口规范。</span><br><span class="line"></span><br><span class="line">通过上述机制，C++允许程序员编写灵活且可扩展的代码，其中基类的指针或引用可以指向不同派生类的对象，并且能够调用这些对象的特定实现，而无需显式地知道对象的确切类型，从而实现了多态性。</span><br></pre></td></tr></table></figure><h4 id="C-继承的实现原理"><a href="#C-继承的实现原理" class="headerlink" title="C++继承的实现原理"></a>C++继承的实现原理</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">C++中的继承实现原理主要是通过以下几个方面体现的：</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 内存布局：当一个派生类从基类继承时，派生类的对象内存布局会首先包含基类的全部非静态数据成员，接着才是派生类自己新增的数据成员。这意味着，派生类对象中包含了基类的所有数据，从而能够访问和操作这些数据。</span><br><span class="line"></span><br><span class="line"><span class="bullet">2.</span> 虚函数表：C++中，如果基类或派生类中定义了至少一个虚函数，则编译器会为该类生成一个虚函数表（vtable）。这个表是一个函数指针数组，存储了所有虚函数的地址。每个具有虚函数的类都有自己的虚函数表，派生类的虚函数表会从基类继承，并在其基础上添加或覆盖相应的函数指针。派生类对象会有一个指向自己虚函数表的隐藏指针（称为vptr），这使得在运行时能够根据对象的实际类型动态调用正确的虚函数。</span><br><span class="line"></span><br><span class="line"><span class="bullet">3.</span> 构造函数和析构函数的调用顺序：构造函数的调用顺序是从基类到派生类，即先调用基类的构造函数，再调用派生类自己的构造函数。析构函数的调用顺序则相反，先调用派生类的析构函数，再调用基类的析构函数。这种顺序确保了资源的正确初始化和释放。</span><br><span class="line"></span><br><span class="line"><span class="bullet">4.</span> 访问权限：继承时，基类的公有（public）和保护（protected）成员对派生类是可见的，而私有（private）成员则不可见。派生类可以进一步指定继承的方式（public, protected, private），影响派生类对象对基类成员的访问权限以及派生类的继承性。</span><br><span class="line"></span><br><span class="line"><span class="bullet">5.</span> 多态性：通过虚函数，C++实现了动态多态。派生类可以重写基类的虚函数，当通过基类指针或引用来调用这些函数时，实际执行的是派生类中的实现。这是通过运行时解析虚函数表来实现的。</span><br><span class="line"></span><br><span class="line"><span class="bullet">6.</span> 虚继承（virtual inheritance）：为了解决多继承情况下基类的重复问题（菱形问题），C++提供了虚继承机制。虚继承使得无论派生类有多少条路径继承同一个基类，基类的子对象在派生类中只有一份，从而解决了二义性和存储浪费的问题。</span><br><span class="line"></span><br><span class="line">通过上述机制，C++的继承不仅允许代码的复用，而且支持了面向对象的三大特性之一——多态，使得程序设计更加灵活和高效。</span><br></pre></td></tr></table></figure><h4 id="C-的整个编译过程"><a href="#C-的整个编译过程" class="headerlink" title="C++的整个编译过程"></a>C++的整个编译过程</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">C++的编译过程可以大致分为以下几个阶段：</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 预处理（Preprocessing）:</span><br><span class="line"><span class="bullet">   -</span> 这是编译的第一步，编译器使用预处理器（如cpp）处理源代码文件。预处理器负责展开宏定义、处理条件编译指令（如<span class="code">`#ifdef`</span>, <span class="code">`#endif`</span>）、移除注释、插入头文件（通过<span class="code">`#include`</span>指令）等。经过预处理后，生成一个没有预处理指令的纯源代码文件，通常以<span class="code">`.i`</span>或<span class="code">`.ii`</span>为扩展名。</span><br><span class="line"></span><br><span class="line"><span class="bullet">2.</span> 编译（Compilation）:</span><br><span class="line"><span class="bullet">   -</span> 在这个阶段，编译器（如g++或clang++）将预处理后的源代码转换为汇编语言。这个过程包括词法分析、语法分析、语义分析等，检查源代码的语法错误和类型错误，并进行各种优化。完成后，生成汇编代码文件，扩展名为<span class="code">`.s`</span>或<span class="code">`.asm`</span>。</span><br><span class="line"></span><br><span class="line"><span class="bullet">3.</span> 汇编（Assembly）:</span><br><span class="line"><span class="bullet">   -</span> 汇编器将汇编代码转换为目标代码（或目标对象文件），这是机器语言的一种低级表示形式，但还不是可执行文件。每个源文件通常会编译成一个单独的目标文件，扩展名可能是<span class="code">`.o`</span>或<span class="code">`.obj`</span>。</span><br><span class="line"></span><br><span class="line"><span class="bullet">4.</span> 链接（Linking）:</span><br><span class="line"><span class="bullet">   -</span> 链接器将所有目标文件以及任何所需的库文件连接在一起，形成最终的可执行文件。这个过程包括解析未解决的符号引用（如外部函数或全局变量）、调整代码段和数据段的地址、去除未使用的代码（如果开启了相应选项）等。链接成功后，就得到了可以直接运行的可执行文件，其扩展名依赖于操作系统，如Windows下的<span class="code">`.exe`</span>，Linux下的无扩展名或<span class="code">`.out`</span>等。</span><br><span class="line"></span><br><span class="line"><span class="bullet">5.</span> 可选的优化步骤:</span><br><span class="line"><span class="bullet">   -</span> 在编译和链接过程中，编译器和链接器可能会执行各种级别的优化，以提高生成代码的效率。这些优化可能包括循环优化、内联函数展开、常量传播等，旨在减少代码大小、提高执行速度或降低能耗。</span><br><span class="line"></span><br><span class="line">综上所述，C++的整个编译过程涉及从高级语言源代码到可执行文件的多个转换步骤，确保了代码的平台兼容性和高效执行。</span><br></pre></td></tr></table></figure><h4 id="cpu-1ghz数每毫秒运行几次"><a href="#cpu-1ghz数每毫秒运行几次" class="headerlink" title="cpu 1ghz数每毫秒运行几次"></a>cpu 1ghz数每毫秒运行几次</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CPU的时钟频率，也就是这里的1GHz（千兆赫兹），表示CPU每秒钟可以进行10亿（1,000,000,000）个周期。要计算每毫秒（千分之一秒）能执行多少个周期，我们可以做如下换算：</span><br><span class="line"></span><br><span class="line">1GHz = 1,000,000,000Hz</span><br><span class="line"></span><br><span class="line">这意味着每秒10亿个周期，那么每毫秒的周期数为：</span><br><span class="line"></span><br><span class="line">1,000,000,000Hz/1,000 = 1,000,000周期/毫秒</span><br><span class="line"></span><br><span class="line">所以，一个1GHz的CPU每毫秒可以执行1百万个周期。</span><br><span class="line"></span><br><span class="line">然而，要注意的是，这仅是指CPU的时钟周期，并不直接等同于指令执行次数。一条C++指令可能需要一个或多个时钟周期来完成，具体取决于CPU架构、指令类型及是否发生缓存命中等因素。因此，实际的C++指令执行次数会少于这个理论值。为了得到更精确的每毫秒指令执行次数，还需要考虑程序的具体情况和CPU的性能特征。</span><br></pre></td></tr></table></figure><h4 id="CPU时间片"><a href="#CPU时间片" class="headerlink" title="CPU时间片"></a>CPU时间片</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CPU时间片（Time Slice）是操作系统中用于实现进程（或线程）调度的基本概念之一。在现代多任务操作系统中，CPU时间被划分为多个微小的时间片段，每个正在执行的进程或线程被分配一段这样的时间片来使用CPU。当一个进程或线程用完它的时间片后，操作系统会暂停其执行，保存其上下文（即当前的执行状态），然后将CPU控制权交给下一个进程或线程，这个过程称为上下文切换。</span><br><span class="line"></span><br><span class="line">CPU时间片机制的主要目的和作用包括：</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 实现多任务处理：通过快速地在多个进程或线程间切换，给用户一种多个任务同时运行的错觉，即使在单CPU或多核CPU系统上也能实现并发执行。</span><br><span class="line"></span><br><span class="line"><span class="bullet">2.</span> 公平性：确保系统中的每个进程都有机会使用CPU，防止某个进程长时间独占CPU资源，从而保证了系统整体的响应性和公平性。</span><br><span class="line"></span><br><span class="line"><span class="bullet">3.</span> 提高系统响应性：即使有长时间运行或等待某些事件（如I/O操作）的进程，通过时间片轮转，可以让其他准备好的进程有机会执行，减少系统延迟。</span><br><span class="line"></span><br><span class="line"><span class="bullet">4.</span> 灵活性：操作系统可以根据进程的不同需求和优先级动态调整时间片的长度，比如对实时性要求高的进程可以分配较短的时间片以减少响应延迟，而对于批处理任务可以给予较长的时间片。</span><br><span class="line"></span><br><span class="line">CPU时间片的长度由操作系统的设计者设定，通常在几毫秒到几十毫秒之间，具体取决于系统的设计目标和负载情况。较短的时间片可以提高系统的响应速度和交互性，但会增加上下文切换的开销；较长的时间片减少了切换频率，提高了CPU效率，但可能导致某些进程等待时间变长。</span><br></pre></td></tr></table></figure><h4 id="对称和非对称加密"><a href="#对称和非对称加密" class="headerlink" title="对称和非对称加密"></a>对称和非对称加密</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">对称加密和非对称加密是现代密码学中两种基本的加密方法，它们在确保数据的安全传输和存储中扮演着至关重要的角色，但工作原理和适用场景有所不同。</span><br><span class="line"></span><br><span class="line"><span class="section">### 对称加密</span></span><br><span class="line"><span class="bullet">-</span> 原理：对称加密使用相同的密钥进行数据的加密和解密。这意味着发送方和接收方必须共享同一个密钥，并且在通信前需要通过安全的渠道交换这个密钥。</span><br><span class="line"><span class="bullet">-</span> 优点：对称加密算法通常处理速度快，加密和解密效率高，适合处理大量数据。</span><br><span class="line"><span class="bullet">-</span> 缺点：密钥管理是其主要挑战，因为所有参与方都需要相同的密钥，一旦密钥泄露，加密数据的安全性就会受到威胁。</span><br><span class="line"><span class="bullet">-</span> 典型应用：对称加密常用于如TLS/SSL协议中的数据传输加密、数据库加密、磁盘加密等场景。</span><br><span class="line"></span><br><span class="line"><span class="section">### 非对称加密</span></span><br><span class="line"><span class="bullet">-</span> 原理：非对称加密使用一对密钥，分别是公钥和私钥。公钥用于加密数据，私钥用于解密数据。公钥可以公开分享，而私钥必须保密。</span><br><span class="line"><span class="bullet">-</span> 优点：安全性高，因为私钥不需要在网络中传输，降低了密钥泄露的风险。此外，非对称加密还支持数字签名，增强信息的完整性和验证发送者的身份。</span><br><span class="line"><span class="bullet">-</span> 缺点：相比对称加密，非对称加密的计算复杂度高，处理速度慢，不适合直接用于大量数据的加密。</span><br><span class="line"><span class="bullet">-</span> 典型应用：非对称加密常用于密钥交换（如TLS握手阶段）、数字签名、加密电子邮件、软件签名等场景。</span><br><span class="line"></span><br><span class="line"><span class="section">### 结合使用</span></span><br><span class="line">在实际应用中，对称加密和非对称加密经常结合使用以互补优缺点。例如，在TLS协议中，首先使用非对称加密来安全地交换对称密钥，随后使用这个对称密钥来高效地加密大量数据传输，这样既保证了密钥交换的安全性，又保证了数据传输的效率。</span><br></pre></td></tr></table></figure><h4 id="进程间通信常见几种方式和他们之间的区别、优缺点，详述"><a href="#进程间通信常见几种方式和他们之间的区别、优缺点，详述" class="headerlink" title="进程间通信常见几种方式和他们之间的区别、优缺点，详述"></a>进程间通信常见几种方式和他们之间的区别、优缺点，详述</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">进程间通信（IPC, Inter-Process Communication）是多进程系统中实现数据交换和协调的关键机制。下面详细介绍几种常见的进程间通信方式及其区别、优缺点：</span><br><span class="line"></span><br><span class="line"><span class="section">### 1. 共享内存（Shared Memory）</span></span><br><span class="line"><span class="bullet">-</span> 概念：多个进程共享同一块物理内存区域，通过读写这块内存来进行数据交换。</span><br><span class="line"><span class="bullet">-</span> 优点：</span><br><span class="line"><span class="bullet">  -</span> 速度快，因为数据直接在内存中交换，不需要通过内核进行复制。</span><br><span class="line"><span class="bullet">  -</span> 适用于大量数据的快速传输。</span><br><span class="line"><span class="bullet">-</span> 缺点：</span><br><span class="line"><span class="bullet">  -</span> 需要处理同步和互斥问题，避免数据一致性问题，可能导致竞态条件和死锁。</span><br><span class="line"><span class="bullet">  -</span> 对共享内存的访问控制复杂，需要使用信号量、互斥锁等机制来保证数据的正确性。</span><br><span class="line"></span><br><span class="line"><span class="section">### 2. 信号量（Semaphores）</span></span><br><span class="line"><span class="bullet">-</span> 概念：一种用于控制多个进程对共享资源访问的同步机制，通过计数来决定是否允许进程进入临界区。</span><br><span class="line"><span class="bullet">-</span> 优点：</span><br><span class="line"><span class="bullet">  -</span> 可以实现对共享资源的独占访问，有效避免竞态条件和死锁。</span><br><span class="line"><span class="bullet">  -</span> 适用于同步和互斥问题的解决。</span><br><span class="line"><span class="bullet">-</span> 缺点：</span><br><span class="line"><span class="bullet">  -</span> 相比直接的数据交换方式，增加了实现的复杂度。</span><br><span class="line"><span class="bullet">  -</span> 需要仔细管理信号量的使用，否则可能导致死锁或资源泄漏。</span><br><span class="line"></span><br><span class="line"><span class="section">### 3. 套接字（Sockets）</span></span><br><span class="line"><span class="bullet">-</span> 概念：最初用于网络通信，但也可用于同一主机上的进程间通信。</span><br><span class="line"><span class="bullet">-</span> 优点：</span><br><span class="line"><span class="bullet">  -</span> 跨平台性强，可在不同计算机或同一计算机的不同进程中通信。</span><br><span class="line"><span class="bullet">  -</span> 支持TCP和UDP等协议，适应不同的通信需求。</span><br><span class="line"><span class="bullet">-</span> 缺点：</span><br><span class="line"><span class="bullet">  -</span> 实现和管理相对复杂。</span><br><span class="line"><span class="bullet">  -</span> 需要考虑网络延迟和数据包丢失问题，可能影响实时性和可靠性。</span><br><span class="line"></span><br><span class="line"><span class="section">### 4. 管道（Pipes）</span></span><br><span class="line"><span class="bullet">-</span> 概念：分为无名管道和有名管道，是半双工的通信方式，数据只能单向流动。</span><br><span class="line"><span class="bullet">  -</span> 无名管道：主要用于有亲缘关系的进程间（如父子进程）。</span><br><span class="line"><span class="bullet">  -</span> 有名管道：允许无亲缘关系的进程间通信。</span><br><span class="line"><span class="bullet">-</span> 优点：</span><br><span class="line"><span class="bullet">  -</span> 实现简单，易于使用。</span><br><span class="line"><span class="bullet">  -</span> 有名管道可用于非亲缘进程通信。</span><br><span class="line"><span class="bullet">-</span> 缺点：</span><br><span class="line"><span class="bullet">  -</span> 半双工，数据只能单向传输，双向通信需建立两条管道。</span><br><span class="line"><span class="bullet">  -</span> 无名管道局限于亲缘进程间。</span><br><span class="line"></span><br><span class="line"><span class="section">### 5. 消息队列（Message Queues）</span></span><br><span class="line"><span class="bullet">-</span> 概念：消息按先进先出（FIFO）原则存储，进程间通过发送和接收消息进行通信。</span><br><span class="line"><span class="bullet">-</span> 优点：</span><br><span class="line"><span class="bullet">  -</span> 支持消息的异步发送和接收。</span><br><span class="line"><span class="bullet">  -</span> 可以实现进程间的解耦。</span><br><span class="line"><span class="bullet">-</span> 缺点：</span><br><span class="line"><span class="bullet">  -</span> 相对于共享内存，消息队列的通信效率较低。</span><br><span class="line"><span class="bullet">  -</span> 系统需要维护消息队列的额外开销。</span><br><span class="line"></span><br><span class="line"><span class="section">### 6. 信号（Signals）</span></span><br><span class="line"><span class="bullet">-</span> 概念：一种进程间轻量级的异步通信方式，用于通知进程发生了某种事件。</span><br><span class="line"><span class="bullet">-</span> 优点：</span><br><span class="line"><span class="bullet">  -</span> 简单、轻量，适用于简单的通知和紧急处理。</span><br><span class="line"><span class="bullet">-</span> 缺点：</span><br><span class="line"><span class="bullet">  -</span> 传递的信息有限，仅能携带少量数据（通常是信号编号）。</span><br><span class="line"><span class="bullet">  -</span> 不适合复杂的数据传输和通信。</span><br><span class="line"></span><br><span class="line"><span class="section">### 7. 共享文件（Shared Files）</span></span><br><span class="line"><span class="bullet">-</span> 概念：通过文件系统中的文件进行数据交换，如管道文件。</span><br><span class="line"><span class="bullet">-</span> 优点：</span><br><span class="line"><span class="bullet">  -</span> 实现简单，易于理解和使用。</span><br><span class="line"><span class="bullet">  -</span> 可以跨越网络共享。</span><br><span class="line"><span class="bullet">-</span> 缺点：</span><br><span class="line"><span class="bullet">  -</span> 同步问题复杂，易产生竞态条件。</span><br><span class="line"><span class="bullet">  -</span> 数据交换效率相对较低。</span><br><span class="line"></span><br><span class="line">每种方式都有其适用场景，选择合适的进程间通信方式需考虑通信的数据量、实时性要求、同步需求以及系统环境等因素。</span><br></pre></td></tr></table></figure><h4 id="单例模式怎么实现，能拷贝构造吗，单例的优点是什么"><a href="#单例模式怎么实现，能拷贝构造吗，单例的优点是什么" class="headerlink" title="单例模式怎么实现，能拷贝构造吗，单例的优点是什么"></a>单例模式怎么实现，能拷贝构造吗，单例的优点是什么</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">单例模式通常有几种实现方式，包括但不限于：</span><br><span class="line"></span><br><span class="line">饿汉式（静态实例）：在类加载时就完成了实例化，避免了线程同步问题。</span><br><span class="line">懒汉式（双重检查锁定）：延迟加载，在第一次使用时进行实例化，并通过双重检查锁定避免多次实例化。</span><br><span class="line">静态内部类：利用了classloader的机制来保证初始化instance时只有一个线程。</span><br><span class="line">枚举：在Java中推荐使用，C++中虽不常用，但也是一种实现方式。</span><br><span class="line">能拷贝构造吗？</span><br><span class="line"></span><br><span class="line">单例模式通常不允许拷贝构造和赋值操作，以确保只有一个实例存在。因此，单例类的拷贝构造函数和赋值操作符通常被声明为delete（在C++11及以后版本中）或声明为私有并不实现（在C++11之前）。</span><br><span class="line"></span><br><span class="line">单例的优点是什么？</span><br><span class="line"></span><br><span class="line">全局访问：可以在任何地方访问，无需频繁创建和销毁对象。</span><br><span class="line">节省资源：由于只有一个实例，避免了重复创建和销毁对象带来的资源消耗。</span><br><span class="line">管理方便：可以控制实例的创建和销毁，方便管理和维护。</span><br><span class="line">简化设计：在某些场景中，单例模式可以简化系统设计，如日志系统、配置管理等。</span><br></pre></td></tr></table></figure><h4 id="静态全局变量和静态局部变量"><a href="#静态全局变量和静态局部变量" class="headerlink" title="静态全局变量和静态局部变量"></a>静态全局变量和静态局部变量</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">静态全局变量和静态局部变量是C/C++编程中两种特殊的存储类别，它们的特点和区别主要体现在作用域、生命周期和存储位置上：</span><br><span class="line"></span><br><span class="line"><span class="section">### 静态全局变量</span></span><br><span class="line"><span class="bullet">-</span> 作用域：静态全局变量具有文件作用域，这意味着它只在定义它的源文件内是可见的。即便在多文件程序中，其他文件中的代码无法直接访问这个静态全局变量，除非通过extern关键字声明。</span><br><span class="line"><span class="bullet">-</span> 生命周期：静态全局变量的生命周期是整个程序的运行期间。从程序开始执行时创建，直到程序结束时才被销毁。</span><br><span class="line"><span class="bullet">-</span> 初始化：静态全局变量如果没有显式初始化，默认初始化为0（或相应的默认值，如NULL对于指针）。</span><br><span class="line"><span class="bullet">-</span> 存储位置：存储在程序的静态存储区域，不在堆栈上，因此不会因为函数调用结束而消失。</span><br><span class="line"></span><br><span class="line"><span class="section">### 静态局部变量</span></span><br><span class="line"><span class="bullet">-</span> 作用域：静态局部变量具有局部作用域，即它只在定义它的函数或代码块内可见。</span><br><span class="line"><span class="bullet">-</span> 生命周期：虽然作用域是局部的，但静态局部变量的生命周期却是整个程序的运行期间。这意味着即使函数被多次调用，静态局部变量也只会被初始化一次，并且在函数调用间保持其值。</span><br><span class="line"><span class="bullet">-</span> 初始化：同样地，如果没有显式初始化，静态局部变量也会被初始化为0（或相应的默认值）。</span><br><span class="line"><span class="bullet">-</span> 存储位置：和静态全局变量一样，存储在静态存储区域，不会因为函数返回而释放其存储空间。</span><br><span class="line"></span><br><span class="line"><span class="section">### 总结</span></span><br><span class="line">两者之间的主要差异在于作用域的不同：静态全局变量在整个文件内可见，而静态局部变量的作用域局限于定义它的函数或代码块。然而，它们都具有跨越函数调用的持久存储特性，存储在静态存储区，且生命周期都是整个程序执行期间。此外，静态局部变量因其局部作用域的特性，常用于需要在函数多次调用间保持状态的场景，而又不希望该状态对函数外部可见的情况。</span><br></pre></td></tr></table></figure><h4 id="简单的实现一个string类"><a href="#简单的实现一个string类" class="headerlink" title="简单的实现一个string类"></a>简单的实现一个string类</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 默认构造函数，初始化为空字符串</span></span><br><span class="line">    <span class="built_in">String</span>() : <span class="built_in">data_</span>(<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>]), <span class="built_in">length_</span>(<span class="number">0</span>) &#123;</span><br><span class="line">        data_[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化为指定C字符串的构造函数</span></span><br><span class="line">    <span class="built_in">String</span>(<span class="keyword">const</span> <span class="keyword">char</span>* str) &#123;</span><br><span class="line">        length_ = <span class="built_in">strlen</span>(str);</span><br><span class="line">        data_ = <span class="keyword">new</span> <span class="keyword">char</span>[length_ + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(data_, str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">String</span>(<span class="keyword">const</span> String&amp; other) &#123;</span><br><span class="line">        length_ = other.length_;</span><br><span class="line">        data_ = <span class="keyword">new</span> <span class="keyword">char</span>[length_ + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(data_, other.data_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动构造函数（C++11及以上）</span></span><br><span class="line">    <span class="built_in">String</span>(String&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        data_ = other.data_;</span><br><span class="line">        length_ = other.length_;</span><br><span class="line">        other.data_ = <span class="literal">nullptr</span>;</span><br><span class="line">        other.length_ = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">String</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] data_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值运算符重载</span></span><br><span class="line">    String&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> String&amp; other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] data_;</span><br><span class="line">            length_ = other.length_;</span><br><span class="line">            data_ = <span class="keyword">new</span> <span class="keyword">char</span>[length_ + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(data_, other.data_);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取字符串长度</span></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> length_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; data_ &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* data_;   <span class="comment">// 指向字符串数据的指针</span></span><br><span class="line">    <span class="keyword">size_t</span> length_; <span class="comment">// 字符串长度</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">s1</span><span class="params">(<span class="string">&quot;Hello, World!&quot;</span>)</span></span>;</span><br><span class="line">    s1.<span class="built_in">print</span>(); <span class="comment">// 输出: Hello, World!</span></span><br><span class="line">    String s2 = s1; <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">    s2.<span class="built_in">print</span>(); <span class="comment">// 输出: Hello, World!</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h5 id="1-智能指针"><a href="#1-智能指针" class="headerlink" title="1.智能指针"></a>1.智能指针</h5><ul><li>底层实现</li><li>QPointer、QScopedPointer、QSharedDataPointer</li></ul><h5 id="2-指针"><a href="#2-指针" class="headerlink" title="2.指针"></a>2.指针</h5><ul><li>指针常量和常量指针的区别</li></ul><h5 id="3-构造析构"><a href="#3-构造析构" class="headerlink" title="3.构造析构"></a>3.构造析构</h5><ul><li>基类构造, 子类构造, 子类成员变量的构造顺序是什么</li></ul><h5 id="4-虚函数"><a href="#4-虚函数" class="headerlink" title="4.虚函数"></a>4.<strong>虚函数</strong></h5><ul><li>多态中，父类与子类的虚表一样吗？如果一个子类的方法用了override关键字呢，虚表又是否相同</li><li>多继承下的虚函数表</li><li>虚表指针的大小</li><li>虚函数和纯虚函数的区别</li></ul><h5 id="5-线程和进程"><a href="#5-线程和进程" class="headerlink" title="5.线程和进程"></a>5.<strong>线程和进程</strong></h5><ul><li>多线程用过吗, 交互有哪些方式</li><li>多线程读写同一个静态变量你是怎么解决的</li><li><code>QTimer</code>是在哪个线程？<code>QTimer</code>为什么启动和停止要在同一个线程？</li><li><code>qt</code>中生成线程的方式？继承<code>QThread</code>,重写<code>run</code>函数与<code>moveToThread</code>的区别？</li><li>进程通信，共享内存如何实现进程安全</li><li>线程池了解吗</li><li>linux 查看进程</li><li>linux 线程和进程的调度</li><li>一个线程1在读文件，主线程退出了，怎么让线程1也退出不继续读</li><li>为什么要用qthread管理多线程？windows自己也有回调机制？</li><li>线程池，申请多少个线程池，比较合适?会不会使用GPU?</li><li>多线程加锁，会劣化性能，请问有什么优化的手段？</li><li>写一个线程不安全的例子, 再把它改为线程安全</li><li>进程间通信方式？线程呢？</li><li>QT的多线程，你用了哪些技术.哪些是只有Qthread能做的，QtConcurrent办不到的.</li><li>如果同时有1000个访问请求，线程池只有8个线程的情况下怎么处理</li></ul><h5 id="6-Qt"><a href="#6-Qt" class="headerlink" title="6.Qt"></a>6.Qt</h5><ul><li>对qt有啥了解，使用qt线程池做过什么</li><li>QT的object类作为所有控件的基类，做了哪些工作，发挥了什么作用</li><li>qobject parent的用处</li><li>qt mfc这种框架怎么和计算机底层交互的</li><li>写一个用户登录界面的逻辑 要求实现多个方法的验证(用户名密码, 手机验证码, 人脸登录等) 并可以后序添加模块</li><li>消息循环机制 消息队列为空怎么办</li><li>写QT的时候尝试用过cmake吗</li><li>Qt内存管理机制</li><li>Qt如何只释放子窗口</li><li>Qt中一些类的构造函数中经常有一个指针参数，用过吗</li><li>moc元编译器元对象</li><li>多线程中是如何使用信号槽的</li><li>项目中如何维护各控件的生命周期</li><li>如何保证只打开一个exe.当打开了exe1的时候，如果再打开exe1第二次，会将exe1之前打开的旧窗口调出，并最大化显示.</li><li>QWidget和QML的区别，在渲染层面</li><li>GPU渲染和CPU渲染，之间的区别是什么</li><li>兄弟窗口，想刷新他们的重叠部分，请问流程是什么样的，刷新的顺序是什么样的</li><li>父子窗口间的刷新管理？兄弟窗口间的刷新管理?如何让子窗口刷新，父窗口不刷新</li><li>show() exec()区别</li><li>Qt Remote Object的序列化与反序列化</li><li>软件如果出现问题，如何去定位的，如何处理的?静态扫描和动态检测，有哪些方法.</li><li>用QT实现一个三角形的按钮，会如何实现?</li><li>使用QT渲染的时候，有没有遇到显卡适配的问题？</li><li>制作一个按钮，会躲避鼠标，鼠标一旦移动上去，按钮就会跑</li><li>除了用鼠标移动去控制指针以外，我们还有很多方式去控制，他都会触发mouseMove事件吗</li><li>鼠标指针，可以移动，除了鼠标键盘可以控制，某些触摸板/触控屏，他们触发的都是mouseEvent吗？</li><li>qgraphscene/ qgraphitem的填充模式，任意一个多边形，它的填充模式有哪些?</li><li>qgraphscene的内存开销，刷新的性能</li></ul><h5 id="7-信号槽"><a href="#7-信号槽" class="headerlink" title="7.信号槽"></a>7.信号槽</h5><ul><li>Qt槽函数在单线程和多线程的区别</li><li>信号与槽，是如何去提高它的匹配性能的，一个信号，如何高效地去找它的槽函数</li><li>一个线程上的对象发出signal，另一个线程上的对象响应slot，这其中会有多线程相关的问题吗</li></ul><h5 id="8-数据结构"><a href="#8-数据结构" class="headerlink" title="8.数据结构"></a>8.数据结构</h5><ul><li>数组的存放方式有: 链表,索引,顺序?</li><li>图搜索,dfs</li><li>B+树和B树的区别？数据库的几个隔离级别，具体如何实现的？</li><li>二分查找</li><li>大端小端判定</li><li>左值和右值</li><li>二叉树如何求深度</li><li>如何求第k大的元素</li><li>unicode和utf-8</li><li>数组/链表区别</li><li>二维数组按行、按列读取速度的差异</li><li>vector 动态扩容底层，扩容机制</li><li>两个 vector 一个放普通数据类型一个放指针，扩容有什么区别</li><li>malloc 和 free 如何知道释放内存具体大小</li><li>宏定义放在哪里</li><li>为什么要内存对齐</li><li>vector和map查找效率</li><li>栈溢出的产生与避免</li><li>内存布局，静态变量和全局变量会放在哪里</li><li>常用的stl容器</li><li>stl的map和hashmap有什么区别，效率方面</li><li>weak_ptr的例子，简单写一下会出现的问题并介绍下</li><li>unordered_map的实现和map的实现</li><li>vector和list的区别</li><li>vector删除一个元素需要注意些什么</li><li>左右值转换</li><li>双向链表和环形链表用在什么场景</li><li>手写自己设计的vector</li><li>用过哪些容器，迭代器失效？</li><li>.int，long long占多少字节</li></ul><h5 id="9-网络基础"><a href="#9-网络基础" class="headerlink" title="9.网络基础"></a>9.网络基础</h5><ul><li>ping的底层原理</li><li>除了ping还有什么命令可以去检测该主机网络是否正常，具体命令</li><li>http1.1相比1.0 http2.0相比1.x的区别</li><li>http和https的区别</li><li>一个https的url输入到浏览器到页面显示 发生了什么</li><li>抓过包吗 https抓包会抓到什么</li><li>我们用腾讯会议聊天的话，用TCP还是UDP，为什么</li><li>计算机网络七层</li><li>GET和POST</li><li>浏览器输入URL后会经历什么过程</li></ul><h5 id="10-其他"><a href="#10-其他" class="headerlink" title="10.其他"></a>10.其他</h5><ul><li>操作系统常见的文件操作函数</li><li>传入派生类的引用, 调用谁的成员函数</li><li>for ++i i++区别</li><li>编程：排序,奇数全放前面</li><li>做过的项目里哪一个是最满意的, 讲一下这个项目</li><li>原子操作有用过吗, 有什么作用</li><li>函数有几种传参方式, 哪种情况用哪种方式</li><li>有用过linux吗, 755权限代表什么含义</li><li>vector的reserve函数和resize函数有什么区别</li><li>什么情况下会使用静态变量</li><li>用过无锁编程吗，知道原子量吗</li><li>你知道MQTT吗？</li><li> Linux系统中阻塞和非阻塞的区别</li><li>volatile关键字的作用</li><li>window的消息队列</li><li>项目中心跳检测机制如何实现的</li><li>说一下C++的move构造和拷贝构造是怎么实现的</li><li>C++模板元编程中的 enable_if 说一下，有什么应用</li><li>多态是如何实现的</li><li>动态绑定与静态绑定说一下，哪个更高效</li><li>结构体和class的区别</li><li>程序编译过程</li><li>函数模板用过吗</li><li>wondows 消息循环</li><li>预防内存泄漏方式</li><li>了解json格式吗</li><li>类中的引用计数</li><li>Lambda表达式</li><li>动态链接、静态链接</li><li>C++面向对象的特性</li><li>MVC和MVVM</li><li>怎么保证生成的随机数是均匀分布的</li><li>抽奖会得到四种道具概率分别不同，该怎么实现这个程序</li><li>假设有几万个号码算出来他们的MD5以16进制存储，然后有一个新的号码算出来它的MD5值，现在要判断这个值在不在之前的数据当中，该怎么实现不能调用库函数</li><li>有没有自己重写过自定义控件</li><li>宏定义如何使用（直接替换），嵌套宏定义如何使用，展开顺序</li><li>关键字inline、类与结构的区别、explicit关键字.</li><li>C++的类型转换</li><li>一个浏览器的网页，包含前进和后退功能，使用哪种数据结构来存放历史网页，比较合适</li><li>windows系统下，是怎么实现窗口刷新(窗口刷新机制);是立即刷新，还是异步刷新;每次我需要一个窗口刷新，他都能立马刷新吗</li><li>说说windows系统的内存管理，怎么实现共享内存？操作系统层面是如何完成这个过程的</li><li>如何分析dump文件</li><li>如何排查出代码里已经存在的内存泄漏问题，线上的内存泄漏</li><li>class前项申明和include的区别</li><li>什么情况下，delete需要加一个中括号[]</li><li>装饰器模式/门面模式/中介者模式，他们的代码实现和优缺点</li><li>共享内存的流程(底层原理)</li><li>自己有没有实现过读写锁?</li><li>乐观锁和悲观锁的区别，自旋锁，是一种乐观锁吗?</li><li>dynamic_cast怎么保证安全的？</li><li>如果有一块内存，如何知道内存是被人正在使用的，还是忘记delete导致内存泄漏的?</li><li>堆内存分配的时候，需要找寻足够大的内存，如果没有足够大的内存怎么办</li><li>const成员如何进行初始化</li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++原生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++原生int和string互换</title>
      <link href="/article/74ffeb25.html"/>
      <url>/article/74ffeb25.html</url>
      
        <content type="html"><![CDATA[<h3 id="int转string"><a href="#int转string" class="headerlink" title="int转string"></a>int转string</h3><p>在C++中将int类型的变量转换为字符串可以使用std::to_string()函数。下面是示例代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">1234567890</span>;</span><br><span class="line">    </span><br><span class="line">    string strNum = <span class="built_in">to_string</span>(num); <span class="comment">// 将int转换为string</span></span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;转换后的字符串为：&quot;</span> &lt;&lt; strNum &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="string转int"><a href="#string转int" class="headerlink" title="string转int"></a>string转int</h3><p>在C++中将字符串转换为int类型可以使用std::stoi()函数。下面是示例代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string strNum = <span class="string">&quot;1234567890&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> num = <span class="built_in">stoi</span>(strNum); <span class="comment">// 将string转换为int</span></span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;转换后的整数为：&quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="char-数字-转int数字"><a href="#char-数字-转int数字" class="headerlink" title="char(数字)转int数字"></a>char(数字)转int数字</h3><p>这里有个坑是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a = <span class="string">&#x27;2&#x27;</span>; </span><br><span class="line"><span class="keyword">int</span> n = (<span class="keyword">int</span>)a;</span><br><span class="line"><span class="comment">//这个时候n其实=50，不是2，是因为当 char 直接 赋给 int 时，实际上是把 char 变量的ASCII 码赋给 int类型，因此取出char 变量的数值不能通过直接转换成int的方法实现</span></span><br></pre></td></tr></table></figure><p>所以正确做法是，利用char变量使用 ASCII进行算术运算这一特征，可以得到一种间接计算获取数值的方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a = <span class="string">&#x27;2&#x27;</span>; </span><br><span class="line"><span class="keyword">int</span> n = a - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="comment">//这个时候n就=2了</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++原生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双映射问题</title>
      <link href="/article/8bff5ea8.html"/>
      <url>/article/8bff5ea8.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>双射说明两个映射表互为映射关系，正反都可推</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isIsomorphic</span><span class="params">(string s, string t)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    map&lt;<span class="keyword">char</span>, <span class="keyword">char</span>&gt; t2s, s2t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) </span><br><span class="line">    &#123;</span><br><span class="line">         <span class="keyword">char</span> a = s[i], b = t[i];</span><br><span class="line">         <span class="keyword">if</span> (s2t.<span class="built_in">contains</span>(a) &amp;&amp; s2t[a] != b || t2s.<span class="built_in">contains</span>(b) &amp;&amp; t2s[b] != a)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      </span><br><span class="line">         s2t[a] = b;</span><br><span class="line">         t2s[b] = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++原生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>std实现字符串分割</title>
      <link href="/article/6586823f.html"/>
      <url>/article/6586823f.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>今天在刷leetcode题的时候发现c++原生和std并没有类似于QString的.split()功能，还需要自己实现，随用std的正则表达式实现了这个功能</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; res;</span><br><span class="line"><span class="function">std::regex <span class="title">reg</span><span class="params">(<span class="string">&quot;\\s+&quot;</span>)</span></span>; <span class="comment">// 正则表达式,匹配空格 </span></span><br><span class="line"><span class="function">std::sregex_token_iterator <span class="title">pos</span><span class="params">(s.begin(), s.end(), reg, <span class="number">-1</span>)</span></span>;</span><br><span class="line"><span class="keyword">decltype</span>(pos) end;              <span class="comment">// 自动推导类型 </span></span><br><span class="line"><span class="keyword">for</span>(; pos != end; ++pos)</span><br><span class="line">&#123;</span><br><span class="line">    res.<span class="built_in">push_back</span>(pos-&gt;<span class="built_in">str</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++原生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023年总结</title>
      <link href="/article/9b8a73a1.html"/>
      <url>/article/9b8a73a1.html</url>
      
        <content type="html"><![CDATA[<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>23年真的是不平凡的一年，发生了好多好多事，这篇回顾文写的持续时间也比较长，我怕到年底的时候不能完整的回忆起每件事</p><p>首先1月份搬家到了北辰时代大厦这边，不得不说风景是真的好，不光挨着鸟巢，上下班都路过鸟巢，工位也高大上了好多，甚至在工位上一扭头就能看到鸟巢风景，还解锁了大年二十八九下班路上，鸟巢公园空无一人的奇观；坏处肯定也是有的，通勤时间从35分钟变成了1小时20分钟，时间长了也麻木了；物价也高了很多，消费开支都高了</p><p>过年的时候两家终于见面了，老爸找了保定会馆，据说在这里的原因是“保证能定”;我对象在第二天也来我家串门吃饭，终于定了在柏润东方大酒店办婚礼</p><p>然后，年后回来上班，从3月份开始了一个大项目，持续到了7月底，前中期几乎每天都在加班，9点后走打车报销是常事，期间各种改需求，赶进度，动不动崩溃，过程很痛苦</p><p>同时我自己的人生大事也在同步推进：3月20号求婚，想了很多最后还是在出租屋里求婚了，期间还发生了趣事，本来照常点下班的对象下午意外撒了咖啡，又是个周五，对象就提前回来了，导致我没布置完就匆匆忙忙躲起来了；还是3月，逛婚博会定了北遇的婚纱；4月份婚纱照拍了，出片了，但是不满意，又约了重拍，同时定了婚庆公司；5月份重拍了婚纱照，5月21号订了婚；6月中旬出了婚纱照片的精修，两个人很满意，还跟着对象俩人玩了第一次剧本杀；7月份就是挑婚纱，最后定婚礼方案；8月份一直在备婚，很多很多事情，动不动就崩溃；8月26号，两个人办了婚礼，这可真是一辈子的大事，很开心</p><p>9月份两个人自驾去乌兰察布玩了，还住了帐篷，晚上还下大暴雨，两个人在帐篷里边看手机视频边吃小火锅，感觉太特别了，很难忘</p><p>以上的段落写在我23年9月份的时候，现在回看一下心态还真的是完全不同；接下来的段落是在24年1月初写的，后边的状况急转直下</p><p>10月份的时候就开始有消息说公司要整个搬到深圳，leader当时还比较乐观，说不太可能，我也觉得不太可能整个全搬到深圳，公司里有很多的老员工，光赔偿金都不够赔的  </p><p>后边部门就开始没活干了，一度到了要员工自己找活干的程度了，我明白这是研发领导跟leader可能有恩怨，连带一起打压我们部门了，申请的工作全都不让做  </p><p>12月初的时候，研发领导开大会，直接就说要进行搬家和大裁员，确实是挺让人意外的，但还是觉得可能动作不会那么快，而且裁也裁不到我，毕竟我的能力大家都是认可的  </p><p>后来我们一起去钢琴行看了电钢琴，花一万买了一架KAWAI CA401，我很喜欢，又可以重拾之前的爱好了，只是希望后续有足够的时间练琴，也能坚持下去  </p><p>月中的时候，某天晚上我照常下班坐昌平线地铁，从西二旗到沙河高教园的时候，突发事故了，当时我只感觉我整个人飞了出去，然后我摔到了某人的上边，我的上边也压着两三个人，挣扎着起来之后发现地铁撞车了，一片混乱，又经过了漫长的两个多小时的等待，我们全都从车上下来了，顺着地铁一路走回了西二旗地铁站，后又因为打不到车，手机又没电了，又徒步走到了新龙泽医院，最后还是玥玥从沙河高教园打车过来接我回去才得以回家的，有生之年竟然上了一次热搜，地铁事故这种超小概率事件能碰上也是神奇··  </p><p>12月末的时候，事情就急转直下了，先是各个部门大裁员，保定部门直接没了，然后就我们部门没动静，后来就是leader开会说可能裁一半，再到24年1月3号（昨天）的时候，leader私聊找我说我在裁员名单上了，事情才尘埃落定了  </p><h3 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h3><p>不知道说什么，现在脑袋其实乱糟糟的，被裁员肯定难过还是有的，但不被裁的话，说实话也干不下去了，没什么意义，还是挺想拿了赔偿休息一阵的，毕竟后边干几十年呢，想出去旅个游还要等放假，我放假别人也放假，人多物价也贵；但又很烦接下来的谈判过程，通过和各个同事的聊天过程后已经预感到了不是一个轻松的过程；还有拿到赔偿后，现在又是年底，过完年了之后找工作的情况也是未知数，还是有些焦虑的····总而言之言而总之，还是希望自己能整理好心情吧，努力把该做的事情做好，希望24年末回顾的时候，自己能有一个满意的结果，加油吧！！</p>]]></content>
      
      
      <categories>
          
          <category> 感悟 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 年度总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt模态窗口点击窗外消失</title>
      <link href="/article/4a371b70.html"/>
      <url>/article/4a371b70.html</url>
      
        <content type="html"><![CDATA[<p>今天遇到个麻烦事，模态窗口、置顶、无父；要实现点窗口外关窗口功能，失焦事件之类的全部失效，查了好多后有了一个很好的解决方案：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setWindowFlags</span>(Qt::FramelessWindowHint | Qt::Popup | Qt::NoDropShadowWindowHint);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt防连点</title>
      <link href="/article/d2b5f7ee.html"/>
      <url>/article/d2b5f7ee.html</url>
      
        <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 避免连续点击</span></span><br><span class="line"><span class="keyword">static</span> DWORD tick1 = <span class="number">0</span>;</span><br><span class="line">DWORD tick2 = <span class="built_in">GetTickCount</span>();</span><br><span class="line"><span class="keyword">if</span> (tick2 - tick1 &gt; <span class="number">200</span>)</span><br><span class="line">&#123;</span><br><span class="line">    tick1 = tick2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt设置窗口居中显示</title>
      <link href="/article/29e34681.html"/>
      <url>/article/29e34681.html</url>
      
        <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//移动窗体到屏幕中央</span></span><br><span class="line">QRect rect = m_pWidget-&gt;<span class="built_in">frameGeometry</span>();</span><br><span class="line">QScreen* screen = QGuiApplication::<span class="built_in">primaryScreen</span>();</span><br><span class="line">QPoint point = screen-&gt;availableGeometry.<span class="built_in">center</span>();</span><br><span class="line">rect.<span class="built_in">moveCenter</span>(point);</span><br><span class="line">m_pWidget-&gt;<span class="built_in">move</span>(rect.<span class="built_in">topLeft</span>());</span><br><span class="line">m_pWidget-&gt;<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt限制软件某日期后不能使用</title>
      <link href="/article/a0b9096a.html"/>
      <url>/article/a0b9096a.html</url>
      
        <content type="html"><![CDATA[<p>在main.cpp里：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QDate <span class="title">overDate</span><span class="params">(<span class="number">2023</span>,<span class="number">6</span>,<span class="number">28</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> days = overDate.<span class="built_in">daysTo</span>(QDate::<span class="built_in">currentDate</span>());</span><br><span class="line"><span class="keyword">if</span>(days &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt正则表达式筛手机号</title>
      <link href="/article/9fa9795d.html"/>
      <url>/article/9fa9795d.html</url>
      
        <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QRegExp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QRegExpValidator&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsValidPhoneNumber</span><span class="params">(<span class="keyword">const</span> QString &amp; phoneNum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QRegExp <span class="title">regx</span><span class="params">(<span class="string">&quot;^1([358][0-9]|4[579]|66|7[0135678]|9[89])[0-9]&#123;8&#125;$&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">QRegExpValidator <span class="title">regs</span><span class="params">(regx, <span class="number">0</span>)</span></span>;</span><br><span class="line">    QString pNum = phoneNum;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    QValidator::State res = regs.<span class="built_in">validate</span>(pNum, pos);</span><br><span class="line">    <span class="keyword">if</span> (QValidator::Acceptable == res) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt快速转换路径(斜杠与反斜杠转换)</title>
      <link href="/article/c2e86a2f.html"/>
      <url>/article/c2e86a2f.html</url>
      
        <content type="html"><![CDATA[<ul><li><p>使用<code>QDir::fromNativeSeparators</code></p></li><li><p>示例：</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QString path = <span class="string">&quot;C:\\temp/test.txt&quot;</span>;</span><br><span class="line">path = QDir::<span class="built_in">fromNativeSeparators</span>(path);</span><br></pre></td></tr></table></figure><ul><li>输出</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:/temp/test.txt</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt实现边框圆角图片</title>
      <link href="/article/577bc24c.html"/>
      <url>/article/577bc24c.html</url>
      
        <content type="html"><![CDATA[<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QPixmap&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QPainter&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QSize&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QBitmap&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QPainterPath&gt;</span></span></span><br><span class="line"></span><br><span class="line">Widget::<span class="built_in">Widget</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::Widget)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    ui-&gt;label-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;background-color:transparent;&quot;</span></span><br><span class="line">                             <span class="string">&quot;border: 1px solid rgba(0,0,0,1);&quot;</span></span><br><span class="line">                             <span class="string">&quot;border-radius: 8px;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> w = ui-&gt;label-&gt;<span class="built_in">width</span>() - <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> h = ui-&gt;label-&gt;<span class="built_in">height</span>() - <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">QPixmap <span class="title">pixmapback</span><span class="params">(<span class="string">&quot;://images/test.jpeg&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">QPixmap <span class="title">pixmap</span><span class="params">(w,h)</span></span>;</span><br><span class="line">    pixmap.<span class="built_in">fill</span>(Qt::transparent);</span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(&amp;pixmap)</span></span>;</span><br><span class="line">    painter.<span class="built_in">setRenderHints</span>(QPainter::Antialiasing | QPainter::SmoothPixmapTransform);</span><br><span class="line">    QPainterPath path;</span><br><span class="line">    path.<span class="built_in">addRoundedRect</span>(<span class="number">0</span>, <span class="number">0</span>, w, h,<span class="number">8</span>,<span class="number">8</span>);    <span class="comment">//绘制圆角</span></span><br><span class="line">    painter.<span class="built_in">setClipPath</span>(path);</span><br><span class="line">    painter.<span class="built_in">drawPixmap</span>(<span class="number">0</span>, <span class="number">0</span>, w, h, pixmapback);</span><br><span class="line"></span><br><span class="line">    ui-&gt;label-&gt;<span class="built_in">setPixmap</span>(pixmap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不同DPI固定窗口位置显示探索</title>
      <link href="/article/36353022.html"/>
      <url>/article/36353022.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近做项目，需求要求不管在什么DPI下，都要保证一个小窗口，显示在一个相对大屏固定位置的地方，误差要求很小。   </p><p>一开始我的思路是按比例设，Qt的坐标（0,0）在左上角，我就以屏幕宽度的90%，屏幕高度的80%，Move窗口，结果出现了意外的情况，右侧的窗口，在比例正确的情况下总是会有一部分跑到屏幕外边去，而且DPI越大跑的越多；经调查后发现了一些需要注意的点。  </p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>其实按比例设置xy坐标的做法是正确的，只是这个xy只定住了窗口的左上角坐标，DPI发生变化后，虽然我一直给窗口设置的150px*50px，其实相对于屏幕的显示大小，发生了变化，DPI越大，窗口相对于当前的屏幕就越大；所以对于相同位置的点，因为窗口变大了，show出来的窗口就会发生偏移。这里有两种解决思路：  </p><p>1.从右往左算出来距离，不要直接乘比例算，这样不管窗口的大小怎么变，窗口的最右侧永远也会空出来一段距离，只是这样算出来的点位置会发生一些偏移，无伤大雅</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">QRectF rect = QApplication::<span class="built_in">desktop</span>()-&gt;<span class="built_in">geometry</span>();</span><br><span class="line"><span class="keyword">int</span> nWidth = rect.<span class="built_in">width</span>();</span><br><span class="line"><span class="keyword">int</span> nHeight = rect.<span class="built_in">height</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//nWidth - nWidth*0.035 - toolBox-&gt;width() = 屏幕宽度-右侧要空出的间距-窗口本体的宽度</span></span><br><span class="line">toolBox-&gt;<span class="built_in">move</span>(nWidth - nWidth*<span class="number">0.035</span> - toolBox-&gt;<span class="built_in">width</span>(), nHeight*<span class="number">0.79</span>);</span><br><span class="line">toolBox-&gt;<span class="built_in">show</span>();</span><br><span class="line">toolBox-&gt;<span class="built_in">activateWindow</span>();</span><br></pre></td></tr></table></figure><p>2.对窗口也乘以比例，例如相对于3840px*2160px分辨率，窗口的大小是150px*50px，则当DPI为2.0时，分辨率就相当于1920px*1080px，那么窗口也要对应的➗2，才能保持相对位置不变</p><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><ul><li>[DPI] 1.0    3840  2120</li><li>[DPI] 1.25   3072 1688</li><li>[DPI] 1.5     2560 1400</li><li>[DPI] 1.75   2194 1195</li><li>[DPI] 2.0     1920 1040</li><li>[DPI] 2.25   1707 920</li><li>[DPI] 2.5     1536  824</li><li>[DPI] 2.75    1396 764</li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
            <tag> 跨平台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt跨平台路径表示法</title>
      <link href="/article/98434a1.html"/>
      <url>/article/98434a1.html</url>
      
        <content type="html"><![CDATA[<p>跨平台开发的时候，经常涉及到路径的表示问题，有单斜杠、双斜杠、双反斜杠等等，很容易出问题，所以直接用separator()方法代替斜杠即可，API原文：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QChar <span class="title">QDir::separator</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function">Returns the native directory separator: <span class="string">&quot;/&quot;</span> under Unix and <span class="string">&quot;\&quot; under Windows.</span></span></span><br><span class="line"><span class="string"><span class="function">You do not need to use this function to build file paths. If you always use &quot;</span>/<span class="string">&quot;, Qt will translate your paths to conform to the underlying operating system. If you want to display paths to the user using their operating system&#x27;s separator use toNativeSeparators().</span></span></span><br><span class="line"><span class="string"><span class="function">See also listSeparator().</span></span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
            <tag> 跨平台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022年总结</title>
      <link href="/article/7448189f.html"/>
      <url>/article/7448189f.html</url>
      
        <content type="html"><![CDATA[<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>2023年的第3天，写了这个回顾文章  </p><p>写这篇文章之前先回顾了一下21年的总结，总的来说22年跟预想的还是有很大变化的。  </p><p>首先，3月份预期的涨薪，名额都已经有我了，但因为新冠疫情公司效益不好，最后还是没涨，确实挺失望的；  </p><p>确实找到了新住处，3月底进行了一次搬家，这次搬到了更远的北六环，到公司的通勤时间也从30分钟变成了一个半小时，但房租着实便宜了不少，只是周边的环境过于荒凉，像一座孤岛，不知道今年房子到期后，会不会搬到沙河县城去，那里比现在住的这还是要热闹一些的；  </p><p>4月份买了一个富士微单相机，我很喜欢，拿着它拍了不少照片，也觉得多拍照片总归是好的，多年后这些照片就是宝贵的回忆；  </p><p>5月份还去了对象家里，第一次见了对方父母，本来预计今年年底两家见个面谈个订婚什么的，因为疫情也没能回去；</p><p>9月份我的猫，布丁，死了。因为反反复复的尿闭，也因为搬到了这里，附近并没有什么宠物医院，我跟对象焦急的想办法治它的时候，膀胱破裂很快就死了，我跟对象哭的哇哇的，我在一个大雨夜把它埋在了一所大学旁边的绿化带里，带着它喜欢的猫罐头和猫条，我觉得我这辈子都忘不了当时的场景；  </p><p>今年还因为新冠疫情，林林总总的在家居家办公了一个半月，到最后年底放开了，自己也感染了，还挺难受，又高烧又各种症状的，过了一个星期也算是挺过来了，对象照顾我结果把她也给传染了；    </p><p>预期的跳槽，也并没有跳，今年的形势比预想的还要严峻，新冠疫情搞的经济不行，各个大厂纷纷在裁员降薪，而且我自己今年有点偷懒，也没有怎么努力准备面试的东西，想想就先算了，稳稳再说（也因为这家公司的福利比较好，工作强度不大，休息时间多），23年会不会跳槽，说实话心里还没有一个定数，想着先总结一下以往几年工作的一些成果，哪怕说后边跳，手里也能拿出来一些东西，不至于工作了好几年，什么都没留下来；  </p><p>关于旅游，今年哪都没去玩，22年确实是没有意义的一年，我觉得多年后我也不想回忆起今年。  </p><h3 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h3><p>今年写的有点琐碎，感觉情绪整体也没有去年那么好，发生了好多事，疫情又反反复复的，闹到最后自己还是感染了；另一方面自己岁数也越来越大了，再过两年就30了，钱也没挣多少，有种莫名的焦虑。后边还有求婚，订婚，婚礼，买房，等等，每每想到就很焦虑，再加上自己程序员的职业特性，今年总结起来就俩字：<strong>焦虑</strong>  </p><p>对于2023年的期望，还是希望生活能逐渐的变好吧，通知说公司这周五要搬家到奥体公园旁边，挨着鸟巢，也不知道去那边了会有什么样新的展开；然后也希望跟对象的一系列事情也都能办完，顺利的求婚，顺利的订婚，顺利的婚礼    </p><p>虽然预料到一堆事压着，还是得撑着，一件一件给办了，<strong>加油吧</strong></p>]]></content>
      
      
      <categories>
          
          <category> 感悟 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 年度总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>判断Linux下程序是否在运行</title>
      <link href="/article/c421f6f2.html"/>
      <url>/article/c421f6f2.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这里提供两种可以判断Linux下某程序是否正在运行的方法，两种都是通过执行终端命令，获取结果并判断来实现的</p><h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">checkProgramRun</span><span class="params">(<span class="keyword">const</span> QString &amp; ProcessName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QString LinuxProcessName = ProcessName;</span><br><span class="line"></span><br><span class="line">    QProcess process;</span><br><span class="line">    process.<span class="built_in">setReadChannel</span>(QProcess::StandardOutput);</span><br><span class="line"></span><br><span class="line">    process.<span class="built_in">start</span>(<span class="string">&quot;ps -ef&quot;</span>);</span><br><span class="line">    process.<span class="built_in">waitForFinished</span>();</span><br><span class="line"></span><br><span class="line">    QByteArray bytes = process.<span class="built_in">readAll</span>();</span><br><span class="line">    process.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>* ch;</span><br><span class="line">    QByteArray ba = LinuxProcessName.<span class="built_in">toLatin1</span>(); <span class="comment">//must</span></span><br><span class="line">    ch = ba.<span class="built_in">data</span>();</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span>(bytes.<span class="built_in">contains</span>(ch))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h3><p>注：这里用到了grep，如果直接用QProcess的start方法执行命令是获取不到grep筛选后的结果的，暂不知原因，这里采用执行shell和echo打印相结合的方法可以成功打印出结果，但还是有小问题，结果是两行，这里只能出现一行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">checkProgramRun</span><span class="params">(<span class="keyword">const</span> QString &amp; ProcessName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QString LinuxProcessName = ProcessName;</span><br><span class="line"></span><br><span class="line">    QProcess process;</span><br><span class="line">    QStringList args;</span><br><span class="line">    args&lt;&lt;<span class="string">&quot;-c&quot;</span>;</span><br><span class="line">    QString strCommnd = <span class="built_in">QString</span>(<span class="string">&quot;echo $(ps -ef | grep %1 | grep -v grep)&quot;</span>).<span class="built_in">arg</span>(LinuxProcessName);</span><br><span class="line">    args&lt;&lt;strCommnd;</span><br><span class="line"></span><br><span class="line">    process.<span class="built_in">start</span>(<span class="string">&quot;sh&quot;</span>,args);</span><br><span class="line">    process.<span class="built_in">waitForFinished</span>();</span><br><span class="line"></span><br><span class="line">    QString programs = process.<span class="built_in">readAllStandardOutput</span>();</span><br><span class="line">    process.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(programs.<span class="built_in">contains</span>(LinuxProcessName))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt下调用系统功能</title>
      <link href="/article/b54bf0c4.html"/>
      <url>/article/b54bf0c4.html</url>
      
        <content type="html"><![CDATA[<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><strong>1.关闭窗口</strong><br>本质上就是发组合键：Alt+F4 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">closeWindow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined Q_OS_WIN</span></span><br><span class="line">    <span class="built_in">keybd_event</span>(VK_LMENU,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">keybd_event</span>(VK_F4,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">keybd_event</span>(VK_F4,<span class="number">0</span>,KEYEVENTF_KEYUP,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">keybd_event</span>(VK_LMENU,<span class="number">0</span>,KEYEVENTF_KEYUP,<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined Q_OS_LINUX</span></span><br><span class="line">    Display *disp = <span class="built_in">XOpenDisplay</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">XTestFakeKeyEvent</span>(disp, <span class="built_in">XKeysymToKeycode</span>(disp,XK_Alt_L), True, CurrentTime);</span><br><span class="line">    <span class="built_in">XTestFakeKeyEvent</span>(disp, <span class="built_in">XKeysymToKeycode</span>(disp,XK_F4), True, CurrentTime);</span><br><span class="line">    <span class="built_in">XTestFakeKeyEvent</span>(disp, <span class="built_in">XKeysymToKeycode</span>(disp,XK_F4), <span class="literal">false</span>, CurrentTime);</span><br><span class="line">    <span class="built_in">XTestFakeKeyEvent</span>(disp, <span class="built_in">XKeysymToKeycode</span>(disp,XK_Alt_L), <span class="literal">false</span>, CurrentTime);</span><br><span class="line">    <span class="built_in">XCloseDisplay</span>(disp);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.显示桌面</strong></p><p>本质上就是发组合键：Win+D</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showDesktop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined Q_OS_WIN</span></span><br><span class="line">    <span class="built_in">keybd_event</span>(VK_LWIN,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">keybd_event</span>(<span class="number">68</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">keybd_event</span>(<span class="number">68</span>,<span class="number">0</span>,KEYEVENTF_KEYUP,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">keybd_event</span>(VK_LWIN,<span class="number">0</span>,KEYEVENTF_KEYUP,<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined Q_OS_LINUX</span></span><br><span class="line">    Display *disp = <span class="built_in">XOpenDisplay</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">XTestFakeKeyEvent</span>(disp, <span class="built_in">XKeysymToKeycode</span>(disp,XK_Super_L), True, CurrentTime);</span><br><span class="line">    <span class="built_in">XTestFakeKeyEvent</span>(disp, <span class="built_in">XKeysymToKeycode</span>(disp,XK_D), True, CurrentTime);</span><br><span class="line">    <span class="built_in">XTestFakeKeyEvent</span>(disp, <span class="built_in">XKeysymToKeycode</span>(disp,XK_D), <span class="literal">false</span>, CurrentTime);</span><br><span class="line">    <span class="built_in">XTestFakeKeyEvent</span>(disp, <span class="built_in">XKeysymToKeycode</span>(disp,XK_Super_L), <span class="literal">false</span>, CurrentTime);</span><br><span class="line">    <span class="built_in">XCloseDisplay</span>(disp);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.Page Up/Page Down</strong></p><p>本质上就是模拟按下对应的键</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pageUp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined Q_OS_WIN</span></span><br><span class="line">    <span class="built_in">keybd_event</span>(VK_PRIOR,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">keybd_event</span>(VK_PRIOR,<span class="number">0</span>,KEYEVENTF_KEYUP,<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined Q_OS_LINUX</span></span><br><span class="line">    Display *disp = <span class="built_in">XOpenDisplay</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">XTestFakeKeyEvent</span>(disp, <span class="built_in">XKeysymToKeycode</span>(disp,XK_Page_Up), True, CurrentTime);</span><br><span class="line">    <span class="built_in">XTestFakeKeyEvent</span>(disp, <span class="built_in">XKeysymToKeycode</span>(disp,XK_Page_Up), <span class="literal">false</span>, CurrentTime);</span><br><span class="line">    <span class="built_in">XCloseDisplay</span>(disp);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pageDown</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined Q_OS_WIN</span></span><br><span class="line">    <span class="built_in">keybd_event</span>(VK_NEXT,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">keybd_event</span>(VK_NEXT,<span class="number">0</span>,KEYEVENTF_KEYUP,<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined Q_OS_LINUX</span></span><br><span class="line">    Display *disp = <span class="built_in">XOpenDisplay</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">XTestFakeKeyEvent</span>(disp, <span class="built_in">XKeysymToKeycode</span>(disp,XK_Next), True, CurrentTime);</span><br><span class="line">    <span class="built_in">XTestFakeKeyEvent</span>(disp, <span class="built_in">XKeysymToKeycode</span>(disp,XK_Next), <span class="literal">false</span>, CurrentTime);</span><br><span class="line">    <span class="built_in">XCloseDisplay</span>(disp);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4.多任务</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showDesktop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined Q_OS_WIN</span></span><br><span class="line">    <span class="built_in">keybd_event</span>(VK_CONTROL,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">keybd_event</span>(VK_LMENU,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">keybd_event</span>(VK_TAB,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">keybd_event</span>(VK_TAB,<span class="number">0</span>,KEYEVENTF_KEYUP,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">keybd_event</span>(VK_CONTROL,<span class="number">0</span>,KEYEVENTF_KEYUP,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">keybd_event</span>(VK_LMENU,<span class="number">0</span>,KEYEVENTF_KEYUP,<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined Q_OS_LINUX</span></span><br><span class="line">    Display *disp = <span class="built_in">XOpenDisplay</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">XTestFakeKeyEvent</span>(disp, <span class="built_in">XKeysymToKeycode</span>(disp,XK_Super_L), True, CurrentTime);</span><br><span class="line">    <span class="built_in">XTestFakeKeyEvent</span>(disp, <span class="built_in">XKeysymToKeycode</span>(disp,XK_W), True, CurrentTime);</span><br><span class="line">    <span class="built_in">XTestFakeKeyEvent</span>(disp, <span class="built_in">XKeysymToKeycode</span>(disp,XK_W), <span class="literal">false</span>, CurrentTime);</span><br><span class="line">    <span class="built_in">XTestFakeKeyEvent</span>(disp, <span class="built_in">XKeysymToKeycode</span>(disp,XK_Super_L), <span class="literal">false</span>, CurrentTime);</span><br><span class="line">    <span class="built_in">XCloseDisplay</span>(disp);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
            <tag> 系统功能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt下的Hook</title>
      <link href="/article/4aa62fe6.html"/>
      <url>/article/4aa62fe6.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>底层hook（钩子）相关逻辑；包含键位和各种组合键的捕获方法，及与Qt类进行交互的逻辑，特此记录</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>源文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">HHOOK keyHook= <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//keyboard hook</span></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">keyProc</span><span class="params">(<span class="keyword">int</span> nCode, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    KBDLLHOOKSTRUCT *pkbhs = (KBDLLHOOKSTRUCT *) lParam;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(nCode == HC_ACTION)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pkbhs-&gt;vkCode == VK_ESCAPE &amp;&amp; <span class="built_in">GetAsyncKeyState</span>(VK_CONTROL)&amp; <span class="number">0x8000</span> &amp;&amp; <span class="built_in">GetAsyncKeyState</span>(VK_SHIFT)&amp;<span class="number">0x8000</span>) <span class="comment">//&quot;Ctrl+Shift+Esc&quot;</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pkbhs-&gt;vkCode == VK_ESCAPE &amp;&amp; <span class="built_in">GetAsyncKeyState</span>(VK_CONTROL) &amp; <span class="number">0x8000</span>)  <span class="comment">//&quot;Ctrl+Esc&quot;</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pkbhs-&gt;vkCode == VK_TAB &amp;&amp; pkbhs-&gt;flags &amp; LLKHF_ALTDOWN )    <span class="comment">//&quot;Alt+Tab&quot;</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pkbhs-&gt;vkCode == VK_ESCAPE &amp;&amp; pkbhs-&gt;flags &amp;LLKHF_ALTDOWN)  <span class="comment">//&quot;Alt+Esc&quot;</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pkbhs-&gt;vkCode == VK_F4 &amp;&amp; pkbhs-&gt;flags &amp; LLKHF_ALTDOWN)  <span class="comment">//&quot;Alt+F4&quot;</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(wParam == WM_KEYDOWN &amp;&amp; pkbhs-&gt;vkCode == VK_SNAPSHOT)  <span class="comment">//&quot;Prtic&quot;</span></span><br><span class="line">        &#123;</span><br><span class="line">            MainWindow::<span class="built_in">getInstance</span>()-&gt;<span class="built_in">todo</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(wParam == WM_KEYUP &amp;&amp; pkbhs-&gt;vkCode == VK_SNAPSHOT)</span><br><span class="line">        &#123;</span><br><span class="line">            MainWindow::<span class="built_in">getInstance</span>()-&gt;<span class="built_in">todo</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(wParam == WM_KEYDOWN &amp;&amp; pkbhs-&gt;vkCode == VK_LWIN)  <span class="comment">// &quot;LeftWin&quot;</span></span><br><span class="line">        &#123;</span><br><span class="line">            MainWindow::<span class="built_in">getInstance</span>()-&gt;<span class="built_in">todo</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(wParam == WM_KEYUP &amp;&amp; pkbhs-&gt;vkCode == VK_LWIN)</span><br><span class="line">        &#123;</span><br><span class="line">            MainWindow::<span class="built_in">getInstance</span>()-&gt;<span class="built_in">todo</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(wParam == WM_KEYDOWN &amp;&amp; pkbhs-&gt;vkCode == VK_RWIN)  <span class="comment">//&quot;RightWin&quot;</span></span><br><span class="line">        &#123;</span><br><span class="line">            MainWindow::<span class="built_in">getInstance</span>()-&gt;<span class="built_in">todo</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(wParam == WM_KEYUP &amp;&amp; pkbhs-&gt;vkCode == VK_RWIN)</span><br><span class="line">        &#123;</span><br><span class="line">            MainWindow::<span class="built_in">getInstance</span>()-&gt;<span class="built_in">todo</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(wParam == WM_KEYDOWN &amp;&amp; pkbhs-&gt;vkCode == VK_TAB)  <span class="comment">//&quot;TAB&quot;</span></span><br><span class="line">        &#123;</span><br><span class="line">            MainWindow::<span class="built_in">getInstance</span>()-&gt;<span class="built_in">todo</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(wParam == WM_KEYUP &amp;&amp; pkbhs-&gt;vkCode == VK_TAB)</span><br><span class="line">        &#123;</span><br><span class="line">            MainWindow::<span class="built_in">getInstance</span>()-&gt;<span class="built_in">todo</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(wParam == WM_KEYDOWN &amp;&amp; pkbhs-&gt;vkCode == <span class="number">68</span>)    <span class="comment">//&quot;Win+D&quot;</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">GetKeyState</span>(VK_LWIN))</span><br><span class="line">            &#123;</span><br><span class="line">                MainWindow::<span class="built_in">getInstance</span>()-&gt;<span class="built_in">todo</span>();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CallNextHookEx</span>(keyHook, nCode, wParam, lParam);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hook</span><span class="params">(<span class="keyword">bool</span> flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(flag)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//registered hooks</span></span><br><span class="line">        keyHook = <span class="built_in">SetWindowsHookEx</span>(WH_KEYBOARD_LL,keyProc,<span class="built_in">GetModuleHandle</span>(<span class="literal">nullptr</span>),<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">UnhookWindowsHookEx</span>(keyHook);</span><br><span class="line">        keyHook= <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MainWindow* instance;</span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent) : <span class="built_in">QMainWindow</span>(parent),<span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    instance = <span class="keyword">this</span>;</span><br><span class="line">    <span class="built_in">hook</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">hook</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">MainWindow *<span class="title">MainWindow::getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
            <tag> Hook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信号槽的特殊声明</title>
      <link href="/article/a204f63f.html"/>
      <url>/article/a204f63f.html</url>
      
        <content type="html"><![CDATA[<p>适用于槽函数逻辑较简单无须单独列出的情况：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QTimer* timer = <span class="keyword">new</span> <span class="built_in">QTimer</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="built_in">connect</span>(timer, &amp;QTimer::timeout, [ = ]()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QTimer::<span class="built_in">singleShot</span>(<span class="number">300</span>, <span class="keyword">this</span> , [ = ]</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
            <tag> 信号槽 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt高分屏适配方案</title>
      <link href="/article/a2642ebb.html"/>
      <url>/article/a2642ebb.html</url>
      
        <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>通过比例系数来实现高分屏适配，软件的每个UI组件尺寸都要乘以比例系数，以达到适配高分辨率的目的</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">win32:&#123;</span><br><span class="line">QT += winextras</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> Q_OS_WIN</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;windows.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="built_in">getWindowScaleFactor</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">double</span> scaleFactor = <span class="number">1.0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> Q_OS_WIN</span></span><br><span class="line">    <span class="keyword">int</span> nWidth = <span class="built_in">GetSystemMetrics</span>(SM_CXSCREEN);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    QRectF rect = QApplication::<span class="built_in">desktop</span>()-&gt;<span class="built_in">screenGeometry</span>();</span><br><span class="line">    <span class="keyword">int</span> nWidth = rect.<span class="built_in">width</span>();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(nWidth &gt;= <span class="number">3840</span> )</span><br><span class="line">    &#123;</span><br><span class="line">          scaleFactor = <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(nWidth &lt; <span class="number">3840</span> &amp;&amp; nWidth &gt; <span class="number">1366</span> )</span><br><span class="line">    &#123;</span><br><span class="line">          scaleFactor = <span class="number">1.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(nWidth &lt;= <span class="number">1366</span>  &amp;&amp; nWidth &gt; <span class="number">800</span> )</span><br><span class="line">    &#123;</span><br><span class="line">          scaleFactor = <span class="number">0.8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(nWidth &lt;= <span class="number">800</span>)</span><br><span class="line">    &#123;</span><br><span class="line">          scaleFactor = <span class="number">0.5</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//各类靠property获取比例系数</span></span><br><span class="line">    QApplication::<span class="built_in">instance</span>()-&gt;<span class="built_in">setProperty</span>(<span class="string">&quot;scalefactor&quot;</span>, dScaleFactor); </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
            <tag> 高分屏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt实现Http的Get/Post请求</title>
      <link href="/article/cdff3725.html"/>
      <url>/article/cdff3725.html</url>
      
        <content type="html"><![CDATA[<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">QT += network</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QNetworkAccessManager&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QNetworkRequest&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QNetworkReply&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建</span></span><br><span class="line"><span class="keyword">void</span> <span class="built_in">init</span>()</span><br><span class="line">&#123;</span><br><span class="line">    QNetworkAccessManager* manager = <span class="keyword">new</span> <span class="built_in">QNetworkAccessManager</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">connect</span>(manager,<span class="built_in">SIGNAL</span>(<span class="built_in">finished</span>(QNetworkReply*)),<span class="keyword">this</span>,<span class="built_in">SLOT</span>(<span class="built_in">replyFinished</span>(QNetworkReply*)));<span class="comment">//关联信号和槽</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//请求，以天气预报为例</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">queryWeather</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> quest_array[<span class="number">256</span>]=<span class="string">&quot;http://wthrcdn.etouch.cn/weather_mini?city=&quot;</span>;</span><br><span class="line">    QNetworkRequest quest;</span><br><span class="line">    <span class="built_in">sprintf</span>(quest_array,<span class="string">&quot;%s%s&quot;</span>,quest_array,cityName.<span class="built_in">toUtf8</span>().<span class="built_in">data</span>());</span><br><span class="line">    quest.<span class="built_in">setUrl</span>(<span class="built_in">QUrl</span>(quest_array));</span><br><span class="line">    quest.<span class="built_in">setHeader</span>(QNetworkRequest::UserAgentHeader,<span class="string">&quot;RT-Thread ART&quot;</span>);</span><br><span class="line">    <span class="comment">/*发送get网络请求*/</span></span><br><span class="line">    manager-&gt;<span class="built_in">get</span>(quest);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//响应</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replyFinished</span><span class="params">(QNetworkReply *reply)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    allinfo = reply-&gt;<span class="built_in">readAll</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;allinfo：&quot;</span>&lt;&lt;allinfo;</span><br><span class="line">    </span><br><span class="line">    QJsonParseError err;</span><br><span class="line">    QJsonDocument json_recv = QJsonDocument::<span class="built_in">fromJson</span>(allinfo.<span class="built_in">toUtf8</span>(),&amp;err);<span class="comment">//解析json对象</span></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt;<span class="string">&quot;Json-Error:&quot;</span>&lt;&lt; err.error;</span><br><span class="line">    <span class="keyword">if</span>(!json_recv.<span class="built_in">isNull</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        QJsonObject object = json_recv.<span class="built_in">object</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式判断版本号大小</title>
      <link href="/article/ad3e8609.html"/>
      <url>/article/ad3e8609.html</url>
      
        <content type="html"><![CDATA[<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compareVersion</span><span class="params">(QString ver1, QString ver2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QStringList list1 = ver1.<span class="built_in">replace</span>(<span class="built_in">QRegExp</span>(<span class="string">&quot;[a-zA-Z() ]&quot;</span>), <span class="string">&quot;&quot;</span>).<span class="built_in">split</span>(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">    QStringList list2 = ver2.<span class="built_in">replace</span>(<span class="built_in">QRegExp</span>(<span class="string">&quot;[a-zA-Z() ]&quot;</span>), <span class="string">&quot;&quot;</span>).<span class="built_in">split</span>(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (list1.<span class="built_in">size</span>() == <span class="number">3</span> &amp;&amp; list2.<span class="built_in">size</span>() == <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        qint32 ver1 = (list1.<span class="built_in">at</span>(<span class="number">0</span>).<span class="built_in">toInt</span>() &lt;&lt; <span class="number">16</span>) | (list1.<span class="built_in">at</span>(<span class="number">1</span>).<span class="built_in">toInt</span>() &lt;&lt; <span class="number">8</span>) | list1.<span class="built_in">at</span>(<span class="number">2</span>).<span class="built_in">toInt</span>();</span><br><span class="line">        qint32 ver2 = (list2.<span class="built_in">at</span>(<span class="number">0</span>).<span class="built_in">toInt</span>() &lt;&lt; <span class="number">16</span>) | (list2.<span class="built_in">at</span>(<span class="number">1</span>).<span class="built_in">toInt</span>() &lt;&lt; <span class="number">8</span>) | list2.<span class="built_in">at</span>(<span class="number">2</span>).<span class="built_in">toInt</span>();</span><br><span class="line">        <span class="keyword">return</span> ver2 &gt; ver1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt图片压缩</title>
      <link href="/article/54b18459.html"/>
      <url>/article/54b18459.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Qt本身就带图片压缩的方法，即利用QPixMap的save方法   </p><p>最后的效果很好，肉眼基本不可辨别，测试用一张微单拍摄的6K图，原图19.7MB，压缩后变为2.3MB </p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>完整流程：</p><figure class="highlight qt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> compressImage(QString path)</span><br><span class="line">&#123;</span><br><span class="line">    QFile file(ui-&gt;lineEdit-&gt;text());</span><br><span class="line">    <span class="keyword">if</span>(!file.open(<span class="attribute">QIODevice</span>::ReadWrite))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    QByteArray bytes = file.readAll();</span><br><span class="line">    QImage img;</span><br><span class="line">    img.loadFromData(bytes);</span><br><span class="line"></span><br><span class="line">    QPixmap bk_image;</span><br><span class="line">    bk_image.convertFromImage(img);</span><br><span class="line"></span><br><span class="line">    bk_image.save(path, nullptr, <span class="number">80</span>);<span class="comment">//压缩率从0-100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021年总结</title>
      <link href="/article/9f7fa39c.html"/>
      <url>/article/9f7fa39c.html</url>
      
        <content type="html"><![CDATA[<hr><h4 id="2021-12-31"><a href="#2021-12-31" class="headerlink" title="2021-12-31"></a>2021-12-31</h4><p>21年的最后一天了，也是同天写了这个文章</p><p>今年是变化巨大的一年，5月份我辞掉了工作三年的工作，来到了一家新公司，这里的工作我更喜欢也更轻松，当然挣得也更多了；搬了新的出租屋，从北京的南五环搬到了北五环，租了一个整居室，整个换了个大环境—后来被证明是个沙雕操作，每个月的房租都能跟买房的房贷持平了；还去了上海和成都旅游—在之前我从未出过河北省的地域范围；空余时间多了，在GitHub发布了很多我一直想要做的项目 ，还创建了这个博客，写了很多文章  </p><p>对于22年，当然还是有一些期望的，因为来公司的时候被HR压价了，我一直心里挺不舒服，尤其她后来得意洋洋的跟我回访的时候说她招到了一个宝（意思她用比这个岗位低的价换来了一个比预期能干的开发人员）， 我就坚定了我想要跳槽的想法。因为我一直在做Qt开发的关系，初步的想法是如果能去金山什么的，做做WPS也是很好的，如果其他的公司有合适的也不错；然后是要换一处房子，希望能找到一个合适的新住处····嗯，暂时就这些，当然也想把这个博客好好的弄下去，不光是对经验的一种总结，也包含一些感悟和记录吧</p>]]></content>
      
      
      <categories>
          
          <category> 感悟 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 年度总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt调用MacOS终端</title>
      <link href="/article/fa7e3d73.html"/>
      <url>/article/fa7e3d73.html</url>
      
        <content type="html"><![CDATA[<figure class="highlight qt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;QProcess&gt;</span><br><span class="line"></span><br><span class="line">QProcess pCmd = <span class="keyword">new</span> QProcess(<span class="keyword">this</span>);</span><br><span class="line">connect(pCmd , SIGNAL(readyReadStandardOutput()) , <span class="keyword">this</span> , SLOT(on_readoutput()));</span><br><span class="line">connect(pCmd , SIGNAL(readyReadStandardError()) , <span class="keyword">this</span> , SLOT(on_readerror()));</span><br><span class="line"></span><br><span class="line">pCmd-&gt;start(<span class="string">&quot;bash&quot;</span>);</span><br><span class="line">pCmd-&gt;waitForStarted();</span><br><span class="line"></span><br><span class="line">QString strTermCmd = <span class="string">&quot;git add -A&quot;</span> + <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">pCmd-&gt;write(strTermCmd.toUtf8().data());</span><br><span class="line">pCmd-&gt;waitForFinished();</span><br></pre></td></tr></table></figure><p>问题的关键就在这个<code>pCmd-&gt;start(&quot;bash&quot;);</code> </p>]]></content>
      
      
      <categories>
          
          <category> 开发笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
            <tag> 终端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RGB值Hex颜色值转换</title>
      <link href="/article/caeca79b.html"/>
      <url>/article/caeca79b.html</url>
      
        <content type="html"><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>输入RGB/Hex值，回车触发转换并自动复制结果到剪贴板，简单高效</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>回车生效的事件直接用的是QLineEdit自带的returnPressed()事件，而复制到剪贴板用到的是QClipboard类：  </p><figure class="highlight qt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;QClipboard&gt;</span><br><span class="line"></span><br><span class="line">QString str = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">QClipboard *clip = <span class="attribute">QApplication</span>::clipboard();</span><br><span class="line">clip-&gt;setText(str);</span><br></pre></td></tr></table></figure><p>这样这个”Hello”就自动复制到剪贴板里了.  </p><p>接下来最主要的就是颜色值的相互转换了，可以里用QColor类，先获取对应的color，然后再转换为对应的显示形式，这里贴上核心代码：  </p><figure class="highlight qt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;QColor&gt;</span><br><span class="line"></span><br><span class="line">QColor <span class="built_in">color</span>(<span class="number">235</span>,<span class="number">235</span>,<span class="number">235</span>);</span><br><span class="line"><span class="built_in">int</span> red = <span class="built_in">color</span>.red();</span><br><span class="line"><span class="built_in">int</span> green = <span class="built_in">color</span>.green();</span><br><span class="line"><span class="built_in">int</span> blue = <span class="built_in">color</span>.blue();</span><br><span class="line">QString strRed = QString(<span class="string">&quot;%1&quot;</span>).arg(red &amp; <span class="number">0xFF</span>, <span class="number">2</span>, <span class="number">16</span>, QLatin1Char(<span class="string">&#x27;0&#x27;</span>));</span><br><span class="line">QString strGreen = QString(<span class="string">&quot;%1&quot;</span>).arg(green &amp; <span class="number">0xFF</span>, <span class="number">2</span>, <span class="number">16</span>, QLatin1Char(<span class="string">&#x27;0&#x27;</span>));</span><br><span class="line">QString strBlue = QString(<span class="string">&quot;%1&quot;</span>).arg(blue &amp; <span class="number">0xFF</span>, <span class="number">2</span>, <span class="number">16</span>, QLatin1Char(<span class="string">&#x27;0&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//十六进制显示</span></span><br><span class="line">QString hex = QString(<span class="string">&quot;#%1%2%3&quot;</span>).arg(strRed.toUpper()).arg(strGreen.toUpper()).arg(strBlue.toUpper());</span><br><span class="line"><span class="comment">//RGB显示</span></span><br><span class="line">QString rgb = QString(<span class="string">&quot;%1, %2, %3&quot;</span>).arg(red).arg(green).arg(blue);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
            <tag> 颜色处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>将Hexo迁移至MacOS</title>
      <link href="/article/3e930800.html"/>
      <url>/article/3e930800.html</url>
      
        <content type="html"><![CDATA[<p>当时用的Windows搭建的这个博客，现在要迁移到我的MacBook Pro上来，在查了很多资料后动手实践，发现还是比较方便的，现写下流程  </p><h3 id="Node-js-Git"><a href="#Node-js-Git" class="headerlink" title="Node.js / Git"></a>Node.js / Git</h3><p>首先要安装Node.js与Git的环境，这里省略就不多说了</p><h3 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h3><p>将原Windows电脑上的博客复制如下的文件，并暂存起来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_config.yml</span><br><span class="line">package.json</span><br><span class="line">scaffolds/</span><br><span class="line">source/</span><br><span class="line">themes/</span><br></pre></td></tr></table></figure><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><ul><li>打开终端，当前路径均可，默认只会装在固定的位置</li><li>执行<code>sudo npm install -g hexo-cli</code> </li></ul><h3 id="初始化博客"><a href="#初始化博客" class="headerlink" title="初始化博客"></a>初始化博客</h3><p>在你想要放置博客的位置，然后操作：</p><ul><li>打开终端</li><li>执行<code>hexo init blog</code></li></ul><h3 id="博客迁移"><a href="#博客迁移" class="headerlink" title="博客迁移"></a>博客迁移</h3><p>将之前暂存的文件，全部替换到刚才创建的blog文件夹中，然后操作：</p><ul><li>打开终端</li><li>执行<code>npm install</code></li><li>执行<code>hexo g</code></li><li>执行<code>hexo d</code></li><li> 查看效果</li></ul><p>至此博客就成功迁移到MacOS中了，后续的操作与Windows下无差别</p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo搭建个人博客</title>
      <link href="/article/ec7d7221.html"/>
      <url>/article/ec7d7221.html</url>
      
        <content type="html"><![CDATA[<h3 id="Github-Pages"><a href="#Github-Pages" class="headerlink" title="Github Pages"></a>Github Pages</h3><p>Github Pages是Github推出的一项网站服务，有关Pages的核心就一点：**创建一个名为username.github.io的仓库。Github会自动识别为一个网站，网站的url就是username.github.io **</p><p>操作起来也很简单，<strong>步骤如下：</strong></p><ul><li>在Gtihub新建一个repository</li><li>在第一栏，<strong>Owner</strong>要选<strong>自己</strong>，<strong>Repository name</strong>填<strong>username.github.io</strong>，username就是你Github的用户名</li><li>可见性选Public，因为Pages free的账号只能public，有钱可以选Private，然后在新建之后的仓库Setting里，左侧栏选Pages，里边有升级成Pages Pro的选项，这样你的网站项目就可以隐藏，但每年要支付一定的费用</li><li>勾选 <strong>Initialize this repository with a README</strong></li><li>点<code>Create repository</code>按钮新建仓库</li></ul><p>此时你便拥有了自己的Pages个人主页，可以尝试输入网址打开看看，这个生成好的 Repository 就是用来存放博客内容的地方</p><h3 id="绑定个人域名"><a href="#绑定个人域名" class="headerlink" title="绑定个人域名"></a>绑定个人域名</h3><p>如果你有一个个人域名，也可以在Repository-Settings-Pages里的<strong>Custom domain</strong>选项填上自己的个人域名，这样你的Pages就和你的个人域名绑定了，输入你的域名就会自动跳转到你个人的Pages</p><h3 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h3><p>生成 Repository之后，接下来就是要往这个Repository 里搭博客了</p><p>Hexo是一款本地博客框架，可以运行一个本地的静态博客网站，如果你只需要在自己电脑用，那就不用Pages了</p><p>Hexo使用起来很方便，只要在本地编辑好.md后缀的文章，然后重新部署就可以了，而且Hexo官网提供了大量的主题模板</p><p><strong>1.搭建Node.js环境</strong></p><ul><li>前往 <a href="https://nodejs.org/en/">https://nodejs.org/en/</a></li><li>下载最新LTS版本</li><li>安装</li><li>打开<strong>Command Prompt</strong>，输入 <code>node -v</code></li><li>显示版本号</li><li>成功</li></ul><p><strong>2.安装Hexo</strong></p><ul><li>打开<strong>Command Prompt</strong></li><li>执行<code>npm install -g hexo-cli</code> </li><li>输入 <code>hexo -v</code>查看版本即安装成功</li></ul><p><strong>3.Hexo的初始化</strong></p><ul><li>创建blog文件夹，位置建议各盘根目录</li><li>打开任一终端(PowerShell/Windows Terminal/Git Bash等均可)，进入刚才创建的blog路径下</li><li>执行<code>hexo init</code> 将 blog 文件夹初始化</li><li>执行 <code>npm install</code> 安装依赖包</li><li>执行 <code>hexo g</code> 开始进行部署操作</li><li>执行 <code>hexo s</code> 将生成的网页放在本地服务器</li><li>打开浏览器，输入网址 <a href="http://localhost:4000/">http://localhost:4000/</a> 就可以看到本地的博客效果了</li><li>效果没问题，返回终端按 <code>Ctrl</code> + <code>C</code> 中止服务运行</li></ul><p><strong>4.发布博客文章</strong><br>发布博客文章也是较为简单的，需要在本地新建一个博客文档，打开本地进行编辑后，重新部署发布即可，操作如下：</p><ul><li>打开刚才的终端</li><li>在blog路径下执行 <code>hexo new &quot;Test&quot;</code></li><li>生成的.md文件路径在 <code>blog\source\_posts</code>下</li></ul><p>打开Test.md，会发现Hexo已经为我们生成了一个表头，表头的格式如下  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">title: Test                       //文章标题</span><br><span class="line">date: 2021-0X-XX XX:XX:XX         //生成日期</span><br><span class="line">tags:                             //所属标签</span><br></pre></td></tr></table></figure><p>然后，在其下随便写一些内容，保存<br>回到终端，执行<code>hexo g</code>部署，然后执行 <code>hexo s</code>发布，刷新 <a href="http://localhost:4000/">http://localhost:4000/</a> 查看结果</p><h3 id="在-Github-上部署-Hexo"><a href="#在-Github-上部署-Hexo" class="headerlink" title="在 Github 上部署 Hexo"></a>在 Github 上部署 Hexo</h3><p><strong>操作如下</strong>：</p><ul><li>复制Github Pages的仓库地址，如：<a href="https://github.com/SantaJiang/santajiang.github.io.git">https://github.com/SantaJiang/santajiang.github.io.git</a></li><li>修改配置文件<code>blog/_config.yml</code> ，最新版与之前的不同从这里开始了</li><li>查找**# Site**字段，修改如下：  </li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Santa的博客</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">&#x27;My personal blog&#x27;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&#x27;记录、分享、交流&#x27;</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">蒋胜达</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">en</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>查找**# URL**字段，修改如下：  </li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">https://santajiang.github.io/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br><span class="line"><span class="attr">pretty_urls:</span></span><br><span class="line">  <span class="attr">trailing_index:</span> <span class="literal">true</span> <span class="comment"># Set to false to remove trailing &#x27;index.html&#x27; from permalinks</span></span><br><span class="line">  <span class="attr">trailing_html:</span> <span class="literal">true</span> <span class="comment"># Set to false to remove trailing &#x27;.html&#x27; from permalinks</span></span><br></pre></td></tr></table></figure><p>注意url填写的是pages网址不是仓库地址</p><ul><li>查找<strong>deploy</strong>字段，修改如下：  </li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/one-command-deployment</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">repository:</span> <span class="string">git@github.com:SantaJiang/santajiang.github.io.git</span></span><br><span class="line"><span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure><p>这里要<strong>注意</strong>两点！</p><ol><li>Github后续更新了默认主分支的名称，已经不叫<strong>master</strong>了，改为了<strong>main</strong>，如果还是写<strong>master</strong>，并不会报错，但是会在<strong>main</strong>分支之外新建一个<strong>master</strong>分支</li><li>repository一栏必须填ssh的地址，因为GitHub的密码验证于2021年8月13日不再支持，也就是不能再用密码方式去提交代码。要使用<strong>personal access token</strong>替代，当然这里我建议用SSH免密登陆，具体GitHub如何配置SSH免密登陆的步骤不在这里详述了，然后继续：</li></ol><ul><li>回到终端，执行 <code>npm install hexo-deployer-git --save</code> 只需执行一次，后续无需再执行</li><li>执行 <code>hexo d</code> 部署</li><li>登录 santajiang.github.io.git 查看效果</li></ul>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
